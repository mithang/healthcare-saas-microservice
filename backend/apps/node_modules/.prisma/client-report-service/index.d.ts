
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model SystemOverview
 * 
 */
export type SystemOverview = $Result.DefaultSelection<Prisma.$SystemOverviewPayload>
/**
 * Model EducationKPI
 * 
 */
export type EducationKPI = $Result.DefaultSelection<Prisma.$EducationKPIPayload>
/**
 * Model LearningProgress
 * 
 */
export type LearningProgress = $Result.DefaultSelection<Prisma.$LearningProgressPayload>
/**
 * Model RevenueReport
 * 
 */
export type RevenueReport = $Result.DefaultSelection<Prisma.$RevenueReportPayload>
/**
 * Model UserAnalytics
 * 
 */
export type UserAnalytics = $Result.DefaultSelection<Prisma.$UserAnalyticsPayload>
/**
 * Model ExportTicket
 * 
 */
export type ExportTicket = $Result.DefaultSelection<Prisma.$ExportTicketPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more SystemOverviews
 * const systemOverviews = await prisma.systemOverview.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more SystemOverviews
   * const systemOverviews = await prisma.systemOverview.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.systemOverview`: Exposes CRUD operations for the **SystemOverview** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemOverviews
    * const systemOverviews = await prisma.systemOverview.findMany()
    * ```
    */
  get systemOverview(): Prisma.SystemOverviewDelegate<ExtArgs>;

  /**
   * `prisma.educationKPI`: Exposes CRUD operations for the **EducationKPI** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EducationKPIS
    * const educationKPIS = await prisma.educationKPI.findMany()
    * ```
    */
  get educationKPI(): Prisma.EducationKPIDelegate<ExtArgs>;

  /**
   * `prisma.learningProgress`: Exposes CRUD operations for the **LearningProgress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LearningProgresses
    * const learningProgresses = await prisma.learningProgress.findMany()
    * ```
    */
  get learningProgress(): Prisma.LearningProgressDelegate<ExtArgs>;

  /**
   * `prisma.revenueReport`: Exposes CRUD operations for the **RevenueReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RevenueReports
    * const revenueReports = await prisma.revenueReport.findMany()
    * ```
    */
  get revenueReport(): Prisma.RevenueReportDelegate<ExtArgs>;

  /**
   * `prisma.userAnalytics`: Exposes CRUD operations for the **UserAnalytics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserAnalytics
    * const userAnalytics = await prisma.userAnalytics.findMany()
    * ```
    */
  get userAnalytics(): Prisma.UserAnalyticsDelegate<ExtArgs>;

  /**
   * `prisma.exportTicket`: Exposes CRUD operations for the **ExportTicket** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExportTickets
    * const exportTickets = await prisma.exportTicket.findMany()
    * ```
    */
  get exportTicket(): Prisma.ExportTicketDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    SystemOverview: 'SystemOverview',
    EducationKPI: 'EducationKPI',
    LearningProgress: 'LearningProgress',
    RevenueReport: 'RevenueReport',
    UserAnalytics: 'UserAnalytics',
    ExportTicket: 'ExportTicket'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "systemOverview" | "educationKPI" | "learningProgress" | "revenueReport" | "userAnalytics" | "exportTicket"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      SystemOverview: {
        payload: Prisma.$SystemOverviewPayload<ExtArgs>
        fields: Prisma.SystemOverviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemOverviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemOverviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemOverviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemOverviewPayload>
          }
          findFirst: {
            args: Prisma.SystemOverviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemOverviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemOverviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemOverviewPayload>
          }
          findMany: {
            args: Prisma.SystemOverviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemOverviewPayload>[]
          }
          create: {
            args: Prisma.SystemOverviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemOverviewPayload>
          }
          createMany: {
            args: Prisma.SystemOverviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SystemOverviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemOverviewPayload>[]
          }
          delete: {
            args: Prisma.SystemOverviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemOverviewPayload>
          }
          update: {
            args: Prisma.SystemOverviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemOverviewPayload>
          }
          deleteMany: {
            args: Prisma.SystemOverviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemOverviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SystemOverviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemOverviewPayload>
          }
          aggregate: {
            args: Prisma.SystemOverviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemOverview>
          }
          groupBy: {
            args: Prisma.SystemOverviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemOverviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemOverviewCountArgs<ExtArgs>
            result: $Utils.Optional<SystemOverviewCountAggregateOutputType> | number
          }
        }
      }
      EducationKPI: {
        payload: Prisma.$EducationKPIPayload<ExtArgs>
        fields: Prisma.EducationKPIFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EducationKPIFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationKPIPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EducationKPIFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationKPIPayload>
          }
          findFirst: {
            args: Prisma.EducationKPIFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationKPIPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EducationKPIFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationKPIPayload>
          }
          findMany: {
            args: Prisma.EducationKPIFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationKPIPayload>[]
          }
          create: {
            args: Prisma.EducationKPICreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationKPIPayload>
          }
          createMany: {
            args: Prisma.EducationKPICreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EducationKPICreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationKPIPayload>[]
          }
          delete: {
            args: Prisma.EducationKPIDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationKPIPayload>
          }
          update: {
            args: Prisma.EducationKPIUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationKPIPayload>
          }
          deleteMany: {
            args: Prisma.EducationKPIDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EducationKPIUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EducationKPIUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationKPIPayload>
          }
          aggregate: {
            args: Prisma.EducationKPIAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEducationKPI>
          }
          groupBy: {
            args: Prisma.EducationKPIGroupByArgs<ExtArgs>
            result: $Utils.Optional<EducationKPIGroupByOutputType>[]
          }
          count: {
            args: Prisma.EducationKPICountArgs<ExtArgs>
            result: $Utils.Optional<EducationKPICountAggregateOutputType> | number
          }
        }
      }
      LearningProgress: {
        payload: Prisma.$LearningProgressPayload<ExtArgs>
        fields: Prisma.LearningProgressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LearningProgressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningProgressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LearningProgressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningProgressPayload>
          }
          findFirst: {
            args: Prisma.LearningProgressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningProgressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LearningProgressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningProgressPayload>
          }
          findMany: {
            args: Prisma.LearningProgressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningProgressPayload>[]
          }
          create: {
            args: Prisma.LearningProgressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningProgressPayload>
          }
          createMany: {
            args: Prisma.LearningProgressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LearningProgressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningProgressPayload>[]
          }
          delete: {
            args: Prisma.LearningProgressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningProgressPayload>
          }
          update: {
            args: Prisma.LearningProgressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningProgressPayload>
          }
          deleteMany: {
            args: Prisma.LearningProgressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LearningProgressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LearningProgressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningProgressPayload>
          }
          aggregate: {
            args: Prisma.LearningProgressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLearningProgress>
          }
          groupBy: {
            args: Prisma.LearningProgressGroupByArgs<ExtArgs>
            result: $Utils.Optional<LearningProgressGroupByOutputType>[]
          }
          count: {
            args: Prisma.LearningProgressCountArgs<ExtArgs>
            result: $Utils.Optional<LearningProgressCountAggregateOutputType> | number
          }
        }
      }
      RevenueReport: {
        payload: Prisma.$RevenueReportPayload<ExtArgs>
        fields: Prisma.RevenueReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RevenueReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenueReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RevenueReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenueReportPayload>
          }
          findFirst: {
            args: Prisma.RevenueReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenueReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RevenueReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenueReportPayload>
          }
          findMany: {
            args: Prisma.RevenueReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenueReportPayload>[]
          }
          create: {
            args: Prisma.RevenueReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenueReportPayload>
          }
          createMany: {
            args: Prisma.RevenueReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RevenueReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenueReportPayload>[]
          }
          delete: {
            args: Prisma.RevenueReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenueReportPayload>
          }
          update: {
            args: Prisma.RevenueReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenueReportPayload>
          }
          deleteMany: {
            args: Prisma.RevenueReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RevenueReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RevenueReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenueReportPayload>
          }
          aggregate: {
            args: Prisma.RevenueReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRevenueReport>
          }
          groupBy: {
            args: Prisma.RevenueReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<RevenueReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.RevenueReportCountArgs<ExtArgs>
            result: $Utils.Optional<RevenueReportCountAggregateOutputType> | number
          }
        }
      }
      UserAnalytics: {
        payload: Prisma.$UserAnalyticsPayload<ExtArgs>
        fields: Prisma.UserAnalyticsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserAnalyticsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAnalyticsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserAnalyticsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAnalyticsPayload>
          }
          findFirst: {
            args: Prisma.UserAnalyticsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAnalyticsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserAnalyticsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAnalyticsPayload>
          }
          findMany: {
            args: Prisma.UserAnalyticsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAnalyticsPayload>[]
          }
          create: {
            args: Prisma.UserAnalyticsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAnalyticsPayload>
          }
          createMany: {
            args: Prisma.UserAnalyticsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserAnalyticsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAnalyticsPayload>[]
          }
          delete: {
            args: Prisma.UserAnalyticsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAnalyticsPayload>
          }
          update: {
            args: Prisma.UserAnalyticsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAnalyticsPayload>
          }
          deleteMany: {
            args: Prisma.UserAnalyticsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserAnalyticsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserAnalyticsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAnalyticsPayload>
          }
          aggregate: {
            args: Prisma.UserAnalyticsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserAnalytics>
          }
          groupBy: {
            args: Prisma.UserAnalyticsGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserAnalyticsGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserAnalyticsCountArgs<ExtArgs>
            result: $Utils.Optional<UserAnalyticsCountAggregateOutputType> | number
          }
        }
      }
      ExportTicket: {
        payload: Prisma.$ExportTicketPayload<ExtArgs>
        fields: Prisma.ExportTicketFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExportTicketFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportTicketPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExportTicketFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportTicketPayload>
          }
          findFirst: {
            args: Prisma.ExportTicketFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportTicketPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExportTicketFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportTicketPayload>
          }
          findMany: {
            args: Prisma.ExportTicketFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportTicketPayload>[]
          }
          create: {
            args: Prisma.ExportTicketCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportTicketPayload>
          }
          createMany: {
            args: Prisma.ExportTicketCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExportTicketCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportTicketPayload>[]
          }
          delete: {
            args: Prisma.ExportTicketDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportTicketPayload>
          }
          update: {
            args: Prisma.ExportTicketUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportTicketPayload>
          }
          deleteMany: {
            args: Prisma.ExportTicketDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExportTicketUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExportTicketUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportTicketPayload>
          }
          aggregate: {
            args: Prisma.ExportTicketAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExportTicket>
          }
          groupBy: {
            args: Prisma.ExportTicketGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExportTicketGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExportTicketCountArgs<ExtArgs>
            result: $Utils.Optional<ExportTicketCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */



  /**
   * Models
   */

  /**
   * Model SystemOverview
   */

  export type AggregateSystemOverview = {
    _count: SystemOverviewCountAggregateOutputType | null
    _avg: SystemOverviewAvgAggregateOutputType | null
    _sum: SystemOverviewSumAggregateOutputType | null
    _min: SystemOverviewMinAggregateOutputType | null
    _max: SystemOverviewMaxAggregateOutputType | null
  }

  export type SystemOverviewAvgAggregateOutputType = {
    id: number | null
    totalRevenue: number | null
    totalOrders: number | null
    totalUsers: number | null
    totalPartners: number | null
  }

  export type SystemOverviewSumAggregateOutputType = {
    id: number | null
    totalRevenue: number | null
    totalOrders: number | null
    totalUsers: number | null
    totalPartners: number | null
  }

  export type SystemOverviewMinAggregateOutputType = {
    id: number | null
    totalRevenue: number | null
    revenueTrend: string | null
    totalOrders: number | null
    ordersTrend: string | null
    totalUsers: number | null
    usersTrend: string | null
    totalPartners: number | null
    partnersTrend: string | null
    updatedAt: Date | null
  }

  export type SystemOverviewMaxAggregateOutputType = {
    id: number | null
    totalRevenue: number | null
    revenueTrend: string | null
    totalOrders: number | null
    ordersTrend: string | null
    totalUsers: number | null
    usersTrend: string | null
    totalPartners: number | null
    partnersTrend: string | null
    updatedAt: Date | null
  }

  export type SystemOverviewCountAggregateOutputType = {
    id: number
    totalRevenue: number
    revenueTrend: number
    totalOrders: number
    ordersTrend: number
    totalUsers: number
    usersTrend: number
    totalPartners: number
    partnersTrend: number
    updatedAt: number
    _all: number
  }


  export type SystemOverviewAvgAggregateInputType = {
    id?: true
    totalRevenue?: true
    totalOrders?: true
    totalUsers?: true
    totalPartners?: true
  }

  export type SystemOverviewSumAggregateInputType = {
    id?: true
    totalRevenue?: true
    totalOrders?: true
    totalUsers?: true
    totalPartners?: true
  }

  export type SystemOverviewMinAggregateInputType = {
    id?: true
    totalRevenue?: true
    revenueTrend?: true
    totalOrders?: true
    ordersTrend?: true
    totalUsers?: true
    usersTrend?: true
    totalPartners?: true
    partnersTrend?: true
    updatedAt?: true
  }

  export type SystemOverviewMaxAggregateInputType = {
    id?: true
    totalRevenue?: true
    revenueTrend?: true
    totalOrders?: true
    ordersTrend?: true
    totalUsers?: true
    usersTrend?: true
    totalPartners?: true
    partnersTrend?: true
    updatedAt?: true
  }

  export type SystemOverviewCountAggregateInputType = {
    id?: true
    totalRevenue?: true
    revenueTrend?: true
    totalOrders?: true
    ordersTrend?: true
    totalUsers?: true
    usersTrend?: true
    totalPartners?: true
    partnersTrend?: true
    updatedAt?: true
    _all?: true
  }

  export type SystemOverviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemOverview to aggregate.
     */
    where?: SystemOverviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemOverviews to fetch.
     */
    orderBy?: SystemOverviewOrderByWithRelationInput | SystemOverviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemOverviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemOverviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemOverviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemOverviews
    **/
    _count?: true | SystemOverviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SystemOverviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SystemOverviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemOverviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemOverviewMaxAggregateInputType
  }

  export type GetSystemOverviewAggregateType<T extends SystemOverviewAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemOverview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemOverview[P]>
      : GetScalarType<T[P], AggregateSystemOverview[P]>
  }




  export type SystemOverviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemOverviewWhereInput
    orderBy?: SystemOverviewOrderByWithAggregationInput | SystemOverviewOrderByWithAggregationInput[]
    by: SystemOverviewScalarFieldEnum[] | SystemOverviewScalarFieldEnum
    having?: SystemOverviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemOverviewCountAggregateInputType | true
    _avg?: SystemOverviewAvgAggregateInputType
    _sum?: SystemOverviewSumAggregateInputType
    _min?: SystemOverviewMinAggregateInputType
    _max?: SystemOverviewMaxAggregateInputType
  }

  export type SystemOverviewGroupByOutputType = {
    id: number
    totalRevenue: number
    revenueTrend: string
    totalOrders: number
    ordersTrend: string
    totalUsers: number
    usersTrend: string
    totalPartners: number
    partnersTrend: string
    updatedAt: Date
    _count: SystemOverviewCountAggregateOutputType | null
    _avg: SystemOverviewAvgAggregateOutputType | null
    _sum: SystemOverviewSumAggregateOutputType | null
    _min: SystemOverviewMinAggregateOutputType | null
    _max: SystemOverviewMaxAggregateOutputType | null
  }

  type GetSystemOverviewGroupByPayload<T extends SystemOverviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemOverviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemOverviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemOverviewGroupByOutputType[P]>
            : GetScalarType<T[P], SystemOverviewGroupByOutputType[P]>
        }
      >
    >


  export type SystemOverviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    totalRevenue?: boolean
    revenueTrend?: boolean
    totalOrders?: boolean
    ordersTrend?: boolean
    totalUsers?: boolean
    usersTrend?: boolean
    totalPartners?: boolean
    partnersTrend?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemOverview"]>

  export type SystemOverviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    totalRevenue?: boolean
    revenueTrend?: boolean
    totalOrders?: boolean
    ordersTrend?: boolean
    totalUsers?: boolean
    usersTrend?: boolean
    totalPartners?: boolean
    partnersTrend?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemOverview"]>

  export type SystemOverviewSelectScalar = {
    id?: boolean
    totalRevenue?: boolean
    revenueTrend?: boolean
    totalOrders?: boolean
    ordersTrend?: boolean
    totalUsers?: boolean
    usersTrend?: boolean
    totalPartners?: boolean
    partnersTrend?: boolean
    updatedAt?: boolean
  }


  export type $SystemOverviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemOverview"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      totalRevenue: number
      revenueTrend: string
      totalOrders: number
      ordersTrend: string
      totalUsers: number
      usersTrend: string
      totalPartners: number
      partnersTrend: string
      updatedAt: Date
    }, ExtArgs["result"]["systemOverview"]>
    composites: {}
  }

  type SystemOverviewGetPayload<S extends boolean | null | undefined | SystemOverviewDefaultArgs> = $Result.GetResult<Prisma.$SystemOverviewPayload, S>

  type SystemOverviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SystemOverviewFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SystemOverviewCountAggregateInputType | true
    }

  export interface SystemOverviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemOverview'], meta: { name: 'SystemOverview' } }
    /**
     * Find zero or one SystemOverview that matches the filter.
     * @param {SystemOverviewFindUniqueArgs} args - Arguments to find a SystemOverview
     * @example
     * // Get one SystemOverview
     * const systemOverview = await prisma.systemOverview.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemOverviewFindUniqueArgs>(args: SelectSubset<T, SystemOverviewFindUniqueArgs<ExtArgs>>): Prisma__SystemOverviewClient<$Result.GetResult<Prisma.$SystemOverviewPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SystemOverview that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SystemOverviewFindUniqueOrThrowArgs} args - Arguments to find a SystemOverview
     * @example
     * // Get one SystemOverview
     * const systemOverview = await prisma.systemOverview.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemOverviewFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemOverviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemOverviewClient<$Result.GetResult<Prisma.$SystemOverviewPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SystemOverview that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemOverviewFindFirstArgs} args - Arguments to find a SystemOverview
     * @example
     * // Get one SystemOverview
     * const systemOverview = await prisma.systemOverview.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemOverviewFindFirstArgs>(args?: SelectSubset<T, SystemOverviewFindFirstArgs<ExtArgs>>): Prisma__SystemOverviewClient<$Result.GetResult<Prisma.$SystemOverviewPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SystemOverview that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemOverviewFindFirstOrThrowArgs} args - Arguments to find a SystemOverview
     * @example
     * // Get one SystemOverview
     * const systemOverview = await prisma.systemOverview.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemOverviewFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemOverviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemOverviewClient<$Result.GetResult<Prisma.$SystemOverviewPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SystemOverviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemOverviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemOverviews
     * const systemOverviews = await prisma.systemOverview.findMany()
     * 
     * // Get first 10 SystemOverviews
     * const systemOverviews = await prisma.systemOverview.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemOverviewWithIdOnly = await prisma.systemOverview.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemOverviewFindManyArgs>(args?: SelectSubset<T, SystemOverviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemOverviewPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SystemOverview.
     * @param {SystemOverviewCreateArgs} args - Arguments to create a SystemOverview.
     * @example
     * // Create one SystemOverview
     * const SystemOverview = await prisma.systemOverview.create({
     *   data: {
     *     // ... data to create a SystemOverview
     *   }
     * })
     * 
     */
    create<T extends SystemOverviewCreateArgs>(args: SelectSubset<T, SystemOverviewCreateArgs<ExtArgs>>): Prisma__SystemOverviewClient<$Result.GetResult<Prisma.$SystemOverviewPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SystemOverviews.
     * @param {SystemOverviewCreateManyArgs} args - Arguments to create many SystemOverviews.
     * @example
     * // Create many SystemOverviews
     * const systemOverview = await prisma.systemOverview.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemOverviewCreateManyArgs>(args?: SelectSubset<T, SystemOverviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SystemOverviews and returns the data saved in the database.
     * @param {SystemOverviewCreateManyAndReturnArgs} args - Arguments to create many SystemOverviews.
     * @example
     * // Create many SystemOverviews
     * const systemOverview = await prisma.systemOverview.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SystemOverviews and only return the `id`
     * const systemOverviewWithIdOnly = await prisma.systemOverview.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SystemOverviewCreateManyAndReturnArgs>(args?: SelectSubset<T, SystemOverviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemOverviewPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SystemOverview.
     * @param {SystemOverviewDeleteArgs} args - Arguments to delete one SystemOverview.
     * @example
     * // Delete one SystemOverview
     * const SystemOverview = await prisma.systemOverview.delete({
     *   where: {
     *     // ... filter to delete one SystemOverview
     *   }
     * })
     * 
     */
    delete<T extends SystemOverviewDeleteArgs>(args: SelectSubset<T, SystemOverviewDeleteArgs<ExtArgs>>): Prisma__SystemOverviewClient<$Result.GetResult<Prisma.$SystemOverviewPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SystemOverview.
     * @param {SystemOverviewUpdateArgs} args - Arguments to update one SystemOverview.
     * @example
     * // Update one SystemOverview
     * const systemOverview = await prisma.systemOverview.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemOverviewUpdateArgs>(args: SelectSubset<T, SystemOverviewUpdateArgs<ExtArgs>>): Prisma__SystemOverviewClient<$Result.GetResult<Prisma.$SystemOverviewPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SystemOverviews.
     * @param {SystemOverviewDeleteManyArgs} args - Arguments to filter SystemOverviews to delete.
     * @example
     * // Delete a few SystemOverviews
     * const { count } = await prisma.systemOverview.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemOverviewDeleteManyArgs>(args?: SelectSubset<T, SystemOverviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemOverviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemOverviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemOverviews
     * const systemOverview = await prisma.systemOverview.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemOverviewUpdateManyArgs>(args: SelectSubset<T, SystemOverviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SystemOverview.
     * @param {SystemOverviewUpsertArgs} args - Arguments to update or create a SystemOverview.
     * @example
     * // Update or create a SystemOverview
     * const systemOverview = await prisma.systemOverview.upsert({
     *   create: {
     *     // ... data to create a SystemOverview
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemOverview we want to update
     *   }
     * })
     */
    upsert<T extends SystemOverviewUpsertArgs>(args: SelectSubset<T, SystemOverviewUpsertArgs<ExtArgs>>): Prisma__SystemOverviewClient<$Result.GetResult<Prisma.$SystemOverviewPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SystemOverviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemOverviewCountArgs} args - Arguments to filter SystemOverviews to count.
     * @example
     * // Count the number of SystemOverviews
     * const count = await prisma.systemOverview.count({
     *   where: {
     *     // ... the filter for the SystemOverviews we want to count
     *   }
     * })
    **/
    count<T extends SystemOverviewCountArgs>(
      args?: Subset<T, SystemOverviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemOverviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemOverview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemOverviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemOverviewAggregateArgs>(args: Subset<T, SystemOverviewAggregateArgs>): Prisma.PrismaPromise<GetSystemOverviewAggregateType<T>>

    /**
     * Group by SystemOverview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemOverviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemOverviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemOverviewGroupByArgs['orderBy'] }
        : { orderBy?: SystemOverviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemOverviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemOverviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemOverview model
   */
  readonly fields: SystemOverviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemOverview.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemOverviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemOverview model
   */ 
  interface SystemOverviewFieldRefs {
    readonly id: FieldRef<"SystemOverview", 'Int'>
    readonly totalRevenue: FieldRef<"SystemOverview", 'Float'>
    readonly revenueTrend: FieldRef<"SystemOverview", 'String'>
    readonly totalOrders: FieldRef<"SystemOverview", 'Int'>
    readonly ordersTrend: FieldRef<"SystemOverview", 'String'>
    readonly totalUsers: FieldRef<"SystemOverview", 'Int'>
    readonly usersTrend: FieldRef<"SystemOverview", 'String'>
    readonly totalPartners: FieldRef<"SystemOverview", 'Int'>
    readonly partnersTrend: FieldRef<"SystemOverview", 'String'>
    readonly updatedAt: FieldRef<"SystemOverview", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemOverview findUnique
   */
  export type SystemOverviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemOverview
     */
    select?: SystemOverviewSelect<ExtArgs> | null
    /**
     * Filter, which SystemOverview to fetch.
     */
    where: SystemOverviewWhereUniqueInput
  }

  /**
   * SystemOverview findUniqueOrThrow
   */
  export type SystemOverviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemOverview
     */
    select?: SystemOverviewSelect<ExtArgs> | null
    /**
     * Filter, which SystemOverview to fetch.
     */
    where: SystemOverviewWhereUniqueInput
  }

  /**
   * SystemOverview findFirst
   */
  export type SystemOverviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemOverview
     */
    select?: SystemOverviewSelect<ExtArgs> | null
    /**
     * Filter, which SystemOverview to fetch.
     */
    where?: SystemOverviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemOverviews to fetch.
     */
    orderBy?: SystemOverviewOrderByWithRelationInput | SystemOverviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemOverviews.
     */
    cursor?: SystemOverviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemOverviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemOverviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemOverviews.
     */
    distinct?: SystemOverviewScalarFieldEnum | SystemOverviewScalarFieldEnum[]
  }

  /**
   * SystemOverview findFirstOrThrow
   */
  export type SystemOverviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemOverview
     */
    select?: SystemOverviewSelect<ExtArgs> | null
    /**
     * Filter, which SystemOverview to fetch.
     */
    where?: SystemOverviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemOverviews to fetch.
     */
    orderBy?: SystemOverviewOrderByWithRelationInput | SystemOverviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemOverviews.
     */
    cursor?: SystemOverviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemOverviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemOverviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemOverviews.
     */
    distinct?: SystemOverviewScalarFieldEnum | SystemOverviewScalarFieldEnum[]
  }

  /**
   * SystemOverview findMany
   */
  export type SystemOverviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemOverview
     */
    select?: SystemOverviewSelect<ExtArgs> | null
    /**
     * Filter, which SystemOverviews to fetch.
     */
    where?: SystemOverviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemOverviews to fetch.
     */
    orderBy?: SystemOverviewOrderByWithRelationInput | SystemOverviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemOverviews.
     */
    cursor?: SystemOverviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemOverviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemOverviews.
     */
    skip?: number
    distinct?: SystemOverviewScalarFieldEnum | SystemOverviewScalarFieldEnum[]
  }

  /**
   * SystemOverview create
   */
  export type SystemOverviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemOverview
     */
    select?: SystemOverviewSelect<ExtArgs> | null
    /**
     * The data needed to create a SystemOverview.
     */
    data: XOR<SystemOverviewCreateInput, SystemOverviewUncheckedCreateInput>
  }

  /**
   * SystemOverview createMany
   */
  export type SystemOverviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemOverviews.
     */
    data: SystemOverviewCreateManyInput | SystemOverviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemOverview createManyAndReturn
   */
  export type SystemOverviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemOverview
     */
    select?: SystemOverviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SystemOverviews.
     */
    data: SystemOverviewCreateManyInput | SystemOverviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemOverview update
   */
  export type SystemOverviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemOverview
     */
    select?: SystemOverviewSelect<ExtArgs> | null
    /**
     * The data needed to update a SystemOverview.
     */
    data: XOR<SystemOverviewUpdateInput, SystemOverviewUncheckedUpdateInput>
    /**
     * Choose, which SystemOverview to update.
     */
    where: SystemOverviewWhereUniqueInput
  }

  /**
   * SystemOverview updateMany
   */
  export type SystemOverviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemOverviews.
     */
    data: XOR<SystemOverviewUpdateManyMutationInput, SystemOverviewUncheckedUpdateManyInput>
    /**
     * Filter which SystemOverviews to update
     */
    where?: SystemOverviewWhereInput
  }

  /**
   * SystemOverview upsert
   */
  export type SystemOverviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemOverview
     */
    select?: SystemOverviewSelect<ExtArgs> | null
    /**
     * The filter to search for the SystemOverview to update in case it exists.
     */
    where: SystemOverviewWhereUniqueInput
    /**
     * In case the SystemOverview found by the `where` argument doesn't exist, create a new SystemOverview with this data.
     */
    create: XOR<SystemOverviewCreateInput, SystemOverviewUncheckedCreateInput>
    /**
     * In case the SystemOverview was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemOverviewUpdateInput, SystemOverviewUncheckedUpdateInput>
  }

  /**
   * SystemOverview delete
   */
  export type SystemOverviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemOverview
     */
    select?: SystemOverviewSelect<ExtArgs> | null
    /**
     * Filter which SystemOverview to delete.
     */
    where: SystemOverviewWhereUniqueInput
  }

  /**
   * SystemOverview deleteMany
   */
  export type SystemOverviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemOverviews to delete
     */
    where?: SystemOverviewWhereInput
  }

  /**
   * SystemOverview without action
   */
  export type SystemOverviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemOverview
     */
    select?: SystemOverviewSelect<ExtArgs> | null
  }


  /**
   * Model EducationKPI
   */

  export type AggregateEducationKPI = {
    _count: EducationKPICountAggregateOutputType | null
    _avg: EducationKPIAvgAggregateOutputType | null
    _sum: EducationKPISumAggregateOutputType | null
    _min: EducationKPIMinAggregateOutputType | null
    _max: EducationKPIMaxAggregateOutputType | null
  }

  export type EducationKPIAvgAggregateOutputType = {
    id: number | null
    totalEnrolled: number | null
    expectedEnrolled: number | null
    enrollmentRate: number | null
    started: number | null
    completed: number | null
    startedRate: number | null
    completedRate: number | null
    totalNotifications: number | null
    usageFrequency: number | null
  }

  export type EducationKPISumAggregateOutputType = {
    id: number | null
    totalEnrolled: number | null
    expectedEnrolled: number | null
    enrollmentRate: number | null
    started: number | null
    completed: number | null
    startedRate: number | null
    completedRate: number | null
    totalNotifications: number | null
    usageFrequency: number | null
  }

  export type EducationKPIMinAggregateOutputType = {
    id: number | null
    totalEnrolled: number | null
    expectedEnrolled: number | null
    enrollmentRate: number | null
    started: number | null
    completed: number | null
    startedRate: number | null
    completedRate: number | null
    totalNotifications: number | null
    usageFrequency: number | null
    avgCourseDuration: string | null
    updatedAt: Date | null
  }

  export type EducationKPIMaxAggregateOutputType = {
    id: number | null
    totalEnrolled: number | null
    expectedEnrolled: number | null
    enrollmentRate: number | null
    started: number | null
    completed: number | null
    startedRate: number | null
    completedRate: number | null
    totalNotifications: number | null
    usageFrequency: number | null
    avgCourseDuration: string | null
    updatedAt: Date | null
  }

  export type EducationKPICountAggregateOutputType = {
    id: number
    totalEnrolled: number
    expectedEnrolled: number
    enrollmentRate: number
    started: number
    completed: number
    startedRate: number
    completedRate: number
    totalNotifications: number
    usageFrequency: number
    avgCourseDuration: number
    updatedAt: number
    _all: number
  }


  export type EducationKPIAvgAggregateInputType = {
    id?: true
    totalEnrolled?: true
    expectedEnrolled?: true
    enrollmentRate?: true
    started?: true
    completed?: true
    startedRate?: true
    completedRate?: true
    totalNotifications?: true
    usageFrequency?: true
  }

  export type EducationKPISumAggregateInputType = {
    id?: true
    totalEnrolled?: true
    expectedEnrolled?: true
    enrollmentRate?: true
    started?: true
    completed?: true
    startedRate?: true
    completedRate?: true
    totalNotifications?: true
    usageFrequency?: true
  }

  export type EducationKPIMinAggregateInputType = {
    id?: true
    totalEnrolled?: true
    expectedEnrolled?: true
    enrollmentRate?: true
    started?: true
    completed?: true
    startedRate?: true
    completedRate?: true
    totalNotifications?: true
    usageFrequency?: true
    avgCourseDuration?: true
    updatedAt?: true
  }

  export type EducationKPIMaxAggregateInputType = {
    id?: true
    totalEnrolled?: true
    expectedEnrolled?: true
    enrollmentRate?: true
    started?: true
    completed?: true
    startedRate?: true
    completedRate?: true
    totalNotifications?: true
    usageFrequency?: true
    avgCourseDuration?: true
    updatedAt?: true
  }

  export type EducationKPICountAggregateInputType = {
    id?: true
    totalEnrolled?: true
    expectedEnrolled?: true
    enrollmentRate?: true
    started?: true
    completed?: true
    startedRate?: true
    completedRate?: true
    totalNotifications?: true
    usageFrequency?: true
    avgCourseDuration?: true
    updatedAt?: true
    _all?: true
  }

  export type EducationKPIAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EducationKPI to aggregate.
     */
    where?: EducationKPIWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EducationKPIS to fetch.
     */
    orderBy?: EducationKPIOrderByWithRelationInput | EducationKPIOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EducationKPIWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EducationKPIS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EducationKPIS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EducationKPIS
    **/
    _count?: true | EducationKPICountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EducationKPIAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EducationKPISumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EducationKPIMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EducationKPIMaxAggregateInputType
  }

  export type GetEducationKPIAggregateType<T extends EducationKPIAggregateArgs> = {
        [P in keyof T & keyof AggregateEducationKPI]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEducationKPI[P]>
      : GetScalarType<T[P], AggregateEducationKPI[P]>
  }




  export type EducationKPIGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EducationKPIWhereInput
    orderBy?: EducationKPIOrderByWithAggregationInput | EducationKPIOrderByWithAggregationInput[]
    by: EducationKPIScalarFieldEnum[] | EducationKPIScalarFieldEnum
    having?: EducationKPIScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EducationKPICountAggregateInputType | true
    _avg?: EducationKPIAvgAggregateInputType
    _sum?: EducationKPISumAggregateInputType
    _min?: EducationKPIMinAggregateInputType
    _max?: EducationKPIMaxAggregateInputType
  }

  export type EducationKPIGroupByOutputType = {
    id: number
    totalEnrolled: number
    expectedEnrolled: number
    enrollmentRate: number
    started: number
    completed: number
    startedRate: number
    completedRate: number
    totalNotifications: number
    usageFrequency: number
    avgCourseDuration: string
    updatedAt: Date
    _count: EducationKPICountAggregateOutputType | null
    _avg: EducationKPIAvgAggregateOutputType | null
    _sum: EducationKPISumAggregateOutputType | null
    _min: EducationKPIMinAggregateOutputType | null
    _max: EducationKPIMaxAggregateOutputType | null
  }

  type GetEducationKPIGroupByPayload<T extends EducationKPIGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EducationKPIGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EducationKPIGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EducationKPIGroupByOutputType[P]>
            : GetScalarType<T[P], EducationKPIGroupByOutputType[P]>
        }
      >
    >


  export type EducationKPISelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    totalEnrolled?: boolean
    expectedEnrolled?: boolean
    enrollmentRate?: boolean
    started?: boolean
    completed?: boolean
    startedRate?: boolean
    completedRate?: boolean
    totalNotifications?: boolean
    usageFrequency?: boolean
    avgCourseDuration?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["educationKPI"]>

  export type EducationKPISelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    totalEnrolled?: boolean
    expectedEnrolled?: boolean
    enrollmentRate?: boolean
    started?: boolean
    completed?: boolean
    startedRate?: boolean
    completedRate?: boolean
    totalNotifications?: boolean
    usageFrequency?: boolean
    avgCourseDuration?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["educationKPI"]>

  export type EducationKPISelectScalar = {
    id?: boolean
    totalEnrolled?: boolean
    expectedEnrolled?: boolean
    enrollmentRate?: boolean
    started?: boolean
    completed?: boolean
    startedRate?: boolean
    completedRate?: boolean
    totalNotifications?: boolean
    usageFrequency?: boolean
    avgCourseDuration?: boolean
    updatedAt?: boolean
  }


  export type $EducationKPIPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EducationKPI"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      totalEnrolled: number
      expectedEnrolled: number
      enrollmentRate: number
      started: number
      completed: number
      startedRate: number
      completedRate: number
      totalNotifications: number
      usageFrequency: number
      avgCourseDuration: string
      updatedAt: Date
    }, ExtArgs["result"]["educationKPI"]>
    composites: {}
  }

  type EducationKPIGetPayload<S extends boolean | null | undefined | EducationKPIDefaultArgs> = $Result.GetResult<Prisma.$EducationKPIPayload, S>

  type EducationKPICountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EducationKPIFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EducationKPICountAggregateInputType | true
    }

  export interface EducationKPIDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EducationKPI'], meta: { name: 'EducationKPI' } }
    /**
     * Find zero or one EducationKPI that matches the filter.
     * @param {EducationKPIFindUniqueArgs} args - Arguments to find a EducationKPI
     * @example
     * // Get one EducationKPI
     * const educationKPI = await prisma.educationKPI.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EducationKPIFindUniqueArgs>(args: SelectSubset<T, EducationKPIFindUniqueArgs<ExtArgs>>): Prisma__EducationKPIClient<$Result.GetResult<Prisma.$EducationKPIPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EducationKPI that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EducationKPIFindUniqueOrThrowArgs} args - Arguments to find a EducationKPI
     * @example
     * // Get one EducationKPI
     * const educationKPI = await prisma.educationKPI.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EducationKPIFindUniqueOrThrowArgs>(args: SelectSubset<T, EducationKPIFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EducationKPIClient<$Result.GetResult<Prisma.$EducationKPIPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EducationKPI that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationKPIFindFirstArgs} args - Arguments to find a EducationKPI
     * @example
     * // Get one EducationKPI
     * const educationKPI = await prisma.educationKPI.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EducationKPIFindFirstArgs>(args?: SelectSubset<T, EducationKPIFindFirstArgs<ExtArgs>>): Prisma__EducationKPIClient<$Result.GetResult<Prisma.$EducationKPIPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EducationKPI that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationKPIFindFirstOrThrowArgs} args - Arguments to find a EducationKPI
     * @example
     * // Get one EducationKPI
     * const educationKPI = await prisma.educationKPI.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EducationKPIFindFirstOrThrowArgs>(args?: SelectSubset<T, EducationKPIFindFirstOrThrowArgs<ExtArgs>>): Prisma__EducationKPIClient<$Result.GetResult<Prisma.$EducationKPIPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EducationKPIS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationKPIFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EducationKPIS
     * const educationKPIS = await prisma.educationKPI.findMany()
     * 
     * // Get first 10 EducationKPIS
     * const educationKPIS = await prisma.educationKPI.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const educationKPIWithIdOnly = await prisma.educationKPI.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EducationKPIFindManyArgs>(args?: SelectSubset<T, EducationKPIFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EducationKPIPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EducationKPI.
     * @param {EducationKPICreateArgs} args - Arguments to create a EducationKPI.
     * @example
     * // Create one EducationKPI
     * const EducationKPI = await prisma.educationKPI.create({
     *   data: {
     *     // ... data to create a EducationKPI
     *   }
     * })
     * 
     */
    create<T extends EducationKPICreateArgs>(args: SelectSubset<T, EducationKPICreateArgs<ExtArgs>>): Prisma__EducationKPIClient<$Result.GetResult<Prisma.$EducationKPIPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EducationKPIS.
     * @param {EducationKPICreateManyArgs} args - Arguments to create many EducationKPIS.
     * @example
     * // Create many EducationKPIS
     * const educationKPI = await prisma.educationKPI.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EducationKPICreateManyArgs>(args?: SelectSubset<T, EducationKPICreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EducationKPIS and returns the data saved in the database.
     * @param {EducationKPICreateManyAndReturnArgs} args - Arguments to create many EducationKPIS.
     * @example
     * // Create many EducationKPIS
     * const educationKPI = await prisma.educationKPI.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EducationKPIS and only return the `id`
     * const educationKPIWithIdOnly = await prisma.educationKPI.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EducationKPICreateManyAndReturnArgs>(args?: SelectSubset<T, EducationKPICreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EducationKPIPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EducationKPI.
     * @param {EducationKPIDeleteArgs} args - Arguments to delete one EducationKPI.
     * @example
     * // Delete one EducationKPI
     * const EducationKPI = await prisma.educationKPI.delete({
     *   where: {
     *     // ... filter to delete one EducationKPI
     *   }
     * })
     * 
     */
    delete<T extends EducationKPIDeleteArgs>(args: SelectSubset<T, EducationKPIDeleteArgs<ExtArgs>>): Prisma__EducationKPIClient<$Result.GetResult<Prisma.$EducationKPIPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EducationKPI.
     * @param {EducationKPIUpdateArgs} args - Arguments to update one EducationKPI.
     * @example
     * // Update one EducationKPI
     * const educationKPI = await prisma.educationKPI.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EducationKPIUpdateArgs>(args: SelectSubset<T, EducationKPIUpdateArgs<ExtArgs>>): Prisma__EducationKPIClient<$Result.GetResult<Prisma.$EducationKPIPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EducationKPIS.
     * @param {EducationKPIDeleteManyArgs} args - Arguments to filter EducationKPIS to delete.
     * @example
     * // Delete a few EducationKPIS
     * const { count } = await prisma.educationKPI.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EducationKPIDeleteManyArgs>(args?: SelectSubset<T, EducationKPIDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EducationKPIS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationKPIUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EducationKPIS
     * const educationKPI = await prisma.educationKPI.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EducationKPIUpdateManyArgs>(args: SelectSubset<T, EducationKPIUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EducationKPI.
     * @param {EducationKPIUpsertArgs} args - Arguments to update or create a EducationKPI.
     * @example
     * // Update or create a EducationKPI
     * const educationKPI = await prisma.educationKPI.upsert({
     *   create: {
     *     // ... data to create a EducationKPI
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EducationKPI we want to update
     *   }
     * })
     */
    upsert<T extends EducationKPIUpsertArgs>(args: SelectSubset<T, EducationKPIUpsertArgs<ExtArgs>>): Prisma__EducationKPIClient<$Result.GetResult<Prisma.$EducationKPIPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EducationKPIS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationKPICountArgs} args - Arguments to filter EducationKPIS to count.
     * @example
     * // Count the number of EducationKPIS
     * const count = await prisma.educationKPI.count({
     *   where: {
     *     // ... the filter for the EducationKPIS we want to count
     *   }
     * })
    **/
    count<T extends EducationKPICountArgs>(
      args?: Subset<T, EducationKPICountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EducationKPICountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EducationKPI.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationKPIAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EducationKPIAggregateArgs>(args: Subset<T, EducationKPIAggregateArgs>): Prisma.PrismaPromise<GetEducationKPIAggregateType<T>>

    /**
     * Group by EducationKPI.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationKPIGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EducationKPIGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EducationKPIGroupByArgs['orderBy'] }
        : { orderBy?: EducationKPIGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EducationKPIGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEducationKPIGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EducationKPI model
   */
  readonly fields: EducationKPIFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EducationKPI.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EducationKPIClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EducationKPI model
   */ 
  interface EducationKPIFieldRefs {
    readonly id: FieldRef<"EducationKPI", 'Int'>
    readonly totalEnrolled: FieldRef<"EducationKPI", 'Int'>
    readonly expectedEnrolled: FieldRef<"EducationKPI", 'Int'>
    readonly enrollmentRate: FieldRef<"EducationKPI", 'Float'>
    readonly started: FieldRef<"EducationKPI", 'Int'>
    readonly completed: FieldRef<"EducationKPI", 'Int'>
    readonly startedRate: FieldRef<"EducationKPI", 'Float'>
    readonly completedRate: FieldRef<"EducationKPI", 'Float'>
    readonly totalNotifications: FieldRef<"EducationKPI", 'Int'>
    readonly usageFrequency: FieldRef<"EducationKPI", 'Float'>
    readonly avgCourseDuration: FieldRef<"EducationKPI", 'String'>
    readonly updatedAt: FieldRef<"EducationKPI", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EducationKPI findUnique
   */
  export type EducationKPIFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationKPI
     */
    select?: EducationKPISelect<ExtArgs> | null
    /**
     * Filter, which EducationKPI to fetch.
     */
    where: EducationKPIWhereUniqueInput
  }

  /**
   * EducationKPI findUniqueOrThrow
   */
  export type EducationKPIFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationKPI
     */
    select?: EducationKPISelect<ExtArgs> | null
    /**
     * Filter, which EducationKPI to fetch.
     */
    where: EducationKPIWhereUniqueInput
  }

  /**
   * EducationKPI findFirst
   */
  export type EducationKPIFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationKPI
     */
    select?: EducationKPISelect<ExtArgs> | null
    /**
     * Filter, which EducationKPI to fetch.
     */
    where?: EducationKPIWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EducationKPIS to fetch.
     */
    orderBy?: EducationKPIOrderByWithRelationInput | EducationKPIOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EducationKPIS.
     */
    cursor?: EducationKPIWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EducationKPIS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EducationKPIS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EducationKPIS.
     */
    distinct?: EducationKPIScalarFieldEnum | EducationKPIScalarFieldEnum[]
  }

  /**
   * EducationKPI findFirstOrThrow
   */
  export type EducationKPIFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationKPI
     */
    select?: EducationKPISelect<ExtArgs> | null
    /**
     * Filter, which EducationKPI to fetch.
     */
    where?: EducationKPIWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EducationKPIS to fetch.
     */
    orderBy?: EducationKPIOrderByWithRelationInput | EducationKPIOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EducationKPIS.
     */
    cursor?: EducationKPIWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EducationKPIS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EducationKPIS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EducationKPIS.
     */
    distinct?: EducationKPIScalarFieldEnum | EducationKPIScalarFieldEnum[]
  }

  /**
   * EducationKPI findMany
   */
  export type EducationKPIFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationKPI
     */
    select?: EducationKPISelect<ExtArgs> | null
    /**
     * Filter, which EducationKPIS to fetch.
     */
    where?: EducationKPIWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EducationKPIS to fetch.
     */
    orderBy?: EducationKPIOrderByWithRelationInput | EducationKPIOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EducationKPIS.
     */
    cursor?: EducationKPIWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EducationKPIS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EducationKPIS.
     */
    skip?: number
    distinct?: EducationKPIScalarFieldEnum | EducationKPIScalarFieldEnum[]
  }

  /**
   * EducationKPI create
   */
  export type EducationKPICreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationKPI
     */
    select?: EducationKPISelect<ExtArgs> | null
    /**
     * The data needed to create a EducationKPI.
     */
    data: XOR<EducationKPICreateInput, EducationKPIUncheckedCreateInput>
  }

  /**
   * EducationKPI createMany
   */
  export type EducationKPICreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EducationKPIS.
     */
    data: EducationKPICreateManyInput | EducationKPICreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EducationKPI createManyAndReturn
   */
  export type EducationKPICreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationKPI
     */
    select?: EducationKPISelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EducationKPIS.
     */
    data: EducationKPICreateManyInput | EducationKPICreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EducationKPI update
   */
  export type EducationKPIUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationKPI
     */
    select?: EducationKPISelect<ExtArgs> | null
    /**
     * The data needed to update a EducationKPI.
     */
    data: XOR<EducationKPIUpdateInput, EducationKPIUncheckedUpdateInput>
    /**
     * Choose, which EducationKPI to update.
     */
    where: EducationKPIWhereUniqueInput
  }

  /**
   * EducationKPI updateMany
   */
  export type EducationKPIUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EducationKPIS.
     */
    data: XOR<EducationKPIUpdateManyMutationInput, EducationKPIUncheckedUpdateManyInput>
    /**
     * Filter which EducationKPIS to update
     */
    where?: EducationKPIWhereInput
  }

  /**
   * EducationKPI upsert
   */
  export type EducationKPIUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationKPI
     */
    select?: EducationKPISelect<ExtArgs> | null
    /**
     * The filter to search for the EducationKPI to update in case it exists.
     */
    where: EducationKPIWhereUniqueInput
    /**
     * In case the EducationKPI found by the `where` argument doesn't exist, create a new EducationKPI with this data.
     */
    create: XOR<EducationKPICreateInput, EducationKPIUncheckedCreateInput>
    /**
     * In case the EducationKPI was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EducationKPIUpdateInput, EducationKPIUncheckedUpdateInput>
  }

  /**
   * EducationKPI delete
   */
  export type EducationKPIDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationKPI
     */
    select?: EducationKPISelect<ExtArgs> | null
    /**
     * Filter which EducationKPI to delete.
     */
    where: EducationKPIWhereUniqueInput
  }

  /**
   * EducationKPI deleteMany
   */
  export type EducationKPIDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EducationKPIS to delete
     */
    where?: EducationKPIWhereInput
  }

  /**
   * EducationKPI without action
   */
  export type EducationKPIDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationKPI
     */
    select?: EducationKPISelect<ExtArgs> | null
  }


  /**
   * Model LearningProgress
   */

  export type AggregateLearningProgress = {
    _count: LearningProgressCountAggregateOutputType | null
    _avg: LearningProgressAvgAggregateOutputType | null
    _sum: LearningProgressSumAggregateOutputType | null
    _min: LearningProgressMinAggregateOutputType | null
    _max: LearningProgressMaxAggregateOutputType | null
  }

  export type LearningProgressAvgAggregateOutputType = {
    id: number | null
    watched70Lesson: number | null
    watched70All: number | null
    totalLearners: number | null
    preTestTotal: number | null
    preTestPassed: number | null
    postTestTotal: number | null
    postTestPassed: number | null
  }

  export type LearningProgressSumAggregateOutputType = {
    id: number | null
    watched70Lesson: number | null
    watched70All: number | null
    totalLearners: number | null
    preTestTotal: number | null
    preTestPassed: number | null
    postTestTotal: number | null
    postTestPassed: number | null
  }

  export type LearningProgressMinAggregateOutputType = {
    id: number | null
    watched70Lesson: number | null
    watched70All: number | null
    totalLearners: number | null
    preTestTotal: number | null
    preTestPassed: number | null
    postTestTotal: number | null
    postTestPassed: number | null
    updatedAt: Date | null
  }

  export type LearningProgressMaxAggregateOutputType = {
    id: number | null
    watched70Lesson: number | null
    watched70All: number | null
    totalLearners: number | null
    preTestTotal: number | null
    preTestPassed: number | null
    postTestTotal: number | null
    postTestPassed: number | null
    updatedAt: Date | null
  }

  export type LearningProgressCountAggregateOutputType = {
    id: number
    watched70Lesson: number
    watched70All: number
    totalLearners: number
    preTestTotal: number
    preTestPassed: number
    postTestTotal: number
    postTestPassed: number
    updatedAt: number
    _all: number
  }


  export type LearningProgressAvgAggregateInputType = {
    id?: true
    watched70Lesson?: true
    watched70All?: true
    totalLearners?: true
    preTestTotal?: true
    preTestPassed?: true
    postTestTotal?: true
    postTestPassed?: true
  }

  export type LearningProgressSumAggregateInputType = {
    id?: true
    watched70Lesson?: true
    watched70All?: true
    totalLearners?: true
    preTestTotal?: true
    preTestPassed?: true
    postTestTotal?: true
    postTestPassed?: true
  }

  export type LearningProgressMinAggregateInputType = {
    id?: true
    watched70Lesson?: true
    watched70All?: true
    totalLearners?: true
    preTestTotal?: true
    preTestPassed?: true
    postTestTotal?: true
    postTestPassed?: true
    updatedAt?: true
  }

  export type LearningProgressMaxAggregateInputType = {
    id?: true
    watched70Lesson?: true
    watched70All?: true
    totalLearners?: true
    preTestTotal?: true
    preTestPassed?: true
    postTestTotal?: true
    postTestPassed?: true
    updatedAt?: true
  }

  export type LearningProgressCountAggregateInputType = {
    id?: true
    watched70Lesson?: true
    watched70All?: true
    totalLearners?: true
    preTestTotal?: true
    preTestPassed?: true
    postTestTotal?: true
    postTestPassed?: true
    updatedAt?: true
    _all?: true
  }

  export type LearningProgressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LearningProgress to aggregate.
     */
    where?: LearningProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningProgresses to fetch.
     */
    orderBy?: LearningProgressOrderByWithRelationInput | LearningProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LearningProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LearningProgresses
    **/
    _count?: true | LearningProgressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LearningProgressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LearningProgressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LearningProgressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LearningProgressMaxAggregateInputType
  }

  export type GetLearningProgressAggregateType<T extends LearningProgressAggregateArgs> = {
        [P in keyof T & keyof AggregateLearningProgress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLearningProgress[P]>
      : GetScalarType<T[P], AggregateLearningProgress[P]>
  }




  export type LearningProgressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LearningProgressWhereInput
    orderBy?: LearningProgressOrderByWithAggregationInput | LearningProgressOrderByWithAggregationInput[]
    by: LearningProgressScalarFieldEnum[] | LearningProgressScalarFieldEnum
    having?: LearningProgressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LearningProgressCountAggregateInputType | true
    _avg?: LearningProgressAvgAggregateInputType
    _sum?: LearningProgressSumAggregateInputType
    _min?: LearningProgressMinAggregateInputType
    _max?: LearningProgressMaxAggregateInputType
  }

  export type LearningProgressGroupByOutputType = {
    id: number
    watched70Lesson: number
    watched70All: number
    totalLearners: number
    preTestTotal: number
    preTestPassed: number
    postTestTotal: number
    postTestPassed: number
    updatedAt: Date
    _count: LearningProgressCountAggregateOutputType | null
    _avg: LearningProgressAvgAggregateOutputType | null
    _sum: LearningProgressSumAggregateOutputType | null
    _min: LearningProgressMinAggregateOutputType | null
    _max: LearningProgressMaxAggregateOutputType | null
  }

  type GetLearningProgressGroupByPayload<T extends LearningProgressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LearningProgressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LearningProgressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LearningProgressGroupByOutputType[P]>
            : GetScalarType<T[P], LearningProgressGroupByOutputType[P]>
        }
      >
    >


  export type LearningProgressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    watched70Lesson?: boolean
    watched70All?: boolean
    totalLearners?: boolean
    preTestTotal?: boolean
    preTestPassed?: boolean
    postTestTotal?: boolean
    postTestPassed?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["learningProgress"]>

  export type LearningProgressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    watched70Lesson?: boolean
    watched70All?: boolean
    totalLearners?: boolean
    preTestTotal?: boolean
    preTestPassed?: boolean
    postTestTotal?: boolean
    postTestPassed?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["learningProgress"]>

  export type LearningProgressSelectScalar = {
    id?: boolean
    watched70Lesson?: boolean
    watched70All?: boolean
    totalLearners?: boolean
    preTestTotal?: boolean
    preTestPassed?: boolean
    postTestTotal?: boolean
    postTestPassed?: boolean
    updatedAt?: boolean
  }


  export type $LearningProgressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LearningProgress"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      watched70Lesson: number
      watched70All: number
      totalLearners: number
      preTestTotal: number
      preTestPassed: number
      postTestTotal: number
      postTestPassed: number
      updatedAt: Date
    }, ExtArgs["result"]["learningProgress"]>
    composites: {}
  }

  type LearningProgressGetPayload<S extends boolean | null | undefined | LearningProgressDefaultArgs> = $Result.GetResult<Prisma.$LearningProgressPayload, S>

  type LearningProgressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LearningProgressFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LearningProgressCountAggregateInputType | true
    }

  export interface LearningProgressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LearningProgress'], meta: { name: 'LearningProgress' } }
    /**
     * Find zero or one LearningProgress that matches the filter.
     * @param {LearningProgressFindUniqueArgs} args - Arguments to find a LearningProgress
     * @example
     * // Get one LearningProgress
     * const learningProgress = await prisma.learningProgress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LearningProgressFindUniqueArgs>(args: SelectSubset<T, LearningProgressFindUniqueArgs<ExtArgs>>): Prisma__LearningProgressClient<$Result.GetResult<Prisma.$LearningProgressPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LearningProgress that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LearningProgressFindUniqueOrThrowArgs} args - Arguments to find a LearningProgress
     * @example
     * // Get one LearningProgress
     * const learningProgress = await prisma.learningProgress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LearningProgressFindUniqueOrThrowArgs>(args: SelectSubset<T, LearningProgressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LearningProgressClient<$Result.GetResult<Prisma.$LearningProgressPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LearningProgress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningProgressFindFirstArgs} args - Arguments to find a LearningProgress
     * @example
     * // Get one LearningProgress
     * const learningProgress = await prisma.learningProgress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LearningProgressFindFirstArgs>(args?: SelectSubset<T, LearningProgressFindFirstArgs<ExtArgs>>): Prisma__LearningProgressClient<$Result.GetResult<Prisma.$LearningProgressPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LearningProgress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningProgressFindFirstOrThrowArgs} args - Arguments to find a LearningProgress
     * @example
     * // Get one LearningProgress
     * const learningProgress = await prisma.learningProgress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LearningProgressFindFirstOrThrowArgs>(args?: SelectSubset<T, LearningProgressFindFirstOrThrowArgs<ExtArgs>>): Prisma__LearningProgressClient<$Result.GetResult<Prisma.$LearningProgressPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LearningProgresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningProgressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LearningProgresses
     * const learningProgresses = await prisma.learningProgress.findMany()
     * 
     * // Get first 10 LearningProgresses
     * const learningProgresses = await prisma.learningProgress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const learningProgressWithIdOnly = await prisma.learningProgress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LearningProgressFindManyArgs>(args?: SelectSubset<T, LearningProgressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningProgressPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LearningProgress.
     * @param {LearningProgressCreateArgs} args - Arguments to create a LearningProgress.
     * @example
     * // Create one LearningProgress
     * const LearningProgress = await prisma.learningProgress.create({
     *   data: {
     *     // ... data to create a LearningProgress
     *   }
     * })
     * 
     */
    create<T extends LearningProgressCreateArgs>(args: SelectSubset<T, LearningProgressCreateArgs<ExtArgs>>): Prisma__LearningProgressClient<$Result.GetResult<Prisma.$LearningProgressPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LearningProgresses.
     * @param {LearningProgressCreateManyArgs} args - Arguments to create many LearningProgresses.
     * @example
     * // Create many LearningProgresses
     * const learningProgress = await prisma.learningProgress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LearningProgressCreateManyArgs>(args?: SelectSubset<T, LearningProgressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LearningProgresses and returns the data saved in the database.
     * @param {LearningProgressCreateManyAndReturnArgs} args - Arguments to create many LearningProgresses.
     * @example
     * // Create many LearningProgresses
     * const learningProgress = await prisma.learningProgress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LearningProgresses and only return the `id`
     * const learningProgressWithIdOnly = await prisma.learningProgress.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LearningProgressCreateManyAndReturnArgs>(args?: SelectSubset<T, LearningProgressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningProgressPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LearningProgress.
     * @param {LearningProgressDeleteArgs} args - Arguments to delete one LearningProgress.
     * @example
     * // Delete one LearningProgress
     * const LearningProgress = await prisma.learningProgress.delete({
     *   where: {
     *     // ... filter to delete one LearningProgress
     *   }
     * })
     * 
     */
    delete<T extends LearningProgressDeleteArgs>(args: SelectSubset<T, LearningProgressDeleteArgs<ExtArgs>>): Prisma__LearningProgressClient<$Result.GetResult<Prisma.$LearningProgressPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LearningProgress.
     * @param {LearningProgressUpdateArgs} args - Arguments to update one LearningProgress.
     * @example
     * // Update one LearningProgress
     * const learningProgress = await prisma.learningProgress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LearningProgressUpdateArgs>(args: SelectSubset<T, LearningProgressUpdateArgs<ExtArgs>>): Prisma__LearningProgressClient<$Result.GetResult<Prisma.$LearningProgressPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LearningProgresses.
     * @param {LearningProgressDeleteManyArgs} args - Arguments to filter LearningProgresses to delete.
     * @example
     * // Delete a few LearningProgresses
     * const { count } = await prisma.learningProgress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LearningProgressDeleteManyArgs>(args?: SelectSubset<T, LearningProgressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LearningProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningProgressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LearningProgresses
     * const learningProgress = await prisma.learningProgress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LearningProgressUpdateManyArgs>(args: SelectSubset<T, LearningProgressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LearningProgress.
     * @param {LearningProgressUpsertArgs} args - Arguments to update or create a LearningProgress.
     * @example
     * // Update or create a LearningProgress
     * const learningProgress = await prisma.learningProgress.upsert({
     *   create: {
     *     // ... data to create a LearningProgress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LearningProgress we want to update
     *   }
     * })
     */
    upsert<T extends LearningProgressUpsertArgs>(args: SelectSubset<T, LearningProgressUpsertArgs<ExtArgs>>): Prisma__LearningProgressClient<$Result.GetResult<Prisma.$LearningProgressPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LearningProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningProgressCountArgs} args - Arguments to filter LearningProgresses to count.
     * @example
     * // Count the number of LearningProgresses
     * const count = await prisma.learningProgress.count({
     *   where: {
     *     // ... the filter for the LearningProgresses we want to count
     *   }
     * })
    **/
    count<T extends LearningProgressCountArgs>(
      args?: Subset<T, LearningProgressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LearningProgressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LearningProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningProgressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LearningProgressAggregateArgs>(args: Subset<T, LearningProgressAggregateArgs>): Prisma.PrismaPromise<GetLearningProgressAggregateType<T>>

    /**
     * Group by LearningProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningProgressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LearningProgressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LearningProgressGroupByArgs['orderBy'] }
        : { orderBy?: LearningProgressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LearningProgressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLearningProgressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LearningProgress model
   */
  readonly fields: LearningProgressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LearningProgress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LearningProgressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LearningProgress model
   */ 
  interface LearningProgressFieldRefs {
    readonly id: FieldRef<"LearningProgress", 'Int'>
    readonly watched70Lesson: FieldRef<"LearningProgress", 'Int'>
    readonly watched70All: FieldRef<"LearningProgress", 'Int'>
    readonly totalLearners: FieldRef<"LearningProgress", 'Int'>
    readonly preTestTotal: FieldRef<"LearningProgress", 'Int'>
    readonly preTestPassed: FieldRef<"LearningProgress", 'Int'>
    readonly postTestTotal: FieldRef<"LearningProgress", 'Int'>
    readonly postTestPassed: FieldRef<"LearningProgress", 'Int'>
    readonly updatedAt: FieldRef<"LearningProgress", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LearningProgress findUnique
   */
  export type LearningProgressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningProgress
     */
    select?: LearningProgressSelect<ExtArgs> | null
    /**
     * Filter, which LearningProgress to fetch.
     */
    where: LearningProgressWhereUniqueInput
  }

  /**
   * LearningProgress findUniqueOrThrow
   */
  export type LearningProgressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningProgress
     */
    select?: LearningProgressSelect<ExtArgs> | null
    /**
     * Filter, which LearningProgress to fetch.
     */
    where: LearningProgressWhereUniqueInput
  }

  /**
   * LearningProgress findFirst
   */
  export type LearningProgressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningProgress
     */
    select?: LearningProgressSelect<ExtArgs> | null
    /**
     * Filter, which LearningProgress to fetch.
     */
    where?: LearningProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningProgresses to fetch.
     */
    orderBy?: LearningProgressOrderByWithRelationInput | LearningProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LearningProgresses.
     */
    cursor?: LearningProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LearningProgresses.
     */
    distinct?: LearningProgressScalarFieldEnum | LearningProgressScalarFieldEnum[]
  }

  /**
   * LearningProgress findFirstOrThrow
   */
  export type LearningProgressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningProgress
     */
    select?: LearningProgressSelect<ExtArgs> | null
    /**
     * Filter, which LearningProgress to fetch.
     */
    where?: LearningProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningProgresses to fetch.
     */
    orderBy?: LearningProgressOrderByWithRelationInput | LearningProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LearningProgresses.
     */
    cursor?: LearningProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LearningProgresses.
     */
    distinct?: LearningProgressScalarFieldEnum | LearningProgressScalarFieldEnum[]
  }

  /**
   * LearningProgress findMany
   */
  export type LearningProgressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningProgress
     */
    select?: LearningProgressSelect<ExtArgs> | null
    /**
     * Filter, which LearningProgresses to fetch.
     */
    where?: LearningProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningProgresses to fetch.
     */
    orderBy?: LearningProgressOrderByWithRelationInput | LearningProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LearningProgresses.
     */
    cursor?: LearningProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningProgresses.
     */
    skip?: number
    distinct?: LearningProgressScalarFieldEnum | LearningProgressScalarFieldEnum[]
  }

  /**
   * LearningProgress create
   */
  export type LearningProgressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningProgress
     */
    select?: LearningProgressSelect<ExtArgs> | null
    /**
     * The data needed to create a LearningProgress.
     */
    data: XOR<LearningProgressCreateInput, LearningProgressUncheckedCreateInput>
  }

  /**
   * LearningProgress createMany
   */
  export type LearningProgressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LearningProgresses.
     */
    data: LearningProgressCreateManyInput | LearningProgressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LearningProgress createManyAndReturn
   */
  export type LearningProgressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningProgress
     */
    select?: LearningProgressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LearningProgresses.
     */
    data: LearningProgressCreateManyInput | LearningProgressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LearningProgress update
   */
  export type LearningProgressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningProgress
     */
    select?: LearningProgressSelect<ExtArgs> | null
    /**
     * The data needed to update a LearningProgress.
     */
    data: XOR<LearningProgressUpdateInput, LearningProgressUncheckedUpdateInput>
    /**
     * Choose, which LearningProgress to update.
     */
    where: LearningProgressWhereUniqueInput
  }

  /**
   * LearningProgress updateMany
   */
  export type LearningProgressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LearningProgresses.
     */
    data: XOR<LearningProgressUpdateManyMutationInput, LearningProgressUncheckedUpdateManyInput>
    /**
     * Filter which LearningProgresses to update
     */
    where?: LearningProgressWhereInput
  }

  /**
   * LearningProgress upsert
   */
  export type LearningProgressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningProgress
     */
    select?: LearningProgressSelect<ExtArgs> | null
    /**
     * The filter to search for the LearningProgress to update in case it exists.
     */
    where: LearningProgressWhereUniqueInput
    /**
     * In case the LearningProgress found by the `where` argument doesn't exist, create a new LearningProgress with this data.
     */
    create: XOR<LearningProgressCreateInput, LearningProgressUncheckedCreateInput>
    /**
     * In case the LearningProgress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LearningProgressUpdateInput, LearningProgressUncheckedUpdateInput>
  }

  /**
   * LearningProgress delete
   */
  export type LearningProgressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningProgress
     */
    select?: LearningProgressSelect<ExtArgs> | null
    /**
     * Filter which LearningProgress to delete.
     */
    where: LearningProgressWhereUniqueInput
  }

  /**
   * LearningProgress deleteMany
   */
  export type LearningProgressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LearningProgresses to delete
     */
    where?: LearningProgressWhereInput
  }

  /**
   * LearningProgress without action
   */
  export type LearningProgressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningProgress
     */
    select?: LearningProgressSelect<ExtArgs> | null
  }


  /**
   * Model RevenueReport
   */

  export type AggregateRevenueReport = {
    _count: RevenueReportCountAggregateOutputType | null
    _avg: RevenueReportAvgAggregateOutputType | null
    _sum: RevenueReportSumAggregateOutputType | null
    _min: RevenueReportMinAggregateOutputType | null
    _max: RevenueReportMaxAggregateOutputType | null
  }

  export type RevenueReportAvgAggregateOutputType = {
    id: number | null
    revenue: number | null
    orders: number | null
    avgOrderValue: number | null
    growth: number | null
  }

  export type RevenueReportSumAggregateOutputType = {
    id: number | null
    revenue: number | null
    orders: number | null
    avgOrderValue: number | null
    growth: number | null
  }

  export type RevenueReportMinAggregateOutputType = {
    id: number | null
    month: string | null
    revenue: number | null
    orders: number | null
    avgOrderValue: number | null
    growth: number | null
    createdAt: Date | null
  }

  export type RevenueReportMaxAggregateOutputType = {
    id: number | null
    month: string | null
    revenue: number | null
    orders: number | null
    avgOrderValue: number | null
    growth: number | null
    createdAt: Date | null
  }

  export type RevenueReportCountAggregateOutputType = {
    id: number
    month: number
    revenue: number
    orders: number
    avgOrderValue: number
    growth: number
    createdAt: number
    _all: number
  }


  export type RevenueReportAvgAggregateInputType = {
    id?: true
    revenue?: true
    orders?: true
    avgOrderValue?: true
    growth?: true
  }

  export type RevenueReportSumAggregateInputType = {
    id?: true
    revenue?: true
    orders?: true
    avgOrderValue?: true
    growth?: true
  }

  export type RevenueReportMinAggregateInputType = {
    id?: true
    month?: true
    revenue?: true
    orders?: true
    avgOrderValue?: true
    growth?: true
    createdAt?: true
  }

  export type RevenueReportMaxAggregateInputType = {
    id?: true
    month?: true
    revenue?: true
    orders?: true
    avgOrderValue?: true
    growth?: true
    createdAt?: true
  }

  export type RevenueReportCountAggregateInputType = {
    id?: true
    month?: true
    revenue?: true
    orders?: true
    avgOrderValue?: true
    growth?: true
    createdAt?: true
    _all?: true
  }

  export type RevenueReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RevenueReport to aggregate.
     */
    where?: RevenueReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RevenueReports to fetch.
     */
    orderBy?: RevenueReportOrderByWithRelationInput | RevenueReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RevenueReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RevenueReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RevenueReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RevenueReports
    **/
    _count?: true | RevenueReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RevenueReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RevenueReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RevenueReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RevenueReportMaxAggregateInputType
  }

  export type GetRevenueReportAggregateType<T extends RevenueReportAggregateArgs> = {
        [P in keyof T & keyof AggregateRevenueReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRevenueReport[P]>
      : GetScalarType<T[P], AggregateRevenueReport[P]>
  }




  export type RevenueReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RevenueReportWhereInput
    orderBy?: RevenueReportOrderByWithAggregationInput | RevenueReportOrderByWithAggregationInput[]
    by: RevenueReportScalarFieldEnum[] | RevenueReportScalarFieldEnum
    having?: RevenueReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RevenueReportCountAggregateInputType | true
    _avg?: RevenueReportAvgAggregateInputType
    _sum?: RevenueReportSumAggregateInputType
    _min?: RevenueReportMinAggregateInputType
    _max?: RevenueReportMaxAggregateInputType
  }

  export type RevenueReportGroupByOutputType = {
    id: number
    month: string
    revenue: number
    orders: number
    avgOrderValue: number
    growth: number
    createdAt: Date
    _count: RevenueReportCountAggregateOutputType | null
    _avg: RevenueReportAvgAggregateOutputType | null
    _sum: RevenueReportSumAggregateOutputType | null
    _min: RevenueReportMinAggregateOutputType | null
    _max: RevenueReportMaxAggregateOutputType | null
  }

  type GetRevenueReportGroupByPayload<T extends RevenueReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RevenueReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RevenueReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RevenueReportGroupByOutputType[P]>
            : GetScalarType<T[P], RevenueReportGroupByOutputType[P]>
        }
      >
    >


  export type RevenueReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    month?: boolean
    revenue?: boolean
    orders?: boolean
    avgOrderValue?: boolean
    growth?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["revenueReport"]>

  export type RevenueReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    month?: boolean
    revenue?: boolean
    orders?: boolean
    avgOrderValue?: boolean
    growth?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["revenueReport"]>

  export type RevenueReportSelectScalar = {
    id?: boolean
    month?: boolean
    revenue?: boolean
    orders?: boolean
    avgOrderValue?: boolean
    growth?: boolean
    createdAt?: boolean
  }


  export type $RevenueReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RevenueReport"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      month: string
      revenue: number
      orders: number
      avgOrderValue: number
      growth: number
      createdAt: Date
    }, ExtArgs["result"]["revenueReport"]>
    composites: {}
  }

  type RevenueReportGetPayload<S extends boolean | null | undefined | RevenueReportDefaultArgs> = $Result.GetResult<Prisma.$RevenueReportPayload, S>

  type RevenueReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RevenueReportFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RevenueReportCountAggregateInputType | true
    }

  export interface RevenueReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RevenueReport'], meta: { name: 'RevenueReport' } }
    /**
     * Find zero or one RevenueReport that matches the filter.
     * @param {RevenueReportFindUniqueArgs} args - Arguments to find a RevenueReport
     * @example
     * // Get one RevenueReport
     * const revenueReport = await prisma.revenueReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RevenueReportFindUniqueArgs>(args: SelectSubset<T, RevenueReportFindUniqueArgs<ExtArgs>>): Prisma__RevenueReportClient<$Result.GetResult<Prisma.$RevenueReportPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RevenueReport that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RevenueReportFindUniqueOrThrowArgs} args - Arguments to find a RevenueReport
     * @example
     * // Get one RevenueReport
     * const revenueReport = await prisma.revenueReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RevenueReportFindUniqueOrThrowArgs>(args: SelectSubset<T, RevenueReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RevenueReportClient<$Result.GetResult<Prisma.$RevenueReportPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RevenueReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevenueReportFindFirstArgs} args - Arguments to find a RevenueReport
     * @example
     * // Get one RevenueReport
     * const revenueReport = await prisma.revenueReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RevenueReportFindFirstArgs>(args?: SelectSubset<T, RevenueReportFindFirstArgs<ExtArgs>>): Prisma__RevenueReportClient<$Result.GetResult<Prisma.$RevenueReportPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RevenueReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevenueReportFindFirstOrThrowArgs} args - Arguments to find a RevenueReport
     * @example
     * // Get one RevenueReport
     * const revenueReport = await prisma.revenueReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RevenueReportFindFirstOrThrowArgs>(args?: SelectSubset<T, RevenueReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__RevenueReportClient<$Result.GetResult<Prisma.$RevenueReportPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RevenueReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevenueReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RevenueReports
     * const revenueReports = await prisma.revenueReport.findMany()
     * 
     * // Get first 10 RevenueReports
     * const revenueReports = await prisma.revenueReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const revenueReportWithIdOnly = await prisma.revenueReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RevenueReportFindManyArgs>(args?: SelectSubset<T, RevenueReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RevenueReportPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RevenueReport.
     * @param {RevenueReportCreateArgs} args - Arguments to create a RevenueReport.
     * @example
     * // Create one RevenueReport
     * const RevenueReport = await prisma.revenueReport.create({
     *   data: {
     *     // ... data to create a RevenueReport
     *   }
     * })
     * 
     */
    create<T extends RevenueReportCreateArgs>(args: SelectSubset<T, RevenueReportCreateArgs<ExtArgs>>): Prisma__RevenueReportClient<$Result.GetResult<Prisma.$RevenueReportPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RevenueReports.
     * @param {RevenueReportCreateManyArgs} args - Arguments to create many RevenueReports.
     * @example
     * // Create many RevenueReports
     * const revenueReport = await prisma.revenueReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RevenueReportCreateManyArgs>(args?: SelectSubset<T, RevenueReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RevenueReports and returns the data saved in the database.
     * @param {RevenueReportCreateManyAndReturnArgs} args - Arguments to create many RevenueReports.
     * @example
     * // Create many RevenueReports
     * const revenueReport = await prisma.revenueReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RevenueReports and only return the `id`
     * const revenueReportWithIdOnly = await prisma.revenueReport.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RevenueReportCreateManyAndReturnArgs>(args?: SelectSubset<T, RevenueReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RevenueReportPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RevenueReport.
     * @param {RevenueReportDeleteArgs} args - Arguments to delete one RevenueReport.
     * @example
     * // Delete one RevenueReport
     * const RevenueReport = await prisma.revenueReport.delete({
     *   where: {
     *     // ... filter to delete one RevenueReport
     *   }
     * })
     * 
     */
    delete<T extends RevenueReportDeleteArgs>(args: SelectSubset<T, RevenueReportDeleteArgs<ExtArgs>>): Prisma__RevenueReportClient<$Result.GetResult<Prisma.$RevenueReportPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RevenueReport.
     * @param {RevenueReportUpdateArgs} args - Arguments to update one RevenueReport.
     * @example
     * // Update one RevenueReport
     * const revenueReport = await prisma.revenueReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RevenueReportUpdateArgs>(args: SelectSubset<T, RevenueReportUpdateArgs<ExtArgs>>): Prisma__RevenueReportClient<$Result.GetResult<Prisma.$RevenueReportPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RevenueReports.
     * @param {RevenueReportDeleteManyArgs} args - Arguments to filter RevenueReports to delete.
     * @example
     * // Delete a few RevenueReports
     * const { count } = await prisma.revenueReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RevenueReportDeleteManyArgs>(args?: SelectSubset<T, RevenueReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RevenueReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevenueReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RevenueReports
     * const revenueReport = await prisma.revenueReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RevenueReportUpdateManyArgs>(args: SelectSubset<T, RevenueReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RevenueReport.
     * @param {RevenueReportUpsertArgs} args - Arguments to update or create a RevenueReport.
     * @example
     * // Update or create a RevenueReport
     * const revenueReport = await prisma.revenueReport.upsert({
     *   create: {
     *     // ... data to create a RevenueReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RevenueReport we want to update
     *   }
     * })
     */
    upsert<T extends RevenueReportUpsertArgs>(args: SelectSubset<T, RevenueReportUpsertArgs<ExtArgs>>): Prisma__RevenueReportClient<$Result.GetResult<Prisma.$RevenueReportPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RevenueReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevenueReportCountArgs} args - Arguments to filter RevenueReports to count.
     * @example
     * // Count the number of RevenueReports
     * const count = await prisma.revenueReport.count({
     *   where: {
     *     // ... the filter for the RevenueReports we want to count
     *   }
     * })
    **/
    count<T extends RevenueReportCountArgs>(
      args?: Subset<T, RevenueReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RevenueReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RevenueReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevenueReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RevenueReportAggregateArgs>(args: Subset<T, RevenueReportAggregateArgs>): Prisma.PrismaPromise<GetRevenueReportAggregateType<T>>

    /**
     * Group by RevenueReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevenueReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RevenueReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RevenueReportGroupByArgs['orderBy'] }
        : { orderBy?: RevenueReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RevenueReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRevenueReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RevenueReport model
   */
  readonly fields: RevenueReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RevenueReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RevenueReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RevenueReport model
   */ 
  interface RevenueReportFieldRefs {
    readonly id: FieldRef<"RevenueReport", 'Int'>
    readonly month: FieldRef<"RevenueReport", 'String'>
    readonly revenue: FieldRef<"RevenueReport", 'Float'>
    readonly orders: FieldRef<"RevenueReport", 'Int'>
    readonly avgOrderValue: FieldRef<"RevenueReport", 'Float'>
    readonly growth: FieldRef<"RevenueReport", 'Float'>
    readonly createdAt: FieldRef<"RevenueReport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RevenueReport findUnique
   */
  export type RevenueReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueReport
     */
    select?: RevenueReportSelect<ExtArgs> | null
    /**
     * Filter, which RevenueReport to fetch.
     */
    where: RevenueReportWhereUniqueInput
  }

  /**
   * RevenueReport findUniqueOrThrow
   */
  export type RevenueReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueReport
     */
    select?: RevenueReportSelect<ExtArgs> | null
    /**
     * Filter, which RevenueReport to fetch.
     */
    where: RevenueReportWhereUniqueInput
  }

  /**
   * RevenueReport findFirst
   */
  export type RevenueReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueReport
     */
    select?: RevenueReportSelect<ExtArgs> | null
    /**
     * Filter, which RevenueReport to fetch.
     */
    where?: RevenueReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RevenueReports to fetch.
     */
    orderBy?: RevenueReportOrderByWithRelationInput | RevenueReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RevenueReports.
     */
    cursor?: RevenueReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RevenueReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RevenueReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RevenueReports.
     */
    distinct?: RevenueReportScalarFieldEnum | RevenueReportScalarFieldEnum[]
  }

  /**
   * RevenueReport findFirstOrThrow
   */
  export type RevenueReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueReport
     */
    select?: RevenueReportSelect<ExtArgs> | null
    /**
     * Filter, which RevenueReport to fetch.
     */
    where?: RevenueReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RevenueReports to fetch.
     */
    orderBy?: RevenueReportOrderByWithRelationInput | RevenueReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RevenueReports.
     */
    cursor?: RevenueReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RevenueReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RevenueReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RevenueReports.
     */
    distinct?: RevenueReportScalarFieldEnum | RevenueReportScalarFieldEnum[]
  }

  /**
   * RevenueReport findMany
   */
  export type RevenueReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueReport
     */
    select?: RevenueReportSelect<ExtArgs> | null
    /**
     * Filter, which RevenueReports to fetch.
     */
    where?: RevenueReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RevenueReports to fetch.
     */
    orderBy?: RevenueReportOrderByWithRelationInput | RevenueReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RevenueReports.
     */
    cursor?: RevenueReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RevenueReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RevenueReports.
     */
    skip?: number
    distinct?: RevenueReportScalarFieldEnum | RevenueReportScalarFieldEnum[]
  }

  /**
   * RevenueReport create
   */
  export type RevenueReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueReport
     */
    select?: RevenueReportSelect<ExtArgs> | null
    /**
     * The data needed to create a RevenueReport.
     */
    data: XOR<RevenueReportCreateInput, RevenueReportUncheckedCreateInput>
  }

  /**
   * RevenueReport createMany
   */
  export type RevenueReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RevenueReports.
     */
    data: RevenueReportCreateManyInput | RevenueReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RevenueReport createManyAndReturn
   */
  export type RevenueReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueReport
     */
    select?: RevenueReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RevenueReports.
     */
    data: RevenueReportCreateManyInput | RevenueReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RevenueReport update
   */
  export type RevenueReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueReport
     */
    select?: RevenueReportSelect<ExtArgs> | null
    /**
     * The data needed to update a RevenueReport.
     */
    data: XOR<RevenueReportUpdateInput, RevenueReportUncheckedUpdateInput>
    /**
     * Choose, which RevenueReport to update.
     */
    where: RevenueReportWhereUniqueInput
  }

  /**
   * RevenueReport updateMany
   */
  export type RevenueReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RevenueReports.
     */
    data: XOR<RevenueReportUpdateManyMutationInput, RevenueReportUncheckedUpdateManyInput>
    /**
     * Filter which RevenueReports to update
     */
    where?: RevenueReportWhereInput
  }

  /**
   * RevenueReport upsert
   */
  export type RevenueReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueReport
     */
    select?: RevenueReportSelect<ExtArgs> | null
    /**
     * The filter to search for the RevenueReport to update in case it exists.
     */
    where: RevenueReportWhereUniqueInput
    /**
     * In case the RevenueReport found by the `where` argument doesn't exist, create a new RevenueReport with this data.
     */
    create: XOR<RevenueReportCreateInput, RevenueReportUncheckedCreateInput>
    /**
     * In case the RevenueReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RevenueReportUpdateInput, RevenueReportUncheckedUpdateInput>
  }

  /**
   * RevenueReport delete
   */
  export type RevenueReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueReport
     */
    select?: RevenueReportSelect<ExtArgs> | null
    /**
     * Filter which RevenueReport to delete.
     */
    where: RevenueReportWhereUniqueInput
  }

  /**
   * RevenueReport deleteMany
   */
  export type RevenueReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RevenueReports to delete
     */
    where?: RevenueReportWhereInput
  }

  /**
   * RevenueReport without action
   */
  export type RevenueReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueReport
     */
    select?: RevenueReportSelect<ExtArgs> | null
  }


  /**
   * Model UserAnalytics
   */

  export type AggregateUserAnalytics = {
    _count: UserAnalyticsCountAggregateOutputType | null
    _avg: UserAnalyticsAvgAggregateOutputType | null
    _sum: UserAnalyticsSumAggregateOutputType | null
    _min: UserAnalyticsMinAggregateOutputType | null
    _max: UserAnalyticsMaxAggregateOutputType | null
  }

  export type UserAnalyticsAvgAggregateOutputType = {
    id: number | null
    totalUsers: number | null
    activeUsers: number | null
    activityRate: number | null
    multipleSessionUsers: number | null
  }

  export type UserAnalyticsSumAggregateOutputType = {
    id: number | null
    totalUsers: number | null
    activeUsers: number | null
    activityRate: number | null
    multipleSessionUsers: number | null
  }

  export type UserAnalyticsMinAggregateOutputType = {
    id: number | null
    totalUsers: number | null
    activeUsers: number | null
    activityRate: number | null
    multipleSessionUsers: number | null
    updatedAt: Date | null
  }

  export type UserAnalyticsMaxAggregateOutputType = {
    id: number | null
    totalUsers: number | null
    activeUsers: number | null
    activityRate: number | null
    multipleSessionUsers: number | null
    updatedAt: Date | null
  }

  export type UserAnalyticsCountAggregateOutputType = {
    id: number
    totalUsers: number
    activeUsers: number
    activityRate: number
    multipleSessionUsers: number
    updatedAt: number
    _all: number
  }


  export type UserAnalyticsAvgAggregateInputType = {
    id?: true
    totalUsers?: true
    activeUsers?: true
    activityRate?: true
    multipleSessionUsers?: true
  }

  export type UserAnalyticsSumAggregateInputType = {
    id?: true
    totalUsers?: true
    activeUsers?: true
    activityRate?: true
    multipleSessionUsers?: true
  }

  export type UserAnalyticsMinAggregateInputType = {
    id?: true
    totalUsers?: true
    activeUsers?: true
    activityRate?: true
    multipleSessionUsers?: true
    updatedAt?: true
  }

  export type UserAnalyticsMaxAggregateInputType = {
    id?: true
    totalUsers?: true
    activeUsers?: true
    activityRate?: true
    multipleSessionUsers?: true
    updatedAt?: true
  }

  export type UserAnalyticsCountAggregateInputType = {
    id?: true
    totalUsers?: true
    activeUsers?: true
    activityRate?: true
    multipleSessionUsers?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAnalyticsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAnalytics to aggregate.
     */
    where?: UserAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAnalytics to fetch.
     */
    orderBy?: UserAnalyticsOrderByWithRelationInput | UserAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserAnalytics
    **/
    _count?: true | UserAnalyticsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAnalyticsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserAnalyticsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserAnalyticsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserAnalyticsMaxAggregateInputType
  }

  export type GetUserAnalyticsAggregateType<T extends UserAnalyticsAggregateArgs> = {
        [P in keyof T & keyof AggregateUserAnalytics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserAnalytics[P]>
      : GetScalarType<T[P], AggregateUserAnalytics[P]>
  }




  export type UserAnalyticsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAnalyticsWhereInput
    orderBy?: UserAnalyticsOrderByWithAggregationInput | UserAnalyticsOrderByWithAggregationInput[]
    by: UserAnalyticsScalarFieldEnum[] | UserAnalyticsScalarFieldEnum
    having?: UserAnalyticsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserAnalyticsCountAggregateInputType | true
    _avg?: UserAnalyticsAvgAggregateInputType
    _sum?: UserAnalyticsSumAggregateInputType
    _min?: UserAnalyticsMinAggregateInputType
    _max?: UserAnalyticsMaxAggregateInputType
  }

  export type UserAnalyticsGroupByOutputType = {
    id: number
    totalUsers: number
    activeUsers: number
    activityRate: number
    multipleSessionUsers: number
    updatedAt: Date
    _count: UserAnalyticsCountAggregateOutputType | null
    _avg: UserAnalyticsAvgAggregateOutputType | null
    _sum: UserAnalyticsSumAggregateOutputType | null
    _min: UserAnalyticsMinAggregateOutputType | null
    _max: UserAnalyticsMaxAggregateOutputType | null
  }

  type GetUserAnalyticsGroupByPayload<T extends UserAnalyticsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserAnalyticsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserAnalyticsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserAnalyticsGroupByOutputType[P]>
            : GetScalarType<T[P], UserAnalyticsGroupByOutputType[P]>
        }
      >
    >


  export type UserAnalyticsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    totalUsers?: boolean
    activeUsers?: boolean
    activityRate?: boolean
    multipleSessionUsers?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["userAnalytics"]>

  export type UserAnalyticsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    totalUsers?: boolean
    activeUsers?: boolean
    activityRate?: boolean
    multipleSessionUsers?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["userAnalytics"]>

  export type UserAnalyticsSelectScalar = {
    id?: boolean
    totalUsers?: boolean
    activeUsers?: boolean
    activityRate?: boolean
    multipleSessionUsers?: boolean
    updatedAt?: boolean
  }


  export type $UserAnalyticsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserAnalytics"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      totalUsers: number
      activeUsers: number
      activityRate: number
      multipleSessionUsers: number
      updatedAt: Date
    }, ExtArgs["result"]["userAnalytics"]>
    composites: {}
  }

  type UserAnalyticsGetPayload<S extends boolean | null | undefined | UserAnalyticsDefaultArgs> = $Result.GetResult<Prisma.$UserAnalyticsPayload, S>

  type UserAnalyticsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserAnalyticsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserAnalyticsCountAggregateInputType | true
    }

  export interface UserAnalyticsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserAnalytics'], meta: { name: 'UserAnalytics' } }
    /**
     * Find zero or one UserAnalytics that matches the filter.
     * @param {UserAnalyticsFindUniqueArgs} args - Arguments to find a UserAnalytics
     * @example
     * // Get one UserAnalytics
     * const userAnalytics = await prisma.userAnalytics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserAnalyticsFindUniqueArgs>(args: SelectSubset<T, UserAnalyticsFindUniqueArgs<ExtArgs>>): Prisma__UserAnalyticsClient<$Result.GetResult<Prisma.$UserAnalyticsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserAnalytics that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserAnalyticsFindUniqueOrThrowArgs} args - Arguments to find a UserAnalytics
     * @example
     * // Get one UserAnalytics
     * const userAnalytics = await prisma.userAnalytics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserAnalyticsFindUniqueOrThrowArgs>(args: SelectSubset<T, UserAnalyticsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserAnalyticsClient<$Result.GetResult<Prisma.$UserAnalyticsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAnalyticsFindFirstArgs} args - Arguments to find a UserAnalytics
     * @example
     * // Get one UserAnalytics
     * const userAnalytics = await prisma.userAnalytics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserAnalyticsFindFirstArgs>(args?: SelectSubset<T, UserAnalyticsFindFirstArgs<ExtArgs>>): Prisma__UserAnalyticsClient<$Result.GetResult<Prisma.$UserAnalyticsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserAnalytics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAnalyticsFindFirstOrThrowArgs} args - Arguments to find a UserAnalytics
     * @example
     * // Get one UserAnalytics
     * const userAnalytics = await prisma.userAnalytics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserAnalyticsFindFirstOrThrowArgs>(args?: SelectSubset<T, UserAnalyticsFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserAnalyticsClient<$Result.GetResult<Prisma.$UserAnalyticsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAnalyticsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserAnalytics
     * const userAnalytics = await prisma.userAnalytics.findMany()
     * 
     * // Get first 10 UserAnalytics
     * const userAnalytics = await prisma.userAnalytics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userAnalyticsWithIdOnly = await prisma.userAnalytics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserAnalyticsFindManyArgs>(args?: SelectSubset<T, UserAnalyticsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAnalyticsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserAnalytics.
     * @param {UserAnalyticsCreateArgs} args - Arguments to create a UserAnalytics.
     * @example
     * // Create one UserAnalytics
     * const UserAnalytics = await prisma.userAnalytics.create({
     *   data: {
     *     // ... data to create a UserAnalytics
     *   }
     * })
     * 
     */
    create<T extends UserAnalyticsCreateArgs>(args: SelectSubset<T, UserAnalyticsCreateArgs<ExtArgs>>): Prisma__UserAnalyticsClient<$Result.GetResult<Prisma.$UserAnalyticsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserAnalytics.
     * @param {UserAnalyticsCreateManyArgs} args - Arguments to create many UserAnalytics.
     * @example
     * // Create many UserAnalytics
     * const userAnalytics = await prisma.userAnalytics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserAnalyticsCreateManyArgs>(args?: SelectSubset<T, UserAnalyticsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserAnalytics and returns the data saved in the database.
     * @param {UserAnalyticsCreateManyAndReturnArgs} args - Arguments to create many UserAnalytics.
     * @example
     * // Create many UserAnalytics
     * const userAnalytics = await prisma.userAnalytics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserAnalytics and only return the `id`
     * const userAnalyticsWithIdOnly = await prisma.userAnalytics.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserAnalyticsCreateManyAndReturnArgs>(args?: SelectSubset<T, UserAnalyticsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAnalyticsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserAnalytics.
     * @param {UserAnalyticsDeleteArgs} args - Arguments to delete one UserAnalytics.
     * @example
     * // Delete one UserAnalytics
     * const UserAnalytics = await prisma.userAnalytics.delete({
     *   where: {
     *     // ... filter to delete one UserAnalytics
     *   }
     * })
     * 
     */
    delete<T extends UserAnalyticsDeleteArgs>(args: SelectSubset<T, UserAnalyticsDeleteArgs<ExtArgs>>): Prisma__UserAnalyticsClient<$Result.GetResult<Prisma.$UserAnalyticsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserAnalytics.
     * @param {UserAnalyticsUpdateArgs} args - Arguments to update one UserAnalytics.
     * @example
     * // Update one UserAnalytics
     * const userAnalytics = await prisma.userAnalytics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserAnalyticsUpdateArgs>(args: SelectSubset<T, UserAnalyticsUpdateArgs<ExtArgs>>): Prisma__UserAnalyticsClient<$Result.GetResult<Prisma.$UserAnalyticsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserAnalytics.
     * @param {UserAnalyticsDeleteManyArgs} args - Arguments to filter UserAnalytics to delete.
     * @example
     * // Delete a few UserAnalytics
     * const { count } = await prisma.userAnalytics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserAnalyticsDeleteManyArgs>(args?: SelectSubset<T, UserAnalyticsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAnalyticsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserAnalytics
     * const userAnalytics = await prisma.userAnalytics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserAnalyticsUpdateManyArgs>(args: SelectSubset<T, UserAnalyticsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserAnalytics.
     * @param {UserAnalyticsUpsertArgs} args - Arguments to update or create a UserAnalytics.
     * @example
     * // Update or create a UserAnalytics
     * const userAnalytics = await prisma.userAnalytics.upsert({
     *   create: {
     *     // ... data to create a UserAnalytics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserAnalytics we want to update
     *   }
     * })
     */
    upsert<T extends UserAnalyticsUpsertArgs>(args: SelectSubset<T, UserAnalyticsUpsertArgs<ExtArgs>>): Prisma__UserAnalyticsClient<$Result.GetResult<Prisma.$UserAnalyticsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAnalyticsCountArgs} args - Arguments to filter UserAnalytics to count.
     * @example
     * // Count the number of UserAnalytics
     * const count = await prisma.userAnalytics.count({
     *   where: {
     *     // ... the filter for the UserAnalytics we want to count
     *   }
     * })
    **/
    count<T extends UserAnalyticsCountArgs>(
      args?: Subset<T, UserAnalyticsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserAnalyticsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAnalyticsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAnalyticsAggregateArgs>(args: Subset<T, UserAnalyticsAggregateArgs>): Prisma.PrismaPromise<GetUserAnalyticsAggregateType<T>>

    /**
     * Group by UserAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAnalyticsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserAnalyticsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserAnalyticsGroupByArgs['orderBy'] }
        : { orderBy?: UserAnalyticsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserAnalyticsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserAnalyticsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserAnalytics model
   */
  readonly fields: UserAnalyticsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserAnalytics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserAnalyticsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserAnalytics model
   */ 
  interface UserAnalyticsFieldRefs {
    readonly id: FieldRef<"UserAnalytics", 'Int'>
    readonly totalUsers: FieldRef<"UserAnalytics", 'Int'>
    readonly activeUsers: FieldRef<"UserAnalytics", 'Int'>
    readonly activityRate: FieldRef<"UserAnalytics", 'Float'>
    readonly multipleSessionUsers: FieldRef<"UserAnalytics", 'Int'>
    readonly updatedAt: FieldRef<"UserAnalytics", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserAnalytics findUnique
   */
  export type UserAnalyticsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnalytics
     */
    select?: UserAnalyticsSelect<ExtArgs> | null
    /**
     * Filter, which UserAnalytics to fetch.
     */
    where: UserAnalyticsWhereUniqueInput
  }

  /**
   * UserAnalytics findUniqueOrThrow
   */
  export type UserAnalyticsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnalytics
     */
    select?: UserAnalyticsSelect<ExtArgs> | null
    /**
     * Filter, which UserAnalytics to fetch.
     */
    where: UserAnalyticsWhereUniqueInput
  }

  /**
   * UserAnalytics findFirst
   */
  export type UserAnalyticsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnalytics
     */
    select?: UserAnalyticsSelect<ExtArgs> | null
    /**
     * Filter, which UserAnalytics to fetch.
     */
    where?: UserAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAnalytics to fetch.
     */
    orderBy?: UserAnalyticsOrderByWithRelationInput | UserAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAnalytics.
     */
    cursor?: UserAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAnalytics.
     */
    distinct?: UserAnalyticsScalarFieldEnum | UserAnalyticsScalarFieldEnum[]
  }

  /**
   * UserAnalytics findFirstOrThrow
   */
  export type UserAnalyticsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnalytics
     */
    select?: UserAnalyticsSelect<ExtArgs> | null
    /**
     * Filter, which UserAnalytics to fetch.
     */
    where?: UserAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAnalytics to fetch.
     */
    orderBy?: UserAnalyticsOrderByWithRelationInput | UserAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAnalytics.
     */
    cursor?: UserAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAnalytics.
     */
    distinct?: UserAnalyticsScalarFieldEnum | UserAnalyticsScalarFieldEnum[]
  }

  /**
   * UserAnalytics findMany
   */
  export type UserAnalyticsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnalytics
     */
    select?: UserAnalyticsSelect<ExtArgs> | null
    /**
     * Filter, which UserAnalytics to fetch.
     */
    where?: UserAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAnalytics to fetch.
     */
    orderBy?: UserAnalyticsOrderByWithRelationInput | UserAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserAnalytics.
     */
    cursor?: UserAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAnalytics.
     */
    skip?: number
    distinct?: UserAnalyticsScalarFieldEnum | UserAnalyticsScalarFieldEnum[]
  }

  /**
   * UserAnalytics create
   */
  export type UserAnalyticsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnalytics
     */
    select?: UserAnalyticsSelect<ExtArgs> | null
    /**
     * The data needed to create a UserAnalytics.
     */
    data: XOR<UserAnalyticsCreateInput, UserAnalyticsUncheckedCreateInput>
  }

  /**
   * UserAnalytics createMany
   */
  export type UserAnalyticsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserAnalytics.
     */
    data: UserAnalyticsCreateManyInput | UserAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserAnalytics createManyAndReturn
   */
  export type UserAnalyticsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnalytics
     */
    select?: UserAnalyticsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserAnalytics.
     */
    data: UserAnalyticsCreateManyInput | UserAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserAnalytics update
   */
  export type UserAnalyticsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnalytics
     */
    select?: UserAnalyticsSelect<ExtArgs> | null
    /**
     * The data needed to update a UserAnalytics.
     */
    data: XOR<UserAnalyticsUpdateInput, UserAnalyticsUncheckedUpdateInput>
    /**
     * Choose, which UserAnalytics to update.
     */
    where: UserAnalyticsWhereUniqueInput
  }

  /**
   * UserAnalytics updateMany
   */
  export type UserAnalyticsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserAnalytics.
     */
    data: XOR<UserAnalyticsUpdateManyMutationInput, UserAnalyticsUncheckedUpdateManyInput>
    /**
     * Filter which UserAnalytics to update
     */
    where?: UserAnalyticsWhereInput
  }

  /**
   * UserAnalytics upsert
   */
  export type UserAnalyticsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnalytics
     */
    select?: UserAnalyticsSelect<ExtArgs> | null
    /**
     * The filter to search for the UserAnalytics to update in case it exists.
     */
    where: UserAnalyticsWhereUniqueInput
    /**
     * In case the UserAnalytics found by the `where` argument doesn't exist, create a new UserAnalytics with this data.
     */
    create: XOR<UserAnalyticsCreateInput, UserAnalyticsUncheckedCreateInput>
    /**
     * In case the UserAnalytics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserAnalyticsUpdateInput, UserAnalyticsUncheckedUpdateInput>
  }

  /**
   * UserAnalytics delete
   */
  export type UserAnalyticsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnalytics
     */
    select?: UserAnalyticsSelect<ExtArgs> | null
    /**
     * Filter which UserAnalytics to delete.
     */
    where: UserAnalyticsWhereUniqueInput
  }

  /**
   * UserAnalytics deleteMany
   */
  export type UserAnalyticsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAnalytics to delete
     */
    where?: UserAnalyticsWhereInput
  }

  /**
   * UserAnalytics without action
   */
  export type UserAnalyticsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnalytics
     */
    select?: UserAnalyticsSelect<ExtArgs> | null
  }


  /**
   * Model ExportTicket
   */

  export type AggregateExportTicket = {
    _count: ExportTicketCountAggregateOutputType | null
    _avg: ExportTicketAvgAggregateOutputType | null
    _sum: ExportTicketSumAggregateOutputType | null
    _min: ExportTicketMinAggregateOutputType | null
    _max: ExportTicketMaxAggregateOutputType | null
  }

  export type ExportTicketAvgAggregateOutputType = {
    id: number | null
    count: number | null
  }

  export type ExportTicketSumAggregateOutputType = {
    id: number | null
    count: number | null
  }

  export type ExportTicketMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    count: number | null
    icon: string | null
    color: string | null
    status: string | null
    fileUrl: string | null
    createdAt: Date | null
  }

  export type ExportTicketMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    count: number | null
    icon: string | null
    color: string | null
    status: string | null
    fileUrl: string | null
    createdAt: Date | null
  }

  export type ExportTicketCountAggregateOutputType = {
    id: number
    title: number
    description: number
    count: number
    icon: number
    color: number
    status: number
    fileUrl: number
    createdAt: number
    _all: number
  }


  export type ExportTicketAvgAggregateInputType = {
    id?: true
    count?: true
  }

  export type ExportTicketSumAggregateInputType = {
    id?: true
    count?: true
  }

  export type ExportTicketMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    count?: true
    icon?: true
    color?: true
    status?: true
    fileUrl?: true
    createdAt?: true
  }

  export type ExportTicketMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    count?: true
    icon?: true
    color?: true
    status?: true
    fileUrl?: true
    createdAt?: true
  }

  export type ExportTicketCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    count?: true
    icon?: true
    color?: true
    status?: true
    fileUrl?: true
    createdAt?: true
    _all?: true
  }

  export type ExportTicketAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExportTicket to aggregate.
     */
    where?: ExportTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExportTickets to fetch.
     */
    orderBy?: ExportTicketOrderByWithRelationInput | ExportTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExportTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExportTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExportTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExportTickets
    **/
    _count?: true | ExportTicketCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExportTicketAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExportTicketSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExportTicketMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExportTicketMaxAggregateInputType
  }

  export type GetExportTicketAggregateType<T extends ExportTicketAggregateArgs> = {
        [P in keyof T & keyof AggregateExportTicket]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExportTicket[P]>
      : GetScalarType<T[P], AggregateExportTicket[P]>
  }




  export type ExportTicketGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExportTicketWhereInput
    orderBy?: ExportTicketOrderByWithAggregationInput | ExportTicketOrderByWithAggregationInput[]
    by: ExportTicketScalarFieldEnum[] | ExportTicketScalarFieldEnum
    having?: ExportTicketScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExportTicketCountAggregateInputType | true
    _avg?: ExportTicketAvgAggregateInputType
    _sum?: ExportTicketSumAggregateInputType
    _min?: ExportTicketMinAggregateInputType
    _max?: ExportTicketMaxAggregateInputType
  }

  export type ExportTicketGroupByOutputType = {
    id: number
    title: string
    description: string
    count: number
    icon: string
    color: string
    status: string
    fileUrl: string | null
    createdAt: Date
    _count: ExportTicketCountAggregateOutputType | null
    _avg: ExportTicketAvgAggregateOutputType | null
    _sum: ExportTicketSumAggregateOutputType | null
    _min: ExportTicketMinAggregateOutputType | null
    _max: ExportTicketMaxAggregateOutputType | null
  }

  type GetExportTicketGroupByPayload<T extends ExportTicketGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExportTicketGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExportTicketGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExportTicketGroupByOutputType[P]>
            : GetScalarType<T[P], ExportTicketGroupByOutputType[P]>
        }
      >
    >


  export type ExportTicketSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    count?: boolean
    icon?: boolean
    color?: boolean
    status?: boolean
    fileUrl?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["exportTicket"]>

  export type ExportTicketSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    count?: boolean
    icon?: boolean
    color?: boolean
    status?: boolean
    fileUrl?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["exportTicket"]>

  export type ExportTicketSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    count?: boolean
    icon?: boolean
    color?: boolean
    status?: boolean
    fileUrl?: boolean
    createdAt?: boolean
  }


  export type $ExportTicketPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExportTicket"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      description: string
      count: number
      icon: string
      color: string
      status: string
      fileUrl: string | null
      createdAt: Date
    }, ExtArgs["result"]["exportTicket"]>
    composites: {}
  }

  type ExportTicketGetPayload<S extends boolean | null | undefined | ExportTicketDefaultArgs> = $Result.GetResult<Prisma.$ExportTicketPayload, S>

  type ExportTicketCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ExportTicketFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExportTicketCountAggregateInputType | true
    }

  export interface ExportTicketDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExportTicket'], meta: { name: 'ExportTicket' } }
    /**
     * Find zero or one ExportTicket that matches the filter.
     * @param {ExportTicketFindUniqueArgs} args - Arguments to find a ExportTicket
     * @example
     * // Get one ExportTicket
     * const exportTicket = await prisma.exportTicket.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExportTicketFindUniqueArgs>(args: SelectSubset<T, ExportTicketFindUniqueArgs<ExtArgs>>): Prisma__ExportTicketClient<$Result.GetResult<Prisma.$ExportTicketPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ExportTicket that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ExportTicketFindUniqueOrThrowArgs} args - Arguments to find a ExportTicket
     * @example
     * // Get one ExportTicket
     * const exportTicket = await prisma.exportTicket.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExportTicketFindUniqueOrThrowArgs>(args: SelectSubset<T, ExportTicketFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExportTicketClient<$Result.GetResult<Prisma.$ExportTicketPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ExportTicket that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExportTicketFindFirstArgs} args - Arguments to find a ExportTicket
     * @example
     * // Get one ExportTicket
     * const exportTicket = await prisma.exportTicket.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExportTicketFindFirstArgs>(args?: SelectSubset<T, ExportTicketFindFirstArgs<ExtArgs>>): Prisma__ExportTicketClient<$Result.GetResult<Prisma.$ExportTicketPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ExportTicket that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExportTicketFindFirstOrThrowArgs} args - Arguments to find a ExportTicket
     * @example
     * // Get one ExportTicket
     * const exportTicket = await prisma.exportTicket.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExportTicketFindFirstOrThrowArgs>(args?: SelectSubset<T, ExportTicketFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExportTicketClient<$Result.GetResult<Prisma.$ExportTicketPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ExportTickets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExportTicketFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExportTickets
     * const exportTickets = await prisma.exportTicket.findMany()
     * 
     * // Get first 10 ExportTickets
     * const exportTickets = await prisma.exportTicket.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const exportTicketWithIdOnly = await prisma.exportTicket.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExportTicketFindManyArgs>(args?: SelectSubset<T, ExportTicketFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExportTicketPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ExportTicket.
     * @param {ExportTicketCreateArgs} args - Arguments to create a ExportTicket.
     * @example
     * // Create one ExportTicket
     * const ExportTicket = await prisma.exportTicket.create({
     *   data: {
     *     // ... data to create a ExportTicket
     *   }
     * })
     * 
     */
    create<T extends ExportTicketCreateArgs>(args: SelectSubset<T, ExportTicketCreateArgs<ExtArgs>>): Prisma__ExportTicketClient<$Result.GetResult<Prisma.$ExportTicketPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ExportTickets.
     * @param {ExportTicketCreateManyArgs} args - Arguments to create many ExportTickets.
     * @example
     * // Create many ExportTickets
     * const exportTicket = await prisma.exportTicket.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExportTicketCreateManyArgs>(args?: SelectSubset<T, ExportTicketCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExportTickets and returns the data saved in the database.
     * @param {ExportTicketCreateManyAndReturnArgs} args - Arguments to create many ExportTickets.
     * @example
     * // Create many ExportTickets
     * const exportTicket = await prisma.exportTicket.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExportTickets and only return the `id`
     * const exportTicketWithIdOnly = await prisma.exportTicket.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExportTicketCreateManyAndReturnArgs>(args?: SelectSubset<T, ExportTicketCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExportTicketPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ExportTicket.
     * @param {ExportTicketDeleteArgs} args - Arguments to delete one ExportTicket.
     * @example
     * // Delete one ExportTicket
     * const ExportTicket = await prisma.exportTicket.delete({
     *   where: {
     *     // ... filter to delete one ExportTicket
     *   }
     * })
     * 
     */
    delete<T extends ExportTicketDeleteArgs>(args: SelectSubset<T, ExportTicketDeleteArgs<ExtArgs>>): Prisma__ExportTicketClient<$Result.GetResult<Prisma.$ExportTicketPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ExportTicket.
     * @param {ExportTicketUpdateArgs} args - Arguments to update one ExportTicket.
     * @example
     * // Update one ExportTicket
     * const exportTicket = await prisma.exportTicket.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExportTicketUpdateArgs>(args: SelectSubset<T, ExportTicketUpdateArgs<ExtArgs>>): Prisma__ExportTicketClient<$Result.GetResult<Prisma.$ExportTicketPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ExportTickets.
     * @param {ExportTicketDeleteManyArgs} args - Arguments to filter ExportTickets to delete.
     * @example
     * // Delete a few ExportTickets
     * const { count } = await prisma.exportTicket.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExportTicketDeleteManyArgs>(args?: SelectSubset<T, ExportTicketDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExportTickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExportTicketUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExportTickets
     * const exportTicket = await prisma.exportTicket.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExportTicketUpdateManyArgs>(args: SelectSubset<T, ExportTicketUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ExportTicket.
     * @param {ExportTicketUpsertArgs} args - Arguments to update or create a ExportTicket.
     * @example
     * // Update or create a ExportTicket
     * const exportTicket = await prisma.exportTicket.upsert({
     *   create: {
     *     // ... data to create a ExportTicket
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExportTicket we want to update
     *   }
     * })
     */
    upsert<T extends ExportTicketUpsertArgs>(args: SelectSubset<T, ExportTicketUpsertArgs<ExtArgs>>): Prisma__ExportTicketClient<$Result.GetResult<Prisma.$ExportTicketPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ExportTickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExportTicketCountArgs} args - Arguments to filter ExportTickets to count.
     * @example
     * // Count the number of ExportTickets
     * const count = await prisma.exportTicket.count({
     *   where: {
     *     // ... the filter for the ExportTickets we want to count
     *   }
     * })
    **/
    count<T extends ExportTicketCountArgs>(
      args?: Subset<T, ExportTicketCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExportTicketCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExportTicket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExportTicketAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExportTicketAggregateArgs>(args: Subset<T, ExportTicketAggregateArgs>): Prisma.PrismaPromise<GetExportTicketAggregateType<T>>

    /**
     * Group by ExportTicket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExportTicketGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExportTicketGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExportTicketGroupByArgs['orderBy'] }
        : { orderBy?: ExportTicketGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExportTicketGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExportTicketGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExportTicket model
   */
  readonly fields: ExportTicketFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExportTicket.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExportTicketClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExportTicket model
   */ 
  interface ExportTicketFieldRefs {
    readonly id: FieldRef<"ExportTicket", 'Int'>
    readonly title: FieldRef<"ExportTicket", 'String'>
    readonly description: FieldRef<"ExportTicket", 'String'>
    readonly count: FieldRef<"ExportTicket", 'Int'>
    readonly icon: FieldRef<"ExportTicket", 'String'>
    readonly color: FieldRef<"ExportTicket", 'String'>
    readonly status: FieldRef<"ExportTicket", 'String'>
    readonly fileUrl: FieldRef<"ExportTicket", 'String'>
    readonly createdAt: FieldRef<"ExportTicket", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExportTicket findUnique
   */
  export type ExportTicketFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportTicket
     */
    select?: ExportTicketSelect<ExtArgs> | null
    /**
     * Filter, which ExportTicket to fetch.
     */
    where: ExportTicketWhereUniqueInput
  }

  /**
   * ExportTicket findUniqueOrThrow
   */
  export type ExportTicketFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportTicket
     */
    select?: ExportTicketSelect<ExtArgs> | null
    /**
     * Filter, which ExportTicket to fetch.
     */
    where: ExportTicketWhereUniqueInput
  }

  /**
   * ExportTicket findFirst
   */
  export type ExportTicketFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportTicket
     */
    select?: ExportTicketSelect<ExtArgs> | null
    /**
     * Filter, which ExportTicket to fetch.
     */
    where?: ExportTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExportTickets to fetch.
     */
    orderBy?: ExportTicketOrderByWithRelationInput | ExportTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExportTickets.
     */
    cursor?: ExportTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExportTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExportTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExportTickets.
     */
    distinct?: ExportTicketScalarFieldEnum | ExportTicketScalarFieldEnum[]
  }

  /**
   * ExportTicket findFirstOrThrow
   */
  export type ExportTicketFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportTicket
     */
    select?: ExportTicketSelect<ExtArgs> | null
    /**
     * Filter, which ExportTicket to fetch.
     */
    where?: ExportTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExportTickets to fetch.
     */
    orderBy?: ExportTicketOrderByWithRelationInput | ExportTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExportTickets.
     */
    cursor?: ExportTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExportTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExportTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExportTickets.
     */
    distinct?: ExportTicketScalarFieldEnum | ExportTicketScalarFieldEnum[]
  }

  /**
   * ExportTicket findMany
   */
  export type ExportTicketFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportTicket
     */
    select?: ExportTicketSelect<ExtArgs> | null
    /**
     * Filter, which ExportTickets to fetch.
     */
    where?: ExportTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExportTickets to fetch.
     */
    orderBy?: ExportTicketOrderByWithRelationInput | ExportTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExportTickets.
     */
    cursor?: ExportTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExportTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExportTickets.
     */
    skip?: number
    distinct?: ExportTicketScalarFieldEnum | ExportTicketScalarFieldEnum[]
  }

  /**
   * ExportTicket create
   */
  export type ExportTicketCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportTicket
     */
    select?: ExportTicketSelect<ExtArgs> | null
    /**
     * The data needed to create a ExportTicket.
     */
    data: XOR<ExportTicketCreateInput, ExportTicketUncheckedCreateInput>
  }

  /**
   * ExportTicket createMany
   */
  export type ExportTicketCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExportTickets.
     */
    data: ExportTicketCreateManyInput | ExportTicketCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExportTicket createManyAndReturn
   */
  export type ExportTicketCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportTicket
     */
    select?: ExportTicketSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ExportTickets.
     */
    data: ExportTicketCreateManyInput | ExportTicketCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExportTicket update
   */
  export type ExportTicketUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportTicket
     */
    select?: ExportTicketSelect<ExtArgs> | null
    /**
     * The data needed to update a ExportTicket.
     */
    data: XOR<ExportTicketUpdateInput, ExportTicketUncheckedUpdateInput>
    /**
     * Choose, which ExportTicket to update.
     */
    where: ExportTicketWhereUniqueInput
  }

  /**
   * ExportTicket updateMany
   */
  export type ExportTicketUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExportTickets.
     */
    data: XOR<ExportTicketUpdateManyMutationInput, ExportTicketUncheckedUpdateManyInput>
    /**
     * Filter which ExportTickets to update
     */
    where?: ExportTicketWhereInput
  }

  /**
   * ExportTicket upsert
   */
  export type ExportTicketUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportTicket
     */
    select?: ExportTicketSelect<ExtArgs> | null
    /**
     * The filter to search for the ExportTicket to update in case it exists.
     */
    where: ExportTicketWhereUniqueInput
    /**
     * In case the ExportTicket found by the `where` argument doesn't exist, create a new ExportTicket with this data.
     */
    create: XOR<ExportTicketCreateInput, ExportTicketUncheckedCreateInput>
    /**
     * In case the ExportTicket was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExportTicketUpdateInput, ExportTicketUncheckedUpdateInput>
  }

  /**
   * ExportTicket delete
   */
  export type ExportTicketDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportTicket
     */
    select?: ExportTicketSelect<ExtArgs> | null
    /**
     * Filter which ExportTicket to delete.
     */
    where: ExportTicketWhereUniqueInput
  }

  /**
   * ExportTicket deleteMany
   */
  export type ExportTicketDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExportTickets to delete
     */
    where?: ExportTicketWhereInput
  }

  /**
   * ExportTicket without action
   */
  export type ExportTicketDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportTicket
     */
    select?: ExportTicketSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const SystemOverviewScalarFieldEnum: {
    id: 'id',
    totalRevenue: 'totalRevenue',
    revenueTrend: 'revenueTrend',
    totalOrders: 'totalOrders',
    ordersTrend: 'ordersTrend',
    totalUsers: 'totalUsers',
    usersTrend: 'usersTrend',
    totalPartners: 'totalPartners',
    partnersTrend: 'partnersTrend',
    updatedAt: 'updatedAt'
  };

  export type SystemOverviewScalarFieldEnum = (typeof SystemOverviewScalarFieldEnum)[keyof typeof SystemOverviewScalarFieldEnum]


  export const EducationKPIScalarFieldEnum: {
    id: 'id',
    totalEnrolled: 'totalEnrolled',
    expectedEnrolled: 'expectedEnrolled',
    enrollmentRate: 'enrollmentRate',
    started: 'started',
    completed: 'completed',
    startedRate: 'startedRate',
    completedRate: 'completedRate',
    totalNotifications: 'totalNotifications',
    usageFrequency: 'usageFrequency',
    avgCourseDuration: 'avgCourseDuration',
    updatedAt: 'updatedAt'
  };

  export type EducationKPIScalarFieldEnum = (typeof EducationKPIScalarFieldEnum)[keyof typeof EducationKPIScalarFieldEnum]


  export const LearningProgressScalarFieldEnum: {
    id: 'id',
    watched70Lesson: 'watched70Lesson',
    watched70All: 'watched70All',
    totalLearners: 'totalLearners',
    preTestTotal: 'preTestTotal',
    preTestPassed: 'preTestPassed',
    postTestTotal: 'postTestTotal',
    postTestPassed: 'postTestPassed',
    updatedAt: 'updatedAt'
  };

  export type LearningProgressScalarFieldEnum = (typeof LearningProgressScalarFieldEnum)[keyof typeof LearningProgressScalarFieldEnum]


  export const RevenueReportScalarFieldEnum: {
    id: 'id',
    month: 'month',
    revenue: 'revenue',
    orders: 'orders',
    avgOrderValue: 'avgOrderValue',
    growth: 'growth',
    createdAt: 'createdAt'
  };

  export type RevenueReportScalarFieldEnum = (typeof RevenueReportScalarFieldEnum)[keyof typeof RevenueReportScalarFieldEnum]


  export const UserAnalyticsScalarFieldEnum: {
    id: 'id',
    totalUsers: 'totalUsers',
    activeUsers: 'activeUsers',
    activityRate: 'activityRate',
    multipleSessionUsers: 'multipleSessionUsers',
    updatedAt: 'updatedAt'
  };

  export type UserAnalyticsScalarFieldEnum = (typeof UserAnalyticsScalarFieldEnum)[keyof typeof UserAnalyticsScalarFieldEnum]


  export const ExportTicketScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    count: 'count',
    icon: 'icon',
    color: 'color',
    status: 'status',
    fileUrl: 'fileUrl',
    createdAt: 'createdAt'
  };

  export type ExportTicketScalarFieldEnum = (typeof ExportTicketScalarFieldEnum)[keyof typeof ExportTicketScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    
  /**
   * Deep Input Types
   */


  export type SystemOverviewWhereInput = {
    AND?: SystemOverviewWhereInput | SystemOverviewWhereInput[]
    OR?: SystemOverviewWhereInput[]
    NOT?: SystemOverviewWhereInput | SystemOverviewWhereInput[]
    id?: IntFilter<"SystemOverview"> | number
    totalRevenue?: FloatFilter<"SystemOverview"> | number
    revenueTrend?: StringFilter<"SystemOverview"> | string
    totalOrders?: IntFilter<"SystemOverview"> | number
    ordersTrend?: StringFilter<"SystemOverview"> | string
    totalUsers?: IntFilter<"SystemOverview"> | number
    usersTrend?: StringFilter<"SystemOverview"> | string
    totalPartners?: IntFilter<"SystemOverview"> | number
    partnersTrend?: StringFilter<"SystemOverview"> | string
    updatedAt?: DateTimeFilter<"SystemOverview"> | Date | string
  }

  export type SystemOverviewOrderByWithRelationInput = {
    id?: SortOrder
    totalRevenue?: SortOrder
    revenueTrend?: SortOrder
    totalOrders?: SortOrder
    ordersTrend?: SortOrder
    totalUsers?: SortOrder
    usersTrend?: SortOrder
    totalPartners?: SortOrder
    partnersTrend?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemOverviewWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SystemOverviewWhereInput | SystemOverviewWhereInput[]
    OR?: SystemOverviewWhereInput[]
    NOT?: SystemOverviewWhereInput | SystemOverviewWhereInput[]
    totalRevenue?: FloatFilter<"SystemOverview"> | number
    revenueTrend?: StringFilter<"SystemOverview"> | string
    totalOrders?: IntFilter<"SystemOverview"> | number
    ordersTrend?: StringFilter<"SystemOverview"> | string
    totalUsers?: IntFilter<"SystemOverview"> | number
    usersTrend?: StringFilter<"SystemOverview"> | string
    totalPartners?: IntFilter<"SystemOverview"> | number
    partnersTrend?: StringFilter<"SystemOverview"> | string
    updatedAt?: DateTimeFilter<"SystemOverview"> | Date | string
  }, "id">

  export type SystemOverviewOrderByWithAggregationInput = {
    id?: SortOrder
    totalRevenue?: SortOrder
    revenueTrend?: SortOrder
    totalOrders?: SortOrder
    ordersTrend?: SortOrder
    totalUsers?: SortOrder
    usersTrend?: SortOrder
    totalPartners?: SortOrder
    partnersTrend?: SortOrder
    updatedAt?: SortOrder
    _count?: SystemOverviewCountOrderByAggregateInput
    _avg?: SystemOverviewAvgOrderByAggregateInput
    _max?: SystemOverviewMaxOrderByAggregateInput
    _min?: SystemOverviewMinOrderByAggregateInput
    _sum?: SystemOverviewSumOrderByAggregateInput
  }

  export type SystemOverviewScalarWhereWithAggregatesInput = {
    AND?: SystemOverviewScalarWhereWithAggregatesInput | SystemOverviewScalarWhereWithAggregatesInput[]
    OR?: SystemOverviewScalarWhereWithAggregatesInput[]
    NOT?: SystemOverviewScalarWhereWithAggregatesInput | SystemOverviewScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SystemOverview"> | number
    totalRevenue?: FloatWithAggregatesFilter<"SystemOverview"> | number
    revenueTrend?: StringWithAggregatesFilter<"SystemOverview"> | string
    totalOrders?: IntWithAggregatesFilter<"SystemOverview"> | number
    ordersTrend?: StringWithAggregatesFilter<"SystemOverview"> | string
    totalUsers?: IntWithAggregatesFilter<"SystemOverview"> | number
    usersTrend?: StringWithAggregatesFilter<"SystemOverview"> | string
    totalPartners?: IntWithAggregatesFilter<"SystemOverview"> | number
    partnersTrend?: StringWithAggregatesFilter<"SystemOverview"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"SystemOverview"> | Date | string
  }

  export type EducationKPIWhereInput = {
    AND?: EducationKPIWhereInput | EducationKPIWhereInput[]
    OR?: EducationKPIWhereInput[]
    NOT?: EducationKPIWhereInput | EducationKPIWhereInput[]
    id?: IntFilter<"EducationKPI"> | number
    totalEnrolled?: IntFilter<"EducationKPI"> | number
    expectedEnrolled?: IntFilter<"EducationKPI"> | number
    enrollmentRate?: FloatFilter<"EducationKPI"> | number
    started?: IntFilter<"EducationKPI"> | number
    completed?: IntFilter<"EducationKPI"> | number
    startedRate?: FloatFilter<"EducationKPI"> | number
    completedRate?: FloatFilter<"EducationKPI"> | number
    totalNotifications?: IntFilter<"EducationKPI"> | number
    usageFrequency?: FloatFilter<"EducationKPI"> | number
    avgCourseDuration?: StringFilter<"EducationKPI"> | string
    updatedAt?: DateTimeFilter<"EducationKPI"> | Date | string
  }

  export type EducationKPIOrderByWithRelationInput = {
    id?: SortOrder
    totalEnrolled?: SortOrder
    expectedEnrolled?: SortOrder
    enrollmentRate?: SortOrder
    started?: SortOrder
    completed?: SortOrder
    startedRate?: SortOrder
    completedRate?: SortOrder
    totalNotifications?: SortOrder
    usageFrequency?: SortOrder
    avgCourseDuration?: SortOrder
    updatedAt?: SortOrder
  }

  export type EducationKPIWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EducationKPIWhereInput | EducationKPIWhereInput[]
    OR?: EducationKPIWhereInput[]
    NOT?: EducationKPIWhereInput | EducationKPIWhereInput[]
    totalEnrolled?: IntFilter<"EducationKPI"> | number
    expectedEnrolled?: IntFilter<"EducationKPI"> | number
    enrollmentRate?: FloatFilter<"EducationKPI"> | number
    started?: IntFilter<"EducationKPI"> | number
    completed?: IntFilter<"EducationKPI"> | number
    startedRate?: FloatFilter<"EducationKPI"> | number
    completedRate?: FloatFilter<"EducationKPI"> | number
    totalNotifications?: IntFilter<"EducationKPI"> | number
    usageFrequency?: FloatFilter<"EducationKPI"> | number
    avgCourseDuration?: StringFilter<"EducationKPI"> | string
    updatedAt?: DateTimeFilter<"EducationKPI"> | Date | string
  }, "id">

  export type EducationKPIOrderByWithAggregationInput = {
    id?: SortOrder
    totalEnrolled?: SortOrder
    expectedEnrolled?: SortOrder
    enrollmentRate?: SortOrder
    started?: SortOrder
    completed?: SortOrder
    startedRate?: SortOrder
    completedRate?: SortOrder
    totalNotifications?: SortOrder
    usageFrequency?: SortOrder
    avgCourseDuration?: SortOrder
    updatedAt?: SortOrder
    _count?: EducationKPICountOrderByAggregateInput
    _avg?: EducationKPIAvgOrderByAggregateInput
    _max?: EducationKPIMaxOrderByAggregateInput
    _min?: EducationKPIMinOrderByAggregateInput
    _sum?: EducationKPISumOrderByAggregateInput
  }

  export type EducationKPIScalarWhereWithAggregatesInput = {
    AND?: EducationKPIScalarWhereWithAggregatesInput | EducationKPIScalarWhereWithAggregatesInput[]
    OR?: EducationKPIScalarWhereWithAggregatesInput[]
    NOT?: EducationKPIScalarWhereWithAggregatesInput | EducationKPIScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EducationKPI"> | number
    totalEnrolled?: IntWithAggregatesFilter<"EducationKPI"> | number
    expectedEnrolled?: IntWithAggregatesFilter<"EducationKPI"> | number
    enrollmentRate?: FloatWithAggregatesFilter<"EducationKPI"> | number
    started?: IntWithAggregatesFilter<"EducationKPI"> | number
    completed?: IntWithAggregatesFilter<"EducationKPI"> | number
    startedRate?: FloatWithAggregatesFilter<"EducationKPI"> | number
    completedRate?: FloatWithAggregatesFilter<"EducationKPI"> | number
    totalNotifications?: IntWithAggregatesFilter<"EducationKPI"> | number
    usageFrequency?: FloatWithAggregatesFilter<"EducationKPI"> | number
    avgCourseDuration?: StringWithAggregatesFilter<"EducationKPI"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"EducationKPI"> | Date | string
  }

  export type LearningProgressWhereInput = {
    AND?: LearningProgressWhereInput | LearningProgressWhereInput[]
    OR?: LearningProgressWhereInput[]
    NOT?: LearningProgressWhereInput | LearningProgressWhereInput[]
    id?: IntFilter<"LearningProgress"> | number
    watched70Lesson?: IntFilter<"LearningProgress"> | number
    watched70All?: IntFilter<"LearningProgress"> | number
    totalLearners?: IntFilter<"LearningProgress"> | number
    preTestTotal?: IntFilter<"LearningProgress"> | number
    preTestPassed?: IntFilter<"LearningProgress"> | number
    postTestTotal?: IntFilter<"LearningProgress"> | number
    postTestPassed?: IntFilter<"LearningProgress"> | number
    updatedAt?: DateTimeFilter<"LearningProgress"> | Date | string
  }

  export type LearningProgressOrderByWithRelationInput = {
    id?: SortOrder
    watched70Lesson?: SortOrder
    watched70All?: SortOrder
    totalLearners?: SortOrder
    preTestTotal?: SortOrder
    preTestPassed?: SortOrder
    postTestTotal?: SortOrder
    postTestPassed?: SortOrder
    updatedAt?: SortOrder
  }

  export type LearningProgressWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LearningProgressWhereInput | LearningProgressWhereInput[]
    OR?: LearningProgressWhereInput[]
    NOT?: LearningProgressWhereInput | LearningProgressWhereInput[]
    watched70Lesson?: IntFilter<"LearningProgress"> | number
    watched70All?: IntFilter<"LearningProgress"> | number
    totalLearners?: IntFilter<"LearningProgress"> | number
    preTestTotal?: IntFilter<"LearningProgress"> | number
    preTestPassed?: IntFilter<"LearningProgress"> | number
    postTestTotal?: IntFilter<"LearningProgress"> | number
    postTestPassed?: IntFilter<"LearningProgress"> | number
    updatedAt?: DateTimeFilter<"LearningProgress"> | Date | string
  }, "id">

  export type LearningProgressOrderByWithAggregationInput = {
    id?: SortOrder
    watched70Lesson?: SortOrder
    watched70All?: SortOrder
    totalLearners?: SortOrder
    preTestTotal?: SortOrder
    preTestPassed?: SortOrder
    postTestTotal?: SortOrder
    postTestPassed?: SortOrder
    updatedAt?: SortOrder
    _count?: LearningProgressCountOrderByAggregateInput
    _avg?: LearningProgressAvgOrderByAggregateInput
    _max?: LearningProgressMaxOrderByAggregateInput
    _min?: LearningProgressMinOrderByAggregateInput
    _sum?: LearningProgressSumOrderByAggregateInput
  }

  export type LearningProgressScalarWhereWithAggregatesInput = {
    AND?: LearningProgressScalarWhereWithAggregatesInput | LearningProgressScalarWhereWithAggregatesInput[]
    OR?: LearningProgressScalarWhereWithAggregatesInput[]
    NOT?: LearningProgressScalarWhereWithAggregatesInput | LearningProgressScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LearningProgress"> | number
    watched70Lesson?: IntWithAggregatesFilter<"LearningProgress"> | number
    watched70All?: IntWithAggregatesFilter<"LearningProgress"> | number
    totalLearners?: IntWithAggregatesFilter<"LearningProgress"> | number
    preTestTotal?: IntWithAggregatesFilter<"LearningProgress"> | number
    preTestPassed?: IntWithAggregatesFilter<"LearningProgress"> | number
    postTestTotal?: IntWithAggregatesFilter<"LearningProgress"> | number
    postTestPassed?: IntWithAggregatesFilter<"LearningProgress"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"LearningProgress"> | Date | string
  }

  export type RevenueReportWhereInput = {
    AND?: RevenueReportWhereInput | RevenueReportWhereInput[]
    OR?: RevenueReportWhereInput[]
    NOT?: RevenueReportWhereInput | RevenueReportWhereInput[]
    id?: IntFilter<"RevenueReport"> | number
    month?: StringFilter<"RevenueReport"> | string
    revenue?: FloatFilter<"RevenueReport"> | number
    orders?: IntFilter<"RevenueReport"> | number
    avgOrderValue?: FloatFilter<"RevenueReport"> | number
    growth?: FloatFilter<"RevenueReport"> | number
    createdAt?: DateTimeFilter<"RevenueReport"> | Date | string
  }

  export type RevenueReportOrderByWithRelationInput = {
    id?: SortOrder
    month?: SortOrder
    revenue?: SortOrder
    orders?: SortOrder
    avgOrderValue?: SortOrder
    growth?: SortOrder
    createdAt?: SortOrder
  }

  export type RevenueReportWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RevenueReportWhereInput | RevenueReportWhereInput[]
    OR?: RevenueReportWhereInput[]
    NOT?: RevenueReportWhereInput | RevenueReportWhereInput[]
    month?: StringFilter<"RevenueReport"> | string
    revenue?: FloatFilter<"RevenueReport"> | number
    orders?: IntFilter<"RevenueReport"> | number
    avgOrderValue?: FloatFilter<"RevenueReport"> | number
    growth?: FloatFilter<"RevenueReport"> | number
    createdAt?: DateTimeFilter<"RevenueReport"> | Date | string
  }, "id">

  export type RevenueReportOrderByWithAggregationInput = {
    id?: SortOrder
    month?: SortOrder
    revenue?: SortOrder
    orders?: SortOrder
    avgOrderValue?: SortOrder
    growth?: SortOrder
    createdAt?: SortOrder
    _count?: RevenueReportCountOrderByAggregateInput
    _avg?: RevenueReportAvgOrderByAggregateInput
    _max?: RevenueReportMaxOrderByAggregateInput
    _min?: RevenueReportMinOrderByAggregateInput
    _sum?: RevenueReportSumOrderByAggregateInput
  }

  export type RevenueReportScalarWhereWithAggregatesInput = {
    AND?: RevenueReportScalarWhereWithAggregatesInput | RevenueReportScalarWhereWithAggregatesInput[]
    OR?: RevenueReportScalarWhereWithAggregatesInput[]
    NOT?: RevenueReportScalarWhereWithAggregatesInput | RevenueReportScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RevenueReport"> | number
    month?: StringWithAggregatesFilter<"RevenueReport"> | string
    revenue?: FloatWithAggregatesFilter<"RevenueReport"> | number
    orders?: IntWithAggregatesFilter<"RevenueReport"> | number
    avgOrderValue?: FloatWithAggregatesFilter<"RevenueReport"> | number
    growth?: FloatWithAggregatesFilter<"RevenueReport"> | number
    createdAt?: DateTimeWithAggregatesFilter<"RevenueReport"> | Date | string
  }

  export type UserAnalyticsWhereInput = {
    AND?: UserAnalyticsWhereInput | UserAnalyticsWhereInput[]
    OR?: UserAnalyticsWhereInput[]
    NOT?: UserAnalyticsWhereInput | UserAnalyticsWhereInput[]
    id?: IntFilter<"UserAnalytics"> | number
    totalUsers?: IntFilter<"UserAnalytics"> | number
    activeUsers?: IntFilter<"UserAnalytics"> | number
    activityRate?: FloatFilter<"UserAnalytics"> | number
    multipleSessionUsers?: IntFilter<"UserAnalytics"> | number
    updatedAt?: DateTimeFilter<"UserAnalytics"> | Date | string
  }

  export type UserAnalyticsOrderByWithRelationInput = {
    id?: SortOrder
    totalUsers?: SortOrder
    activeUsers?: SortOrder
    activityRate?: SortOrder
    multipleSessionUsers?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAnalyticsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UserAnalyticsWhereInput | UserAnalyticsWhereInput[]
    OR?: UserAnalyticsWhereInput[]
    NOT?: UserAnalyticsWhereInput | UserAnalyticsWhereInput[]
    totalUsers?: IntFilter<"UserAnalytics"> | number
    activeUsers?: IntFilter<"UserAnalytics"> | number
    activityRate?: FloatFilter<"UserAnalytics"> | number
    multipleSessionUsers?: IntFilter<"UserAnalytics"> | number
    updatedAt?: DateTimeFilter<"UserAnalytics"> | Date | string
  }, "id">

  export type UserAnalyticsOrderByWithAggregationInput = {
    id?: SortOrder
    totalUsers?: SortOrder
    activeUsers?: SortOrder
    activityRate?: SortOrder
    multipleSessionUsers?: SortOrder
    updatedAt?: SortOrder
    _count?: UserAnalyticsCountOrderByAggregateInput
    _avg?: UserAnalyticsAvgOrderByAggregateInput
    _max?: UserAnalyticsMaxOrderByAggregateInput
    _min?: UserAnalyticsMinOrderByAggregateInput
    _sum?: UserAnalyticsSumOrderByAggregateInput
  }

  export type UserAnalyticsScalarWhereWithAggregatesInput = {
    AND?: UserAnalyticsScalarWhereWithAggregatesInput | UserAnalyticsScalarWhereWithAggregatesInput[]
    OR?: UserAnalyticsScalarWhereWithAggregatesInput[]
    NOT?: UserAnalyticsScalarWhereWithAggregatesInput | UserAnalyticsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserAnalytics"> | number
    totalUsers?: IntWithAggregatesFilter<"UserAnalytics"> | number
    activeUsers?: IntWithAggregatesFilter<"UserAnalytics"> | number
    activityRate?: FloatWithAggregatesFilter<"UserAnalytics"> | number
    multipleSessionUsers?: IntWithAggregatesFilter<"UserAnalytics"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"UserAnalytics"> | Date | string
  }

  export type ExportTicketWhereInput = {
    AND?: ExportTicketWhereInput | ExportTicketWhereInput[]
    OR?: ExportTicketWhereInput[]
    NOT?: ExportTicketWhereInput | ExportTicketWhereInput[]
    id?: IntFilter<"ExportTicket"> | number
    title?: StringFilter<"ExportTicket"> | string
    description?: StringFilter<"ExportTicket"> | string
    count?: IntFilter<"ExportTicket"> | number
    icon?: StringFilter<"ExportTicket"> | string
    color?: StringFilter<"ExportTicket"> | string
    status?: StringFilter<"ExportTicket"> | string
    fileUrl?: StringNullableFilter<"ExportTicket"> | string | null
    createdAt?: DateTimeFilter<"ExportTicket"> | Date | string
  }

  export type ExportTicketOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    count?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    status?: SortOrder
    fileUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type ExportTicketWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ExportTicketWhereInput | ExportTicketWhereInput[]
    OR?: ExportTicketWhereInput[]
    NOT?: ExportTicketWhereInput | ExportTicketWhereInput[]
    title?: StringFilter<"ExportTicket"> | string
    description?: StringFilter<"ExportTicket"> | string
    count?: IntFilter<"ExportTicket"> | number
    icon?: StringFilter<"ExportTicket"> | string
    color?: StringFilter<"ExportTicket"> | string
    status?: StringFilter<"ExportTicket"> | string
    fileUrl?: StringNullableFilter<"ExportTicket"> | string | null
    createdAt?: DateTimeFilter<"ExportTicket"> | Date | string
  }, "id">

  export type ExportTicketOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    count?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    status?: SortOrder
    fileUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ExportTicketCountOrderByAggregateInput
    _avg?: ExportTicketAvgOrderByAggregateInput
    _max?: ExportTicketMaxOrderByAggregateInput
    _min?: ExportTicketMinOrderByAggregateInput
    _sum?: ExportTicketSumOrderByAggregateInput
  }

  export type ExportTicketScalarWhereWithAggregatesInput = {
    AND?: ExportTicketScalarWhereWithAggregatesInput | ExportTicketScalarWhereWithAggregatesInput[]
    OR?: ExportTicketScalarWhereWithAggregatesInput[]
    NOT?: ExportTicketScalarWhereWithAggregatesInput | ExportTicketScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ExportTicket"> | number
    title?: StringWithAggregatesFilter<"ExportTicket"> | string
    description?: StringWithAggregatesFilter<"ExportTicket"> | string
    count?: IntWithAggregatesFilter<"ExportTicket"> | number
    icon?: StringWithAggregatesFilter<"ExportTicket"> | string
    color?: StringWithAggregatesFilter<"ExportTicket"> | string
    status?: StringWithAggregatesFilter<"ExportTicket"> | string
    fileUrl?: StringNullableWithAggregatesFilter<"ExportTicket"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ExportTicket"> | Date | string
  }

  export type SystemOverviewCreateInput = {
    totalRevenue: number
    revenueTrend: string
    totalOrders: number
    ordersTrend: string
    totalUsers: number
    usersTrend: string
    totalPartners: number
    partnersTrend: string
    updatedAt?: Date | string
  }

  export type SystemOverviewUncheckedCreateInput = {
    id?: number
    totalRevenue: number
    revenueTrend: string
    totalOrders: number
    ordersTrend: string
    totalUsers: number
    usersTrend: string
    totalPartners: number
    partnersTrend: string
    updatedAt?: Date | string
  }

  export type SystemOverviewUpdateInput = {
    totalRevenue?: FloatFieldUpdateOperationsInput | number
    revenueTrend?: StringFieldUpdateOperationsInput | string
    totalOrders?: IntFieldUpdateOperationsInput | number
    ordersTrend?: StringFieldUpdateOperationsInput | string
    totalUsers?: IntFieldUpdateOperationsInput | number
    usersTrend?: StringFieldUpdateOperationsInput | string
    totalPartners?: IntFieldUpdateOperationsInput | number
    partnersTrend?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemOverviewUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalRevenue?: FloatFieldUpdateOperationsInput | number
    revenueTrend?: StringFieldUpdateOperationsInput | string
    totalOrders?: IntFieldUpdateOperationsInput | number
    ordersTrend?: StringFieldUpdateOperationsInput | string
    totalUsers?: IntFieldUpdateOperationsInput | number
    usersTrend?: StringFieldUpdateOperationsInput | string
    totalPartners?: IntFieldUpdateOperationsInput | number
    partnersTrend?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemOverviewCreateManyInput = {
    id?: number
    totalRevenue: number
    revenueTrend: string
    totalOrders: number
    ordersTrend: string
    totalUsers: number
    usersTrend: string
    totalPartners: number
    partnersTrend: string
    updatedAt?: Date | string
  }

  export type SystemOverviewUpdateManyMutationInput = {
    totalRevenue?: FloatFieldUpdateOperationsInput | number
    revenueTrend?: StringFieldUpdateOperationsInput | string
    totalOrders?: IntFieldUpdateOperationsInput | number
    ordersTrend?: StringFieldUpdateOperationsInput | string
    totalUsers?: IntFieldUpdateOperationsInput | number
    usersTrend?: StringFieldUpdateOperationsInput | string
    totalPartners?: IntFieldUpdateOperationsInput | number
    partnersTrend?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemOverviewUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalRevenue?: FloatFieldUpdateOperationsInput | number
    revenueTrend?: StringFieldUpdateOperationsInput | string
    totalOrders?: IntFieldUpdateOperationsInput | number
    ordersTrend?: StringFieldUpdateOperationsInput | string
    totalUsers?: IntFieldUpdateOperationsInput | number
    usersTrend?: StringFieldUpdateOperationsInput | string
    totalPartners?: IntFieldUpdateOperationsInput | number
    partnersTrend?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EducationKPICreateInput = {
    totalEnrolled: number
    expectedEnrolled: number
    enrollmentRate: number
    started: number
    completed: number
    startedRate: number
    completedRate: number
    totalNotifications: number
    usageFrequency: number
    avgCourseDuration: string
    updatedAt?: Date | string
  }

  export type EducationKPIUncheckedCreateInput = {
    id?: number
    totalEnrolled: number
    expectedEnrolled: number
    enrollmentRate: number
    started: number
    completed: number
    startedRate: number
    completedRate: number
    totalNotifications: number
    usageFrequency: number
    avgCourseDuration: string
    updatedAt?: Date | string
  }

  export type EducationKPIUpdateInput = {
    totalEnrolled?: IntFieldUpdateOperationsInput | number
    expectedEnrolled?: IntFieldUpdateOperationsInput | number
    enrollmentRate?: FloatFieldUpdateOperationsInput | number
    started?: IntFieldUpdateOperationsInput | number
    completed?: IntFieldUpdateOperationsInput | number
    startedRate?: FloatFieldUpdateOperationsInput | number
    completedRate?: FloatFieldUpdateOperationsInput | number
    totalNotifications?: IntFieldUpdateOperationsInput | number
    usageFrequency?: FloatFieldUpdateOperationsInput | number
    avgCourseDuration?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EducationKPIUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalEnrolled?: IntFieldUpdateOperationsInput | number
    expectedEnrolled?: IntFieldUpdateOperationsInput | number
    enrollmentRate?: FloatFieldUpdateOperationsInput | number
    started?: IntFieldUpdateOperationsInput | number
    completed?: IntFieldUpdateOperationsInput | number
    startedRate?: FloatFieldUpdateOperationsInput | number
    completedRate?: FloatFieldUpdateOperationsInput | number
    totalNotifications?: IntFieldUpdateOperationsInput | number
    usageFrequency?: FloatFieldUpdateOperationsInput | number
    avgCourseDuration?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EducationKPICreateManyInput = {
    id?: number
    totalEnrolled: number
    expectedEnrolled: number
    enrollmentRate: number
    started: number
    completed: number
    startedRate: number
    completedRate: number
    totalNotifications: number
    usageFrequency: number
    avgCourseDuration: string
    updatedAt?: Date | string
  }

  export type EducationKPIUpdateManyMutationInput = {
    totalEnrolled?: IntFieldUpdateOperationsInput | number
    expectedEnrolled?: IntFieldUpdateOperationsInput | number
    enrollmentRate?: FloatFieldUpdateOperationsInput | number
    started?: IntFieldUpdateOperationsInput | number
    completed?: IntFieldUpdateOperationsInput | number
    startedRate?: FloatFieldUpdateOperationsInput | number
    completedRate?: FloatFieldUpdateOperationsInput | number
    totalNotifications?: IntFieldUpdateOperationsInput | number
    usageFrequency?: FloatFieldUpdateOperationsInput | number
    avgCourseDuration?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EducationKPIUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalEnrolled?: IntFieldUpdateOperationsInput | number
    expectedEnrolled?: IntFieldUpdateOperationsInput | number
    enrollmentRate?: FloatFieldUpdateOperationsInput | number
    started?: IntFieldUpdateOperationsInput | number
    completed?: IntFieldUpdateOperationsInput | number
    startedRate?: FloatFieldUpdateOperationsInput | number
    completedRate?: FloatFieldUpdateOperationsInput | number
    totalNotifications?: IntFieldUpdateOperationsInput | number
    usageFrequency?: FloatFieldUpdateOperationsInput | number
    avgCourseDuration?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LearningProgressCreateInput = {
    watched70Lesson: number
    watched70All: number
    totalLearners: number
    preTestTotal: number
    preTestPassed: number
    postTestTotal: number
    postTestPassed: number
    updatedAt?: Date | string
  }

  export type LearningProgressUncheckedCreateInput = {
    id?: number
    watched70Lesson: number
    watched70All: number
    totalLearners: number
    preTestTotal: number
    preTestPassed: number
    postTestTotal: number
    postTestPassed: number
    updatedAt?: Date | string
  }

  export type LearningProgressUpdateInput = {
    watched70Lesson?: IntFieldUpdateOperationsInput | number
    watched70All?: IntFieldUpdateOperationsInput | number
    totalLearners?: IntFieldUpdateOperationsInput | number
    preTestTotal?: IntFieldUpdateOperationsInput | number
    preTestPassed?: IntFieldUpdateOperationsInput | number
    postTestTotal?: IntFieldUpdateOperationsInput | number
    postTestPassed?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LearningProgressUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    watched70Lesson?: IntFieldUpdateOperationsInput | number
    watched70All?: IntFieldUpdateOperationsInput | number
    totalLearners?: IntFieldUpdateOperationsInput | number
    preTestTotal?: IntFieldUpdateOperationsInput | number
    preTestPassed?: IntFieldUpdateOperationsInput | number
    postTestTotal?: IntFieldUpdateOperationsInput | number
    postTestPassed?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LearningProgressCreateManyInput = {
    id?: number
    watched70Lesson: number
    watched70All: number
    totalLearners: number
    preTestTotal: number
    preTestPassed: number
    postTestTotal: number
    postTestPassed: number
    updatedAt?: Date | string
  }

  export type LearningProgressUpdateManyMutationInput = {
    watched70Lesson?: IntFieldUpdateOperationsInput | number
    watched70All?: IntFieldUpdateOperationsInput | number
    totalLearners?: IntFieldUpdateOperationsInput | number
    preTestTotal?: IntFieldUpdateOperationsInput | number
    preTestPassed?: IntFieldUpdateOperationsInput | number
    postTestTotal?: IntFieldUpdateOperationsInput | number
    postTestPassed?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LearningProgressUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    watched70Lesson?: IntFieldUpdateOperationsInput | number
    watched70All?: IntFieldUpdateOperationsInput | number
    totalLearners?: IntFieldUpdateOperationsInput | number
    preTestTotal?: IntFieldUpdateOperationsInput | number
    preTestPassed?: IntFieldUpdateOperationsInput | number
    postTestTotal?: IntFieldUpdateOperationsInput | number
    postTestPassed?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RevenueReportCreateInput = {
    month: string
    revenue: number
    orders: number
    avgOrderValue: number
    growth: number
    createdAt?: Date | string
  }

  export type RevenueReportUncheckedCreateInput = {
    id?: number
    month: string
    revenue: number
    orders: number
    avgOrderValue: number
    growth: number
    createdAt?: Date | string
  }

  export type RevenueReportUpdateInput = {
    month?: StringFieldUpdateOperationsInput | string
    revenue?: FloatFieldUpdateOperationsInput | number
    orders?: IntFieldUpdateOperationsInput | number
    avgOrderValue?: FloatFieldUpdateOperationsInput | number
    growth?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RevenueReportUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    month?: StringFieldUpdateOperationsInput | string
    revenue?: FloatFieldUpdateOperationsInput | number
    orders?: IntFieldUpdateOperationsInput | number
    avgOrderValue?: FloatFieldUpdateOperationsInput | number
    growth?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RevenueReportCreateManyInput = {
    id?: number
    month: string
    revenue: number
    orders: number
    avgOrderValue: number
    growth: number
    createdAt?: Date | string
  }

  export type RevenueReportUpdateManyMutationInput = {
    month?: StringFieldUpdateOperationsInput | string
    revenue?: FloatFieldUpdateOperationsInput | number
    orders?: IntFieldUpdateOperationsInput | number
    avgOrderValue?: FloatFieldUpdateOperationsInput | number
    growth?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RevenueReportUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    month?: StringFieldUpdateOperationsInput | string
    revenue?: FloatFieldUpdateOperationsInput | number
    orders?: IntFieldUpdateOperationsInput | number
    avgOrderValue?: FloatFieldUpdateOperationsInput | number
    growth?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAnalyticsCreateInput = {
    totalUsers: number
    activeUsers: number
    activityRate: number
    multipleSessionUsers: number
    updatedAt?: Date | string
  }

  export type UserAnalyticsUncheckedCreateInput = {
    id?: number
    totalUsers: number
    activeUsers: number
    activityRate: number
    multipleSessionUsers: number
    updatedAt?: Date | string
  }

  export type UserAnalyticsUpdateInput = {
    totalUsers?: IntFieldUpdateOperationsInput | number
    activeUsers?: IntFieldUpdateOperationsInput | number
    activityRate?: FloatFieldUpdateOperationsInput | number
    multipleSessionUsers?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAnalyticsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalUsers?: IntFieldUpdateOperationsInput | number
    activeUsers?: IntFieldUpdateOperationsInput | number
    activityRate?: FloatFieldUpdateOperationsInput | number
    multipleSessionUsers?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAnalyticsCreateManyInput = {
    id?: number
    totalUsers: number
    activeUsers: number
    activityRate: number
    multipleSessionUsers: number
    updatedAt?: Date | string
  }

  export type UserAnalyticsUpdateManyMutationInput = {
    totalUsers?: IntFieldUpdateOperationsInput | number
    activeUsers?: IntFieldUpdateOperationsInput | number
    activityRate?: FloatFieldUpdateOperationsInput | number
    multipleSessionUsers?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAnalyticsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalUsers?: IntFieldUpdateOperationsInput | number
    activeUsers?: IntFieldUpdateOperationsInput | number
    activityRate?: FloatFieldUpdateOperationsInput | number
    multipleSessionUsers?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExportTicketCreateInput = {
    title: string
    description: string
    count: number
    icon: string
    color: string
    status?: string
    fileUrl?: string | null
    createdAt?: Date | string
  }

  export type ExportTicketUncheckedCreateInput = {
    id?: number
    title: string
    description: string
    count: number
    icon: string
    color: string
    status?: string
    fileUrl?: string | null
    createdAt?: Date | string
  }

  export type ExportTicketUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    icon?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExportTicketUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    icon?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExportTicketCreateManyInput = {
    id?: number
    title: string
    description: string
    count: number
    icon: string
    color: string
    status?: string
    fileUrl?: string | null
    createdAt?: Date | string
  }

  export type ExportTicketUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    icon?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExportTicketUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    icon?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SystemOverviewCountOrderByAggregateInput = {
    id?: SortOrder
    totalRevenue?: SortOrder
    revenueTrend?: SortOrder
    totalOrders?: SortOrder
    ordersTrend?: SortOrder
    totalUsers?: SortOrder
    usersTrend?: SortOrder
    totalPartners?: SortOrder
    partnersTrend?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemOverviewAvgOrderByAggregateInput = {
    id?: SortOrder
    totalRevenue?: SortOrder
    totalOrders?: SortOrder
    totalUsers?: SortOrder
    totalPartners?: SortOrder
  }

  export type SystemOverviewMaxOrderByAggregateInput = {
    id?: SortOrder
    totalRevenue?: SortOrder
    revenueTrend?: SortOrder
    totalOrders?: SortOrder
    ordersTrend?: SortOrder
    totalUsers?: SortOrder
    usersTrend?: SortOrder
    totalPartners?: SortOrder
    partnersTrend?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemOverviewMinOrderByAggregateInput = {
    id?: SortOrder
    totalRevenue?: SortOrder
    revenueTrend?: SortOrder
    totalOrders?: SortOrder
    ordersTrend?: SortOrder
    totalUsers?: SortOrder
    usersTrend?: SortOrder
    totalPartners?: SortOrder
    partnersTrend?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemOverviewSumOrderByAggregateInput = {
    id?: SortOrder
    totalRevenue?: SortOrder
    totalOrders?: SortOrder
    totalUsers?: SortOrder
    totalPartners?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EducationKPICountOrderByAggregateInput = {
    id?: SortOrder
    totalEnrolled?: SortOrder
    expectedEnrolled?: SortOrder
    enrollmentRate?: SortOrder
    started?: SortOrder
    completed?: SortOrder
    startedRate?: SortOrder
    completedRate?: SortOrder
    totalNotifications?: SortOrder
    usageFrequency?: SortOrder
    avgCourseDuration?: SortOrder
    updatedAt?: SortOrder
  }

  export type EducationKPIAvgOrderByAggregateInput = {
    id?: SortOrder
    totalEnrolled?: SortOrder
    expectedEnrolled?: SortOrder
    enrollmentRate?: SortOrder
    started?: SortOrder
    completed?: SortOrder
    startedRate?: SortOrder
    completedRate?: SortOrder
    totalNotifications?: SortOrder
    usageFrequency?: SortOrder
  }

  export type EducationKPIMaxOrderByAggregateInput = {
    id?: SortOrder
    totalEnrolled?: SortOrder
    expectedEnrolled?: SortOrder
    enrollmentRate?: SortOrder
    started?: SortOrder
    completed?: SortOrder
    startedRate?: SortOrder
    completedRate?: SortOrder
    totalNotifications?: SortOrder
    usageFrequency?: SortOrder
    avgCourseDuration?: SortOrder
    updatedAt?: SortOrder
  }

  export type EducationKPIMinOrderByAggregateInput = {
    id?: SortOrder
    totalEnrolled?: SortOrder
    expectedEnrolled?: SortOrder
    enrollmentRate?: SortOrder
    started?: SortOrder
    completed?: SortOrder
    startedRate?: SortOrder
    completedRate?: SortOrder
    totalNotifications?: SortOrder
    usageFrequency?: SortOrder
    avgCourseDuration?: SortOrder
    updatedAt?: SortOrder
  }

  export type EducationKPISumOrderByAggregateInput = {
    id?: SortOrder
    totalEnrolled?: SortOrder
    expectedEnrolled?: SortOrder
    enrollmentRate?: SortOrder
    started?: SortOrder
    completed?: SortOrder
    startedRate?: SortOrder
    completedRate?: SortOrder
    totalNotifications?: SortOrder
    usageFrequency?: SortOrder
  }

  export type LearningProgressCountOrderByAggregateInput = {
    id?: SortOrder
    watched70Lesson?: SortOrder
    watched70All?: SortOrder
    totalLearners?: SortOrder
    preTestTotal?: SortOrder
    preTestPassed?: SortOrder
    postTestTotal?: SortOrder
    postTestPassed?: SortOrder
    updatedAt?: SortOrder
  }

  export type LearningProgressAvgOrderByAggregateInput = {
    id?: SortOrder
    watched70Lesson?: SortOrder
    watched70All?: SortOrder
    totalLearners?: SortOrder
    preTestTotal?: SortOrder
    preTestPassed?: SortOrder
    postTestTotal?: SortOrder
    postTestPassed?: SortOrder
  }

  export type LearningProgressMaxOrderByAggregateInput = {
    id?: SortOrder
    watched70Lesson?: SortOrder
    watched70All?: SortOrder
    totalLearners?: SortOrder
    preTestTotal?: SortOrder
    preTestPassed?: SortOrder
    postTestTotal?: SortOrder
    postTestPassed?: SortOrder
    updatedAt?: SortOrder
  }

  export type LearningProgressMinOrderByAggregateInput = {
    id?: SortOrder
    watched70Lesson?: SortOrder
    watched70All?: SortOrder
    totalLearners?: SortOrder
    preTestTotal?: SortOrder
    preTestPassed?: SortOrder
    postTestTotal?: SortOrder
    postTestPassed?: SortOrder
    updatedAt?: SortOrder
  }

  export type LearningProgressSumOrderByAggregateInput = {
    id?: SortOrder
    watched70Lesson?: SortOrder
    watched70All?: SortOrder
    totalLearners?: SortOrder
    preTestTotal?: SortOrder
    preTestPassed?: SortOrder
    postTestTotal?: SortOrder
    postTestPassed?: SortOrder
  }

  export type RevenueReportCountOrderByAggregateInput = {
    id?: SortOrder
    month?: SortOrder
    revenue?: SortOrder
    orders?: SortOrder
    avgOrderValue?: SortOrder
    growth?: SortOrder
    createdAt?: SortOrder
  }

  export type RevenueReportAvgOrderByAggregateInput = {
    id?: SortOrder
    revenue?: SortOrder
    orders?: SortOrder
    avgOrderValue?: SortOrder
    growth?: SortOrder
  }

  export type RevenueReportMaxOrderByAggregateInput = {
    id?: SortOrder
    month?: SortOrder
    revenue?: SortOrder
    orders?: SortOrder
    avgOrderValue?: SortOrder
    growth?: SortOrder
    createdAt?: SortOrder
  }

  export type RevenueReportMinOrderByAggregateInput = {
    id?: SortOrder
    month?: SortOrder
    revenue?: SortOrder
    orders?: SortOrder
    avgOrderValue?: SortOrder
    growth?: SortOrder
    createdAt?: SortOrder
  }

  export type RevenueReportSumOrderByAggregateInput = {
    id?: SortOrder
    revenue?: SortOrder
    orders?: SortOrder
    avgOrderValue?: SortOrder
    growth?: SortOrder
  }

  export type UserAnalyticsCountOrderByAggregateInput = {
    id?: SortOrder
    totalUsers?: SortOrder
    activeUsers?: SortOrder
    activityRate?: SortOrder
    multipleSessionUsers?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAnalyticsAvgOrderByAggregateInput = {
    id?: SortOrder
    totalUsers?: SortOrder
    activeUsers?: SortOrder
    activityRate?: SortOrder
    multipleSessionUsers?: SortOrder
  }

  export type UserAnalyticsMaxOrderByAggregateInput = {
    id?: SortOrder
    totalUsers?: SortOrder
    activeUsers?: SortOrder
    activityRate?: SortOrder
    multipleSessionUsers?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAnalyticsMinOrderByAggregateInput = {
    id?: SortOrder
    totalUsers?: SortOrder
    activeUsers?: SortOrder
    activityRate?: SortOrder
    multipleSessionUsers?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAnalyticsSumOrderByAggregateInput = {
    id?: SortOrder
    totalUsers?: SortOrder
    activeUsers?: SortOrder
    activityRate?: SortOrder
    multipleSessionUsers?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ExportTicketCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    count?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    status?: SortOrder
    fileUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type ExportTicketAvgOrderByAggregateInput = {
    id?: SortOrder
    count?: SortOrder
  }

  export type ExportTicketMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    count?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    status?: SortOrder
    fileUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type ExportTicketMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    count?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    status?: SortOrder
    fileUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type ExportTicketSumOrderByAggregateInput = {
    id?: SortOrder
    count?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use SystemOverviewDefaultArgs instead
     */
    export type SystemOverviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SystemOverviewDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EducationKPIDefaultArgs instead
     */
    export type EducationKPIArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EducationKPIDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LearningProgressDefaultArgs instead
     */
    export type LearningProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LearningProgressDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RevenueReportDefaultArgs instead
     */
    export type RevenueReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RevenueReportDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserAnalyticsDefaultArgs instead
     */
    export type UserAnalyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserAnalyticsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExportTicketDefaultArgs instead
     */
    export type ExportTicketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExportTicketDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}