
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Seminar
 * 
 */
export type Seminar = $Result.DefaultSelection<Prisma.$SeminarPayload>
/**
 * Model SeminarBanner
 * 
 */
export type SeminarBanner = $Result.DefaultSelection<Prisma.$SeminarBannerPayload>
/**
 * Model SeminarAttendee
 * 
 */
export type SeminarAttendee = $Result.DefaultSelection<Prisma.$SeminarAttendeePayload>
/**
 * Model SeminarInvitation
 * 
 */
export type SeminarInvitation = $Result.DefaultSelection<Prisma.$SeminarInvitationPayload>
/**
 * Model SeminarSession
 * 
 */
export type SeminarSession = $Result.DefaultSelection<Prisma.$SeminarSessionPayload>
/**
 * Model SeminarSpeaker
 * 
 */
export type SeminarSpeaker = $Result.DefaultSelection<Prisma.$SeminarSpeakerPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Seminars
 * const seminars = await prisma.seminar.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Seminars
   * const seminars = await prisma.seminar.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.seminar`: Exposes CRUD operations for the **Seminar** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Seminars
    * const seminars = await prisma.seminar.findMany()
    * ```
    */
  get seminar(): Prisma.SeminarDelegate<ExtArgs>;

  /**
   * `prisma.seminarBanner`: Exposes CRUD operations for the **SeminarBanner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SeminarBanners
    * const seminarBanners = await prisma.seminarBanner.findMany()
    * ```
    */
  get seminarBanner(): Prisma.SeminarBannerDelegate<ExtArgs>;

  /**
   * `prisma.seminarAttendee`: Exposes CRUD operations for the **SeminarAttendee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SeminarAttendees
    * const seminarAttendees = await prisma.seminarAttendee.findMany()
    * ```
    */
  get seminarAttendee(): Prisma.SeminarAttendeeDelegate<ExtArgs>;

  /**
   * `prisma.seminarInvitation`: Exposes CRUD operations for the **SeminarInvitation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SeminarInvitations
    * const seminarInvitations = await prisma.seminarInvitation.findMany()
    * ```
    */
  get seminarInvitation(): Prisma.SeminarInvitationDelegate<ExtArgs>;

  /**
   * `prisma.seminarSession`: Exposes CRUD operations for the **SeminarSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SeminarSessions
    * const seminarSessions = await prisma.seminarSession.findMany()
    * ```
    */
  get seminarSession(): Prisma.SeminarSessionDelegate<ExtArgs>;

  /**
   * `prisma.seminarSpeaker`: Exposes CRUD operations for the **SeminarSpeaker** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SeminarSpeakers
    * const seminarSpeakers = await prisma.seminarSpeaker.findMany()
    * ```
    */
  get seminarSpeaker(): Prisma.SeminarSpeakerDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Seminar: 'Seminar',
    SeminarBanner: 'SeminarBanner',
    SeminarAttendee: 'SeminarAttendee',
    SeminarInvitation: 'SeminarInvitation',
    SeminarSession: 'SeminarSession',
    SeminarSpeaker: 'SeminarSpeaker'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "seminar" | "seminarBanner" | "seminarAttendee" | "seminarInvitation" | "seminarSession" | "seminarSpeaker"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Seminar: {
        payload: Prisma.$SeminarPayload<ExtArgs>
        fields: Prisma.SeminarFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SeminarFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeminarPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SeminarFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeminarPayload>
          }
          findFirst: {
            args: Prisma.SeminarFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeminarPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SeminarFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeminarPayload>
          }
          findMany: {
            args: Prisma.SeminarFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeminarPayload>[]
          }
          create: {
            args: Prisma.SeminarCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeminarPayload>
          }
          createMany: {
            args: Prisma.SeminarCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SeminarCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeminarPayload>[]
          }
          delete: {
            args: Prisma.SeminarDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeminarPayload>
          }
          update: {
            args: Prisma.SeminarUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeminarPayload>
          }
          deleteMany: {
            args: Prisma.SeminarDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SeminarUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SeminarUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeminarPayload>
          }
          aggregate: {
            args: Prisma.SeminarAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSeminar>
          }
          groupBy: {
            args: Prisma.SeminarGroupByArgs<ExtArgs>
            result: $Utils.Optional<SeminarGroupByOutputType>[]
          }
          count: {
            args: Prisma.SeminarCountArgs<ExtArgs>
            result: $Utils.Optional<SeminarCountAggregateOutputType> | number
          }
        }
      }
      SeminarBanner: {
        payload: Prisma.$SeminarBannerPayload<ExtArgs>
        fields: Prisma.SeminarBannerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SeminarBannerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeminarBannerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SeminarBannerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeminarBannerPayload>
          }
          findFirst: {
            args: Prisma.SeminarBannerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeminarBannerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SeminarBannerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeminarBannerPayload>
          }
          findMany: {
            args: Prisma.SeminarBannerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeminarBannerPayload>[]
          }
          create: {
            args: Prisma.SeminarBannerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeminarBannerPayload>
          }
          createMany: {
            args: Prisma.SeminarBannerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SeminarBannerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeminarBannerPayload>[]
          }
          delete: {
            args: Prisma.SeminarBannerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeminarBannerPayload>
          }
          update: {
            args: Prisma.SeminarBannerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeminarBannerPayload>
          }
          deleteMany: {
            args: Prisma.SeminarBannerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SeminarBannerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SeminarBannerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeminarBannerPayload>
          }
          aggregate: {
            args: Prisma.SeminarBannerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSeminarBanner>
          }
          groupBy: {
            args: Prisma.SeminarBannerGroupByArgs<ExtArgs>
            result: $Utils.Optional<SeminarBannerGroupByOutputType>[]
          }
          count: {
            args: Prisma.SeminarBannerCountArgs<ExtArgs>
            result: $Utils.Optional<SeminarBannerCountAggregateOutputType> | number
          }
        }
      }
      SeminarAttendee: {
        payload: Prisma.$SeminarAttendeePayload<ExtArgs>
        fields: Prisma.SeminarAttendeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SeminarAttendeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeminarAttendeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SeminarAttendeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeminarAttendeePayload>
          }
          findFirst: {
            args: Prisma.SeminarAttendeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeminarAttendeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SeminarAttendeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeminarAttendeePayload>
          }
          findMany: {
            args: Prisma.SeminarAttendeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeminarAttendeePayload>[]
          }
          create: {
            args: Prisma.SeminarAttendeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeminarAttendeePayload>
          }
          createMany: {
            args: Prisma.SeminarAttendeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SeminarAttendeeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeminarAttendeePayload>[]
          }
          delete: {
            args: Prisma.SeminarAttendeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeminarAttendeePayload>
          }
          update: {
            args: Prisma.SeminarAttendeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeminarAttendeePayload>
          }
          deleteMany: {
            args: Prisma.SeminarAttendeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SeminarAttendeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SeminarAttendeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeminarAttendeePayload>
          }
          aggregate: {
            args: Prisma.SeminarAttendeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSeminarAttendee>
          }
          groupBy: {
            args: Prisma.SeminarAttendeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<SeminarAttendeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.SeminarAttendeeCountArgs<ExtArgs>
            result: $Utils.Optional<SeminarAttendeeCountAggregateOutputType> | number
          }
        }
      }
      SeminarInvitation: {
        payload: Prisma.$SeminarInvitationPayload<ExtArgs>
        fields: Prisma.SeminarInvitationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SeminarInvitationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeminarInvitationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SeminarInvitationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeminarInvitationPayload>
          }
          findFirst: {
            args: Prisma.SeminarInvitationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeminarInvitationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SeminarInvitationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeminarInvitationPayload>
          }
          findMany: {
            args: Prisma.SeminarInvitationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeminarInvitationPayload>[]
          }
          create: {
            args: Prisma.SeminarInvitationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeminarInvitationPayload>
          }
          createMany: {
            args: Prisma.SeminarInvitationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SeminarInvitationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeminarInvitationPayload>[]
          }
          delete: {
            args: Prisma.SeminarInvitationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeminarInvitationPayload>
          }
          update: {
            args: Prisma.SeminarInvitationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeminarInvitationPayload>
          }
          deleteMany: {
            args: Prisma.SeminarInvitationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SeminarInvitationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SeminarInvitationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeminarInvitationPayload>
          }
          aggregate: {
            args: Prisma.SeminarInvitationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSeminarInvitation>
          }
          groupBy: {
            args: Prisma.SeminarInvitationGroupByArgs<ExtArgs>
            result: $Utils.Optional<SeminarInvitationGroupByOutputType>[]
          }
          count: {
            args: Prisma.SeminarInvitationCountArgs<ExtArgs>
            result: $Utils.Optional<SeminarInvitationCountAggregateOutputType> | number
          }
        }
      }
      SeminarSession: {
        payload: Prisma.$SeminarSessionPayload<ExtArgs>
        fields: Prisma.SeminarSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SeminarSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeminarSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SeminarSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeminarSessionPayload>
          }
          findFirst: {
            args: Prisma.SeminarSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeminarSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SeminarSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeminarSessionPayload>
          }
          findMany: {
            args: Prisma.SeminarSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeminarSessionPayload>[]
          }
          create: {
            args: Prisma.SeminarSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeminarSessionPayload>
          }
          createMany: {
            args: Prisma.SeminarSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SeminarSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeminarSessionPayload>[]
          }
          delete: {
            args: Prisma.SeminarSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeminarSessionPayload>
          }
          update: {
            args: Prisma.SeminarSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeminarSessionPayload>
          }
          deleteMany: {
            args: Prisma.SeminarSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SeminarSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SeminarSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeminarSessionPayload>
          }
          aggregate: {
            args: Prisma.SeminarSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSeminarSession>
          }
          groupBy: {
            args: Prisma.SeminarSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SeminarSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SeminarSessionCountArgs<ExtArgs>
            result: $Utils.Optional<SeminarSessionCountAggregateOutputType> | number
          }
        }
      }
      SeminarSpeaker: {
        payload: Prisma.$SeminarSpeakerPayload<ExtArgs>
        fields: Prisma.SeminarSpeakerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SeminarSpeakerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeminarSpeakerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SeminarSpeakerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeminarSpeakerPayload>
          }
          findFirst: {
            args: Prisma.SeminarSpeakerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeminarSpeakerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SeminarSpeakerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeminarSpeakerPayload>
          }
          findMany: {
            args: Prisma.SeminarSpeakerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeminarSpeakerPayload>[]
          }
          create: {
            args: Prisma.SeminarSpeakerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeminarSpeakerPayload>
          }
          createMany: {
            args: Prisma.SeminarSpeakerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SeminarSpeakerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeminarSpeakerPayload>[]
          }
          delete: {
            args: Prisma.SeminarSpeakerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeminarSpeakerPayload>
          }
          update: {
            args: Prisma.SeminarSpeakerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeminarSpeakerPayload>
          }
          deleteMany: {
            args: Prisma.SeminarSpeakerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SeminarSpeakerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SeminarSpeakerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeminarSpeakerPayload>
          }
          aggregate: {
            args: Prisma.SeminarSpeakerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSeminarSpeaker>
          }
          groupBy: {
            args: Prisma.SeminarSpeakerGroupByArgs<ExtArgs>
            result: $Utils.Optional<SeminarSpeakerGroupByOutputType>[]
          }
          count: {
            args: Prisma.SeminarSpeakerCountArgs<ExtArgs>
            result: $Utils.Optional<SeminarSpeakerCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type SeminarCountOutputType
   */

  export type SeminarCountOutputType = {
    banners: number
    attendees: number
    invitations: number
    sessions: number
  }

  export type SeminarCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    banners?: boolean | SeminarCountOutputTypeCountBannersArgs
    attendees?: boolean | SeminarCountOutputTypeCountAttendeesArgs
    invitations?: boolean | SeminarCountOutputTypeCountInvitationsArgs
    sessions?: boolean | SeminarCountOutputTypeCountSessionsArgs
  }

  // Custom InputTypes
  /**
   * SeminarCountOutputType without action
   */
  export type SeminarCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeminarCountOutputType
     */
    select?: SeminarCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SeminarCountOutputType without action
   */
  export type SeminarCountOutputTypeCountBannersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeminarBannerWhereInput
  }

  /**
   * SeminarCountOutputType without action
   */
  export type SeminarCountOutputTypeCountAttendeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeminarAttendeeWhereInput
  }

  /**
   * SeminarCountOutputType without action
   */
  export type SeminarCountOutputTypeCountInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeminarInvitationWhereInput
  }

  /**
   * SeminarCountOutputType without action
   */
  export type SeminarCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeminarSessionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Seminar
   */

  export type AggregateSeminar = {
    _count: SeminarCountAggregateOutputType | null
    _avg: SeminarAvgAggregateOutputType | null
    _sum: SeminarSumAggregateOutputType | null
    _min: SeminarMinAggregateOutputType | null
    _max: SeminarMaxAggregateOutputType | null
  }

  export type SeminarAvgAggregateOutputType = {
    id: number | null
    capacity: number | null
    registrations: number | null
  }

  export type SeminarSumAggregateOutputType = {
    id: number | null
    capacity: number | null
    registrations: number | null
  }

  export type SeminarMinAggregateOutputType = {
    id: number | null
    title: string | null
    date: string | null
    location: string | null
    capacity: number | null
    registrations: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SeminarMaxAggregateOutputType = {
    id: number | null
    title: string | null
    date: string | null
    location: string | null
    capacity: number | null
    registrations: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SeminarCountAggregateOutputType = {
    id: number
    title: number
    date: number
    location: number
    capacity: number
    registrations: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SeminarAvgAggregateInputType = {
    id?: true
    capacity?: true
    registrations?: true
  }

  export type SeminarSumAggregateInputType = {
    id?: true
    capacity?: true
    registrations?: true
  }

  export type SeminarMinAggregateInputType = {
    id?: true
    title?: true
    date?: true
    location?: true
    capacity?: true
    registrations?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SeminarMaxAggregateInputType = {
    id?: true
    title?: true
    date?: true
    location?: true
    capacity?: true
    registrations?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SeminarCountAggregateInputType = {
    id?: true
    title?: true
    date?: true
    location?: true
    capacity?: true
    registrations?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SeminarAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Seminar to aggregate.
     */
    where?: SeminarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seminars to fetch.
     */
    orderBy?: SeminarOrderByWithRelationInput | SeminarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SeminarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seminars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seminars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Seminars
    **/
    _count?: true | SeminarCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SeminarAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SeminarSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SeminarMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SeminarMaxAggregateInputType
  }

  export type GetSeminarAggregateType<T extends SeminarAggregateArgs> = {
        [P in keyof T & keyof AggregateSeminar]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeminar[P]>
      : GetScalarType<T[P], AggregateSeminar[P]>
  }




  export type SeminarGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeminarWhereInput
    orderBy?: SeminarOrderByWithAggregationInput | SeminarOrderByWithAggregationInput[]
    by: SeminarScalarFieldEnum[] | SeminarScalarFieldEnum
    having?: SeminarScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SeminarCountAggregateInputType | true
    _avg?: SeminarAvgAggregateInputType
    _sum?: SeminarSumAggregateInputType
    _min?: SeminarMinAggregateInputType
    _max?: SeminarMaxAggregateInputType
  }

  export type SeminarGroupByOutputType = {
    id: number
    title: string
    date: string
    location: string
    capacity: number
    registrations: number
    status: string
    createdAt: Date
    updatedAt: Date
    _count: SeminarCountAggregateOutputType | null
    _avg: SeminarAvgAggregateOutputType | null
    _sum: SeminarSumAggregateOutputType | null
    _min: SeminarMinAggregateOutputType | null
    _max: SeminarMaxAggregateOutputType | null
  }

  type GetSeminarGroupByPayload<T extends SeminarGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SeminarGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SeminarGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SeminarGroupByOutputType[P]>
            : GetScalarType<T[P], SeminarGroupByOutputType[P]>
        }
      >
    >


  export type SeminarSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    date?: boolean
    location?: boolean
    capacity?: boolean
    registrations?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    banners?: boolean | Seminar$bannersArgs<ExtArgs>
    attendees?: boolean | Seminar$attendeesArgs<ExtArgs>
    invitations?: boolean | Seminar$invitationsArgs<ExtArgs>
    sessions?: boolean | Seminar$sessionsArgs<ExtArgs>
    _count?: boolean | SeminarCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["seminar"]>

  export type SeminarSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    date?: boolean
    location?: boolean
    capacity?: boolean
    registrations?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["seminar"]>

  export type SeminarSelectScalar = {
    id?: boolean
    title?: boolean
    date?: boolean
    location?: boolean
    capacity?: boolean
    registrations?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SeminarInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    banners?: boolean | Seminar$bannersArgs<ExtArgs>
    attendees?: boolean | Seminar$attendeesArgs<ExtArgs>
    invitations?: boolean | Seminar$invitationsArgs<ExtArgs>
    sessions?: boolean | Seminar$sessionsArgs<ExtArgs>
    _count?: boolean | SeminarCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SeminarIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SeminarPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Seminar"
    objects: {
      banners: Prisma.$SeminarBannerPayload<ExtArgs>[]
      attendees: Prisma.$SeminarAttendeePayload<ExtArgs>[]
      invitations: Prisma.$SeminarInvitationPayload<ExtArgs>[]
      sessions: Prisma.$SeminarSessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      date: string
      location: string
      capacity: number
      registrations: number
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["seminar"]>
    composites: {}
  }

  type SeminarGetPayload<S extends boolean | null | undefined | SeminarDefaultArgs> = $Result.GetResult<Prisma.$SeminarPayload, S>

  type SeminarCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SeminarFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SeminarCountAggregateInputType | true
    }

  export interface SeminarDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Seminar'], meta: { name: 'Seminar' } }
    /**
     * Find zero or one Seminar that matches the filter.
     * @param {SeminarFindUniqueArgs} args - Arguments to find a Seminar
     * @example
     * // Get one Seminar
     * const seminar = await prisma.seminar.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SeminarFindUniqueArgs>(args: SelectSubset<T, SeminarFindUniqueArgs<ExtArgs>>): Prisma__SeminarClient<$Result.GetResult<Prisma.$SeminarPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Seminar that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SeminarFindUniqueOrThrowArgs} args - Arguments to find a Seminar
     * @example
     * // Get one Seminar
     * const seminar = await prisma.seminar.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SeminarFindUniqueOrThrowArgs>(args: SelectSubset<T, SeminarFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SeminarClient<$Result.GetResult<Prisma.$SeminarPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Seminar that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeminarFindFirstArgs} args - Arguments to find a Seminar
     * @example
     * // Get one Seminar
     * const seminar = await prisma.seminar.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SeminarFindFirstArgs>(args?: SelectSubset<T, SeminarFindFirstArgs<ExtArgs>>): Prisma__SeminarClient<$Result.GetResult<Prisma.$SeminarPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Seminar that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeminarFindFirstOrThrowArgs} args - Arguments to find a Seminar
     * @example
     * // Get one Seminar
     * const seminar = await prisma.seminar.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SeminarFindFirstOrThrowArgs>(args?: SelectSubset<T, SeminarFindFirstOrThrowArgs<ExtArgs>>): Prisma__SeminarClient<$Result.GetResult<Prisma.$SeminarPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Seminars that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeminarFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Seminars
     * const seminars = await prisma.seminar.findMany()
     * 
     * // Get first 10 Seminars
     * const seminars = await prisma.seminar.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const seminarWithIdOnly = await prisma.seminar.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SeminarFindManyArgs>(args?: SelectSubset<T, SeminarFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeminarPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Seminar.
     * @param {SeminarCreateArgs} args - Arguments to create a Seminar.
     * @example
     * // Create one Seminar
     * const Seminar = await prisma.seminar.create({
     *   data: {
     *     // ... data to create a Seminar
     *   }
     * })
     * 
     */
    create<T extends SeminarCreateArgs>(args: SelectSubset<T, SeminarCreateArgs<ExtArgs>>): Prisma__SeminarClient<$Result.GetResult<Prisma.$SeminarPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Seminars.
     * @param {SeminarCreateManyArgs} args - Arguments to create many Seminars.
     * @example
     * // Create many Seminars
     * const seminar = await prisma.seminar.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SeminarCreateManyArgs>(args?: SelectSubset<T, SeminarCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Seminars and returns the data saved in the database.
     * @param {SeminarCreateManyAndReturnArgs} args - Arguments to create many Seminars.
     * @example
     * // Create many Seminars
     * const seminar = await prisma.seminar.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Seminars and only return the `id`
     * const seminarWithIdOnly = await prisma.seminar.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SeminarCreateManyAndReturnArgs>(args?: SelectSubset<T, SeminarCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeminarPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Seminar.
     * @param {SeminarDeleteArgs} args - Arguments to delete one Seminar.
     * @example
     * // Delete one Seminar
     * const Seminar = await prisma.seminar.delete({
     *   where: {
     *     // ... filter to delete one Seminar
     *   }
     * })
     * 
     */
    delete<T extends SeminarDeleteArgs>(args: SelectSubset<T, SeminarDeleteArgs<ExtArgs>>): Prisma__SeminarClient<$Result.GetResult<Prisma.$SeminarPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Seminar.
     * @param {SeminarUpdateArgs} args - Arguments to update one Seminar.
     * @example
     * // Update one Seminar
     * const seminar = await prisma.seminar.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SeminarUpdateArgs>(args: SelectSubset<T, SeminarUpdateArgs<ExtArgs>>): Prisma__SeminarClient<$Result.GetResult<Prisma.$SeminarPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Seminars.
     * @param {SeminarDeleteManyArgs} args - Arguments to filter Seminars to delete.
     * @example
     * // Delete a few Seminars
     * const { count } = await prisma.seminar.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SeminarDeleteManyArgs>(args?: SelectSubset<T, SeminarDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Seminars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeminarUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Seminars
     * const seminar = await prisma.seminar.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SeminarUpdateManyArgs>(args: SelectSubset<T, SeminarUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Seminar.
     * @param {SeminarUpsertArgs} args - Arguments to update or create a Seminar.
     * @example
     * // Update or create a Seminar
     * const seminar = await prisma.seminar.upsert({
     *   create: {
     *     // ... data to create a Seminar
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Seminar we want to update
     *   }
     * })
     */
    upsert<T extends SeminarUpsertArgs>(args: SelectSubset<T, SeminarUpsertArgs<ExtArgs>>): Prisma__SeminarClient<$Result.GetResult<Prisma.$SeminarPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Seminars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeminarCountArgs} args - Arguments to filter Seminars to count.
     * @example
     * // Count the number of Seminars
     * const count = await prisma.seminar.count({
     *   where: {
     *     // ... the filter for the Seminars we want to count
     *   }
     * })
    **/
    count<T extends SeminarCountArgs>(
      args?: Subset<T, SeminarCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SeminarCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Seminar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeminarAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SeminarAggregateArgs>(args: Subset<T, SeminarAggregateArgs>): Prisma.PrismaPromise<GetSeminarAggregateType<T>>

    /**
     * Group by Seminar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeminarGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SeminarGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SeminarGroupByArgs['orderBy'] }
        : { orderBy?: SeminarGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SeminarGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSeminarGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Seminar model
   */
  readonly fields: SeminarFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Seminar.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SeminarClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    banners<T extends Seminar$bannersArgs<ExtArgs> = {}>(args?: Subset<T, Seminar$bannersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeminarBannerPayload<ExtArgs>, T, "findMany"> | Null>
    attendees<T extends Seminar$attendeesArgs<ExtArgs> = {}>(args?: Subset<T, Seminar$attendeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeminarAttendeePayload<ExtArgs>, T, "findMany"> | Null>
    invitations<T extends Seminar$invitationsArgs<ExtArgs> = {}>(args?: Subset<T, Seminar$invitationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeminarInvitationPayload<ExtArgs>, T, "findMany"> | Null>
    sessions<T extends Seminar$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, Seminar$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeminarSessionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Seminar model
   */ 
  interface SeminarFieldRefs {
    readonly id: FieldRef<"Seminar", 'Int'>
    readonly title: FieldRef<"Seminar", 'String'>
    readonly date: FieldRef<"Seminar", 'String'>
    readonly location: FieldRef<"Seminar", 'String'>
    readonly capacity: FieldRef<"Seminar", 'Int'>
    readonly registrations: FieldRef<"Seminar", 'Int'>
    readonly status: FieldRef<"Seminar", 'String'>
    readonly createdAt: FieldRef<"Seminar", 'DateTime'>
    readonly updatedAt: FieldRef<"Seminar", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Seminar findUnique
   */
  export type SeminarFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seminar
     */
    select?: SeminarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeminarInclude<ExtArgs> | null
    /**
     * Filter, which Seminar to fetch.
     */
    where: SeminarWhereUniqueInput
  }

  /**
   * Seminar findUniqueOrThrow
   */
  export type SeminarFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seminar
     */
    select?: SeminarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeminarInclude<ExtArgs> | null
    /**
     * Filter, which Seminar to fetch.
     */
    where: SeminarWhereUniqueInput
  }

  /**
   * Seminar findFirst
   */
  export type SeminarFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seminar
     */
    select?: SeminarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeminarInclude<ExtArgs> | null
    /**
     * Filter, which Seminar to fetch.
     */
    where?: SeminarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seminars to fetch.
     */
    orderBy?: SeminarOrderByWithRelationInput | SeminarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Seminars.
     */
    cursor?: SeminarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seminars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seminars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Seminars.
     */
    distinct?: SeminarScalarFieldEnum | SeminarScalarFieldEnum[]
  }

  /**
   * Seminar findFirstOrThrow
   */
  export type SeminarFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seminar
     */
    select?: SeminarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeminarInclude<ExtArgs> | null
    /**
     * Filter, which Seminar to fetch.
     */
    where?: SeminarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seminars to fetch.
     */
    orderBy?: SeminarOrderByWithRelationInput | SeminarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Seminars.
     */
    cursor?: SeminarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seminars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seminars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Seminars.
     */
    distinct?: SeminarScalarFieldEnum | SeminarScalarFieldEnum[]
  }

  /**
   * Seminar findMany
   */
  export type SeminarFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seminar
     */
    select?: SeminarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeminarInclude<ExtArgs> | null
    /**
     * Filter, which Seminars to fetch.
     */
    where?: SeminarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seminars to fetch.
     */
    orderBy?: SeminarOrderByWithRelationInput | SeminarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Seminars.
     */
    cursor?: SeminarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seminars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seminars.
     */
    skip?: number
    distinct?: SeminarScalarFieldEnum | SeminarScalarFieldEnum[]
  }

  /**
   * Seminar create
   */
  export type SeminarCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seminar
     */
    select?: SeminarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeminarInclude<ExtArgs> | null
    /**
     * The data needed to create a Seminar.
     */
    data: XOR<SeminarCreateInput, SeminarUncheckedCreateInput>
  }

  /**
   * Seminar createMany
   */
  export type SeminarCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Seminars.
     */
    data: SeminarCreateManyInput | SeminarCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Seminar createManyAndReturn
   */
  export type SeminarCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seminar
     */
    select?: SeminarSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Seminars.
     */
    data: SeminarCreateManyInput | SeminarCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Seminar update
   */
  export type SeminarUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seminar
     */
    select?: SeminarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeminarInclude<ExtArgs> | null
    /**
     * The data needed to update a Seminar.
     */
    data: XOR<SeminarUpdateInput, SeminarUncheckedUpdateInput>
    /**
     * Choose, which Seminar to update.
     */
    where: SeminarWhereUniqueInput
  }

  /**
   * Seminar updateMany
   */
  export type SeminarUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Seminars.
     */
    data: XOR<SeminarUpdateManyMutationInput, SeminarUncheckedUpdateManyInput>
    /**
     * Filter which Seminars to update
     */
    where?: SeminarWhereInput
  }

  /**
   * Seminar upsert
   */
  export type SeminarUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seminar
     */
    select?: SeminarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeminarInclude<ExtArgs> | null
    /**
     * The filter to search for the Seminar to update in case it exists.
     */
    where: SeminarWhereUniqueInput
    /**
     * In case the Seminar found by the `where` argument doesn't exist, create a new Seminar with this data.
     */
    create: XOR<SeminarCreateInput, SeminarUncheckedCreateInput>
    /**
     * In case the Seminar was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SeminarUpdateInput, SeminarUncheckedUpdateInput>
  }

  /**
   * Seminar delete
   */
  export type SeminarDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seminar
     */
    select?: SeminarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeminarInclude<ExtArgs> | null
    /**
     * Filter which Seminar to delete.
     */
    where: SeminarWhereUniqueInput
  }

  /**
   * Seminar deleteMany
   */
  export type SeminarDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Seminars to delete
     */
    where?: SeminarWhereInput
  }

  /**
   * Seminar.banners
   */
  export type Seminar$bannersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeminarBanner
     */
    select?: SeminarBannerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeminarBannerInclude<ExtArgs> | null
    where?: SeminarBannerWhereInput
    orderBy?: SeminarBannerOrderByWithRelationInput | SeminarBannerOrderByWithRelationInput[]
    cursor?: SeminarBannerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SeminarBannerScalarFieldEnum | SeminarBannerScalarFieldEnum[]
  }

  /**
   * Seminar.attendees
   */
  export type Seminar$attendeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeminarAttendee
     */
    select?: SeminarAttendeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeminarAttendeeInclude<ExtArgs> | null
    where?: SeminarAttendeeWhereInput
    orderBy?: SeminarAttendeeOrderByWithRelationInput | SeminarAttendeeOrderByWithRelationInput[]
    cursor?: SeminarAttendeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SeminarAttendeeScalarFieldEnum | SeminarAttendeeScalarFieldEnum[]
  }

  /**
   * Seminar.invitations
   */
  export type Seminar$invitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeminarInvitation
     */
    select?: SeminarInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeminarInvitationInclude<ExtArgs> | null
    where?: SeminarInvitationWhereInput
    orderBy?: SeminarInvitationOrderByWithRelationInput | SeminarInvitationOrderByWithRelationInput[]
    cursor?: SeminarInvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SeminarInvitationScalarFieldEnum | SeminarInvitationScalarFieldEnum[]
  }

  /**
   * Seminar.sessions
   */
  export type Seminar$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeminarSession
     */
    select?: SeminarSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeminarSessionInclude<ExtArgs> | null
    where?: SeminarSessionWhereInput
    orderBy?: SeminarSessionOrderByWithRelationInput | SeminarSessionOrderByWithRelationInput[]
    cursor?: SeminarSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SeminarSessionScalarFieldEnum | SeminarSessionScalarFieldEnum[]
  }

  /**
   * Seminar without action
   */
  export type SeminarDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seminar
     */
    select?: SeminarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeminarInclude<ExtArgs> | null
  }


  /**
   * Model SeminarBanner
   */

  export type AggregateSeminarBanner = {
    _count: SeminarBannerCountAggregateOutputType | null
    _avg: SeminarBannerAvgAggregateOutputType | null
    _sum: SeminarBannerSumAggregateOutputType | null
    _min: SeminarBannerMinAggregateOutputType | null
    _max: SeminarBannerMaxAggregateOutputType | null
  }

  export type SeminarBannerAvgAggregateOutputType = {
    id: number | null
    seminarId: number | null
    priority: number | null
  }

  export type SeminarBannerSumAggregateOutputType = {
    id: number | null
    seminarId: number | null
    priority: number | null
  }

  export type SeminarBannerMinAggregateOutputType = {
    id: number | null
    seminarId: number | null
    image: string | null
    priority: number | null
  }

  export type SeminarBannerMaxAggregateOutputType = {
    id: number | null
    seminarId: number | null
    image: string | null
    priority: number | null
  }

  export type SeminarBannerCountAggregateOutputType = {
    id: number
    seminarId: number
    image: number
    priority: number
    _all: number
  }


  export type SeminarBannerAvgAggregateInputType = {
    id?: true
    seminarId?: true
    priority?: true
  }

  export type SeminarBannerSumAggregateInputType = {
    id?: true
    seminarId?: true
    priority?: true
  }

  export type SeminarBannerMinAggregateInputType = {
    id?: true
    seminarId?: true
    image?: true
    priority?: true
  }

  export type SeminarBannerMaxAggregateInputType = {
    id?: true
    seminarId?: true
    image?: true
    priority?: true
  }

  export type SeminarBannerCountAggregateInputType = {
    id?: true
    seminarId?: true
    image?: true
    priority?: true
    _all?: true
  }

  export type SeminarBannerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SeminarBanner to aggregate.
     */
    where?: SeminarBannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeminarBanners to fetch.
     */
    orderBy?: SeminarBannerOrderByWithRelationInput | SeminarBannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SeminarBannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeminarBanners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeminarBanners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SeminarBanners
    **/
    _count?: true | SeminarBannerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SeminarBannerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SeminarBannerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SeminarBannerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SeminarBannerMaxAggregateInputType
  }

  export type GetSeminarBannerAggregateType<T extends SeminarBannerAggregateArgs> = {
        [P in keyof T & keyof AggregateSeminarBanner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeminarBanner[P]>
      : GetScalarType<T[P], AggregateSeminarBanner[P]>
  }




  export type SeminarBannerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeminarBannerWhereInput
    orderBy?: SeminarBannerOrderByWithAggregationInput | SeminarBannerOrderByWithAggregationInput[]
    by: SeminarBannerScalarFieldEnum[] | SeminarBannerScalarFieldEnum
    having?: SeminarBannerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SeminarBannerCountAggregateInputType | true
    _avg?: SeminarBannerAvgAggregateInputType
    _sum?: SeminarBannerSumAggregateInputType
    _min?: SeminarBannerMinAggregateInputType
    _max?: SeminarBannerMaxAggregateInputType
  }

  export type SeminarBannerGroupByOutputType = {
    id: number
    seminarId: number
    image: string
    priority: number
    _count: SeminarBannerCountAggregateOutputType | null
    _avg: SeminarBannerAvgAggregateOutputType | null
    _sum: SeminarBannerSumAggregateOutputType | null
    _min: SeminarBannerMinAggregateOutputType | null
    _max: SeminarBannerMaxAggregateOutputType | null
  }

  type GetSeminarBannerGroupByPayload<T extends SeminarBannerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SeminarBannerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SeminarBannerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SeminarBannerGroupByOutputType[P]>
            : GetScalarType<T[P], SeminarBannerGroupByOutputType[P]>
        }
      >
    >


  export type SeminarBannerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seminarId?: boolean
    image?: boolean
    priority?: boolean
    seminar?: boolean | SeminarDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["seminarBanner"]>

  export type SeminarBannerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seminarId?: boolean
    image?: boolean
    priority?: boolean
    seminar?: boolean | SeminarDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["seminarBanner"]>

  export type SeminarBannerSelectScalar = {
    id?: boolean
    seminarId?: boolean
    image?: boolean
    priority?: boolean
  }

  export type SeminarBannerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seminar?: boolean | SeminarDefaultArgs<ExtArgs>
  }
  export type SeminarBannerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seminar?: boolean | SeminarDefaultArgs<ExtArgs>
  }

  export type $SeminarBannerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SeminarBanner"
    objects: {
      seminar: Prisma.$SeminarPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      seminarId: number
      image: string
      priority: number
    }, ExtArgs["result"]["seminarBanner"]>
    composites: {}
  }

  type SeminarBannerGetPayload<S extends boolean | null | undefined | SeminarBannerDefaultArgs> = $Result.GetResult<Prisma.$SeminarBannerPayload, S>

  type SeminarBannerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SeminarBannerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SeminarBannerCountAggregateInputType | true
    }

  export interface SeminarBannerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SeminarBanner'], meta: { name: 'SeminarBanner' } }
    /**
     * Find zero or one SeminarBanner that matches the filter.
     * @param {SeminarBannerFindUniqueArgs} args - Arguments to find a SeminarBanner
     * @example
     * // Get one SeminarBanner
     * const seminarBanner = await prisma.seminarBanner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SeminarBannerFindUniqueArgs>(args: SelectSubset<T, SeminarBannerFindUniqueArgs<ExtArgs>>): Prisma__SeminarBannerClient<$Result.GetResult<Prisma.$SeminarBannerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SeminarBanner that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SeminarBannerFindUniqueOrThrowArgs} args - Arguments to find a SeminarBanner
     * @example
     * // Get one SeminarBanner
     * const seminarBanner = await prisma.seminarBanner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SeminarBannerFindUniqueOrThrowArgs>(args: SelectSubset<T, SeminarBannerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SeminarBannerClient<$Result.GetResult<Prisma.$SeminarBannerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SeminarBanner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeminarBannerFindFirstArgs} args - Arguments to find a SeminarBanner
     * @example
     * // Get one SeminarBanner
     * const seminarBanner = await prisma.seminarBanner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SeminarBannerFindFirstArgs>(args?: SelectSubset<T, SeminarBannerFindFirstArgs<ExtArgs>>): Prisma__SeminarBannerClient<$Result.GetResult<Prisma.$SeminarBannerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SeminarBanner that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeminarBannerFindFirstOrThrowArgs} args - Arguments to find a SeminarBanner
     * @example
     * // Get one SeminarBanner
     * const seminarBanner = await prisma.seminarBanner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SeminarBannerFindFirstOrThrowArgs>(args?: SelectSubset<T, SeminarBannerFindFirstOrThrowArgs<ExtArgs>>): Prisma__SeminarBannerClient<$Result.GetResult<Prisma.$SeminarBannerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SeminarBanners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeminarBannerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SeminarBanners
     * const seminarBanners = await prisma.seminarBanner.findMany()
     * 
     * // Get first 10 SeminarBanners
     * const seminarBanners = await prisma.seminarBanner.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const seminarBannerWithIdOnly = await prisma.seminarBanner.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SeminarBannerFindManyArgs>(args?: SelectSubset<T, SeminarBannerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeminarBannerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SeminarBanner.
     * @param {SeminarBannerCreateArgs} args - Arguments to create a SeminarBanner.
     * @example
     * // Create one SeminarBanner
     * const SeminarBanner = await prisma.seminarBanner.create({
     *   data: {
     *     // ... data to create a SeminarBanner
     *   }
     * })
     * 
     */
    create<T extends SeminarBannerCreateArgs>(args: SelectSubset<T, SeminarBannerCreateArgs<ExtArgs>>): Prisma__SeminarBannerClient<$Result.GetResult<Prisma.$SeminarBannerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SeminarBanners.
     * @param {SeminarBannerCreateManyArgs} args - Arguments to create many SeminarBanners.
     * @example
     * // Create many SeminarBanners
     * const seminarBanner = await prisma.seminarBanner.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SeminarBannerCreateManyArgs>(args?: SelectSubset<T, SeminarBannerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SeminarBanners and returns the data saved in the database.
     * @param {SeminarBannerCreateManyAndReturnArgs} args - Arguments to create many SeminarBanners.
     * @example
     * // Create many SeminarBanners
     * const seminarBanner = await prisma.seminarBanner.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SeminarBanners and only return the `id`
     * const seminarBannerWithIdOnly = await prisma.seminarBanner.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SeminarBannerCreateManyAndReturnArgs>(args?: SelectSubset<T, SeminarBannerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeminarBannerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SeminarBanner.
     * @param {SeminarBannerDeleteArgs} args - Arguments to delete one SeminarBanner.
     * @example
     * // Delete one SeminarBanner
     * const SeminarBanner = await prisma.seminarBanner.delete({
     *   where: {
     *     // ... filter to delete one SeminarBanner
     *   }
     * })
     * 
     */
    delete<T extends SeminarBannerDeleteArgs>(args: SelectSubset<T, SeminarBannerDeleteArgs<ExtArgs>>): Prisma__SeminarBannerClient<$Result.GetResult<Prisma.$SeminarBannerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SeminarBanner.
     * @param {SeminarBannerUpdateArgs} args - Arguments to update one SeminarBanner.
     * @example
     * // Update one SeminarBanner
     * const seminarBanner = await prisma.seminarBanner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SeminarBannerUpdateArgs>(args: SelectSubset<T, SeminarBannerUpdateArgs<ExtArgs>>): Prisma__SeminarBannerClient<$Result.GetResult<Prisma.$SeminarBannerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SeminarBanners.
     * @param {SeminarBannerDeleteManyArgs} args - Arguments to filter SeminarBanners to delete.
     * @example
     * // Delete a few SeminarBanners
     * const { count } = await prisma.seminarBanner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SeminarBannerDeleteManyArgs>(args?: SelectSubset<T, SeminarBannerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SeminarBanners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeminarBannerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SeminarBanners
     * const seminarBanner = await prisma.seminarBanner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SeminarBannerUpdateManyArgs>(args: SelectSubset<T, SeminarBannerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SeminarBanner.
     * @param {SeminarBannerUpsertArgs} args - Arguments to update or create a SeminarBanner.
     * @example
     * // Update or create a SeminarBanner
     * const seminarBanner = await prisma.seminarBanner.upsert({
     *   create: {
     *     // ... data to create a SeminarBanner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SeminarBanner we want to update
     *   }
     * })
     */
    upsert<T extends SeminarBannerUpsertArgs>(args: SelectSubset<T, SeminarBannerUpsertArgs<ExtArgs>>): Prisma__SeminarBannerClient<$Result.GetResult<Prisma.$SeminarBannerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SeminarBanners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeminarBannerCountArgs} args - Arguments to filter SeminarBanners to count.
     * @example
     * // Count the number of SeminarBanners
     * const count = await prisma.seminarBanner.count({
     *   where: {
     *     // ... the filter for the SeminarBanners we want to count
     *   }
     * })
    **/
    count<T extends SeminarBannerCountArgs>(
      args?: Subset<T, SeminarBannerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SeminarBannerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SeminarBanner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeminarBannerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SeminarBannerAggregateArgs>(args: Subset<T, SeminarBannerAggregateArgs>): Prisma.PrismaPromise<GetSeminarBannerAggregateType<T>>

    /**
     * Group by SeminarBanner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeminarBannerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SeminarBannerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SeminarBannerGroupByArgs['orderBy'] }
        : { orderBy?: SeminarBannerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SeminarBannerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSeminarBannerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SeminarBanner model
   */
  readonly fields: SeminarBannerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SeminarBanner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SeminarBannerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    seminar<T extends SeminarDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SeminarDefaultArgs<ExtArgs>>): Prisma__SeminarClient<$Result.GetResult<Prisma.$SeminarPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SeminarBanner model
   */ 
  interface SeminarBannerFieldRefs {
    readonly id: FieldRef<"SeminarBanner", 'Int'>
    readonly seminarId: FieldRef<"SeminarBanner", 'Int'>
    readonly image: FieldRef<"SeminarBanner", 'String'>
    readonly priority: FieldRef<"SeminarBanner", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SeminarBanner findUnique
   */
  export type SeminarBannerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeminarBanner
     */
    select?: SeminarBannerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeminarBannerInclude<ExtArgs> | null
    /**
     * Filter, which SeminarBanner to fetch.
     */
    where: SeminarBannerWhereUniqueInput
  }

  /**
   * SeminarBanner findUniqueOrThrow
   */
  export type SeminarBannerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeminarBanner
     */
    select?: SeminarBannerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeminarBannerInclude<ExtArgs> | null
    /**
     * Filter, which SeminarBanner to fetch.
     */
    where: SeminarBannerWhereUniqueInput
  }

  /**
   * SeminarBanner findFirst
   */
  export type SeminarBannerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeminarBanner
     */
    select?: SeminarBannerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeminarBannerInclude<ExtArgs> | null
    /**
     * Filter, which SeminarBanner to fetch.
     */
    where?: SeminarBannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeminarBanners to fetch.
     */
    orderBy?: SeminarBannerOrderByWithRelationInput | SeminarBannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SeminarBanners.
     */
    cursor?: SeminarBannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeminarBanners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeminarBanners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SeminarBanners.
     */
    distinct?: SeminarBannerScalarFieldEnum | SeminarBannerScalarFieldEnum[]
  }

  /**
   * SeminarBanner findFirstOrThrow
   */
  export type SeminarBannerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeminarBanner
     */
    select?: SeminarBannerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeminarBannerInclude<ExtArgs> | null
    /**
     * Filter, which SeminarBanner to fetch.
     */
    where?: SeminarBannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeminarBanners to fetch.
     */
    orderBy?: SeminarBannerOrderByWithRelationInput | SeminarBannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SeminarBanners.
     */
    cursor?: SeminarBannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeminarBanners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeminarBanners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SeminarBanners.
     */
    distinct?: SeminarBannerScalarFieldEnum | SeminarBannerScalarFieldEnum[]
  }

  /**
   * SeminarBanner findMany
   */
  export type SeminarBannerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeminarBanner
     */
    select?: SeminarBannerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeminarBannerInclude<ExtArgs> | null
    /**
     * Filter, which SeminarBanners to fetch.
     */
    where?: SeminarBannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeminarBanners to fetch.
     */
    orderBy?: SeminarBannerOrderByWithRelationInput | SeminarBannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SeminarBanners.
     */
    cursor?: SeminarBannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeminarBanners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeminarBanners.
     */
    skip?: number
    distinct?: SeminarBannerScalarFieldEnum | SeminarBannerScalarFieldEnum[]
  }

  /**
   * SeminarBanner create
   */
  export type SeminarBannerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeminarBanner
     */
    select?: SeminarBannerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeminarBannerInclude<ExtArgs> | null
    /**
     * The data needed to create a SeminarBanner.
     */
    data: XOR<SeminarBannerCreateInput, SeminarBannerUncheckedCreateInput>
  }

  /**
   * SeminarBanner createMany
   */
  export type SeminarBannerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SeminarBanners.
     */
    data: SeminarBannerCreateManyInput | SeminarBannerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SeminarBanner createManyAndReturn
   */
  export type SeminarBannerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeminarBanner
     */
    select?: SeminarBannerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SeminarBanners.
     */
    data: SeminarBannerCreateManyInput | SeminarBannerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeminarBannerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SeminarBanner update
   */
  export type SeminarBannerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeminarBanner
     */
    select?: SeminarBannerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeminarBannerInclude<ExtArgs> | null
    /**
     * The data needed to update a SeminarBanner.
     */
    data: XOR<SeminarBannerUpdateInput, SeminarBannerUncheckedUpdateInput>
    /**
     * Choose, which SeminarBanner to update.
     */
    where: SeminarBannerWhereUniqueInput
  }

  /**
   * SeminarBanner updateMany
   */
  export type SeminarBannerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SeminarBanners.
     */
    data: XOR<SeminarBannerUpdateManyMutationInput, SeminarBannerUncheckedUpdateManyInput>
    /**
     * Filter which SeminarBanners to update
     */
    where?: SeminarBannerWhereInput
  }

  /**
   * SeminarBanner upsert
   */
  export type SeminarBannerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeminarBanner
     */
    select?: SeminarBannerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeminarBannerInclude<ExtArgs> | null
    /**
     * The filter to search for the SeminarBanner to update in case it exists.
     */
    where: SeminarBannerWhereUniqueInput
    /**
     * In case the SeminarBanner found by the `where` argument doesn't exist, create a new SeminarBanner with this data.
     */
    create: XOR<SeminarBannerCreateInput, SeminarBannerUncheckedCreateInput>
    /**
     * In case the SeminarBanner was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SeminarBannerUpdateInput, SeminarBannerUncheckedUpdateInput>
  }

  /**
   * SeminarBanner delete
   */
  export type SeminarBannerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeminarBanner
     */
    select?: SeminarBannerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeminarBannerInclude<ExtArgs> | null
    /**
     * Filter which SeminarBanner to delete.
     */
    where: SeminarBannerWhereUniqueInput
  }

  /**
   * SeminarBanner deleteMany
   */
  export type SeminarBannerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SeminarBanners to delete
     */
    where?: SeminarBannerWhereInput
  }

  /**
   * SeminarBanner without action
   */
  export type SeminarBannerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeminarBanner
     */
    select?: SeminarBannerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeminarBannerInclude<ExtArgs> | null
  }


  /**
   * Model SeminarAttendee
   */

  export type AggregateSeminarAttendee = {
    _count: SeminarAttendeeCountAggregateOutputType | null
    _avg: SeminarAttendeeAvgAggregateOutputType | null
    _sum: SeminarAttendeeSumAggregateOutputType | null
    _min: SeminarAttendeeMinAggregateOutputType | null
    _max: SeminarAttendeeMaxAggregateOutputType | null
  }

  export type SeminarAttendeeAvgAggregateOutputType = {
    id: number | null
    seminarId: number | null
  }

  export type SeminarAttendeeSumAggregateOutputType = {
    id: number | null
    seminarId: number | null
  }

  export type SeminarAttendeeMinAggregateOutputType = {
    id: number | null
    seminarId: number | null
    name: string | null
    email: string | null
    phone: string | null
    checkedIn: boolean | null
    checkinTime: string | null
  }

  export type SeminarAttendeeMaxAggregateOutputType = {
    id: number | null
    seminarId: number | null
    name: string | null
    email: string | null
    phone: string | null
    checkedIn: boolean | null
    checkinTime: string | null
  }

  export type SeminarAttendeeCountAggregateOutputType = {
    id: number
    seminarId: number
    name: number
    email: number
    phone: number
    checkedIn: number
    checkinTime: number
    _all: number
  }


  export type SeminarAttendeeAvgAggregateInputType = {
    id?: true
    seminarId?: true
  }

  export type SeminarAttendeeSumAggregateInputType = {
    id?: true
    seminarId?: true
  }

  export type SeminarAttendeeMinAggregateInputType = {
    id?: true
    seminarId?: true
    name?: true
    email?: true
    phone?: true
    checkedIn?: true
    checkinTime?: true
  }

  export type SeminarAttendeeMaxAggregateInputType = {
    id?: true
    seminarId?: true
    name?: true
    email?: true
    phone?: true
    checkedIn?: true
    checkinTime?: true
  }

  export type SeminarAttendeeCountAggregateInputType = {
    id?: true
    seminarId?: true
    name?: true
    email?: true
    phone?: true
    checkedIn?: true
    checkinTime?: true
    _all?: true
  }

  export type SeminarAttendeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SeminarAttendee to aggregate.
     */
    where?: SeminarAttendeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeminarAttendees to fetch.
     */
    orderBy?: SeminarAttendeeOrderByWithRelationInput | SeminarAttendeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SeminarAttendeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeminarAttendees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeminarAttendees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SeminarAttendees
    **/
    _count?: true | SeminarAttendeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SeminarAttendeeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SeminarAttendeeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SeminarAttendeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SeminarAttendeeMaxAggregateInputType
  }

  export type GetSeminarAttendeeAggregateType<T extends SeminarAttendeeAggregateArgs> = {
        [P in keyof T & keyof AggregateSeminarAttendee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeminarAttendee[P]>
      : GetScalarType<T[P], AggregateSeminarAttendee[P]>
  }




  export type SeminarAttendeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeminarAttendeeWhereInput
    orderBy?: SeminarAttendeeOrderByWithAggregationInput | SeminarAttendeeOrderByWithAggregationInput[]
    by: SeminarAttendeeScalarFieldEnum[] | SeminarAttendeeScalarFieldEnum
    having?: SeminarAttendeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SeminarAttendeeCountAggregateInputType | true
    _avg?: SeminarAttendeeAvgAggregateInputType
    _sum?: SeminarAttendeeSumAggregateInputType
    _min?: SeminarAttendeeMinAggregateInputType
    _max?: SeminarAttendeeMaxAggregateInputType
  }

  export type SeminarAttendeeGroupByOutputType = {
    id: number
    seminarId: number
    name: string
    email: string
    phone: string
    checkedIn: boolean
    checkinTime: string | null
    _count: SeminarAttendeeCountAggregateOutputType | null
    _avg: SeminarAttendeeAvgAggregateOutputType | null
    _sum: SeminarAttendeeSumAggregateOutputType | null
    _min: SeminarAttendeeMinAggregateOutputType | null
    _max: SeminarAttendeeMaxAggregateOutputType | null
  }

  type GetSeminarAttendeeGroupByPayload<T extends SeminarAttendeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SeminarAttendeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SeminarAttendeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SeminarAttendeeGroupByOutputType[P]>
            : GetScalarType<T[P], SeminarAttendeeGroupByOutputType[P]>
        }
      >
    >


  export type SeminarAttendeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seminarId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    checkedIn?: boolean
    checkinTime?: boolean
    seminar?: boolean | SeminarDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["seminarAttendee"]>

  export type SeminarAttendeeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seminarId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    checkedIn?: boolean
    checkinTime?: boolean
    seminar?: boolean | SeminarDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["seminarAttendee"]>

  export type SeminarAttendeeSelectScalar = {
    id?: boolean
    seminarId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    checkedIn?: boolean
    checkinTime?: boolean
  }

  export type SeminarAttendeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seminar?: boolean | SeminarDefaultArgs<ExtArgs>
  }
  export type SeminarAttendeeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seminar?: boolean | SeminarDefaultArgs<ExtArgs>
  }

  export type $SeminarAttendeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SeminarAttendee"
    objects: {
      seminar: Prisma.$SeminarPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      seminarId: number
      name: string
      email: string
      phone: string
      checkedIn: boolean
      checkinTime: string | null
    }, ExtArgs["result"]["seminarAttendee"]>
    composites: {}
  }

  type SeminarAttendeeGetPayload<S extends boolean | null | undefined | SeminarAttendeeDefaultArgs> = $Result.GetResult<Prisma.$SeminarAttendeePayload, S>

  type SeminarAttendeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SeminarAttendeeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SeminarAttendeeCountAggregateInputType | true
    }

  export interface SeminarAttendeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SeminarAttendee'], meta: { name: 'SeminarAttendee' } }
    /**
     * Find zero or one SeminarAttendee that matches the filter.
     * @param {SeminarAttendeeFindUniqueArgs} args - Arguments to find a SeminarAttendee
     * @example
     * // Get one SeminarAttendee
     * const seminarAttendee = await prisma.seminarAttendee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SeminarAttendeeFindUniqueArgs>(args: SelectSubset<T, SeminarAttendeeFindUniqueArgs<ExtArgs>>): Prisma__SeminarAttendeeClient<$Result.GetResult<Prisma.$SeminarAttendeePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SeminarAttendee that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SeminarAttendeeFindUniqueOrThrowArgs} args - Arguments to find a SeminarAttendee
     * @example
     * // Get one SeminarAttendee
     * const seminarAttendee = await prisma.seminarAttendee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SeminarAttendeeFindUniqueOrThrowArgs>(args: SelectSubset<T, SeminarAttendeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SeminarAttendeeClient<$Result.GetResult<Prisma.$SeminarAttendeePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SeminarAttendee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeminarAttendeeFindFirstArgs} args - Arguments to find a SeminarAttendee
     * @example
     * // Get one SeminarAttendee
     * const seminarAttendee = await prisma.seminarAttendee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SeminarAttendeeFindFirstArgs>(args?: SelectSubset<T, SeminarAttendeeFindFirstArgs<ExtArgs>>): Prisma__SeminarAttendeeClient<$Result.GetResult<Prisma.$SeminarAttendeePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SeminarAttendee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeminarAttendeeFindFirstOrThrowArgs} args - Arguments to find a SeminarAttendee
     * @example
     * // Get one SeminarAttendee
     * const seminarAttendee = await prisma.seminarAttendee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SeminarAttendeeFindFirstOrThrowArgs>(args?: SelectSubset<T, SeminarAttendeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__SeminarAttendeeClient<$Result.GetResult<Prisma.$SeminarAttendeePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SeminarAttendees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeminarAttendeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SeminarAttendees
     * const seminarAttendees = await prisma.seminarAttendee.findMany()
     * 
     * // Get first 10 SeminarAttendees
     * const seminarAttendees = await prisma.seminarAttendee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const seminarAttendeeWithIdOnly = await prisma.seminarAttendee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SeminarAttendeeFindManyArgs>(args?: SelectSubset<T, SeminarAttendeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeminarAttendeePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SeminarAttendee.
     * @param {SeminarAttendeeCreateArgs} args - Arguments to create a SeminarAttendee.
     * @example
     * // Create one SeminarAttendee
     * const SeminarAttendee = await prisma.seminarAttendee.create({
     *   data: {
     *     // ... data to create a SeminarAttendee
     *   }
     * })
     * 
     */
    create<T extends SeminarAttendeeCreateArgs>(args: SelectSubset<T, SeminarAttendeeCreateArgs<ExtArgs>>): Prisma__SeminarAttendeeClient<$Result.GetResult<Prisma.$SeminarAttendeePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SeminarAttendees.
     * @param {SeminarAttendeeCreateManyArgs} args - Arguments to create many SeminarAttendees.
     * @example
     * // Create many SeminarAttendees
     * const seminarAttendee = await prisma.seminarAttendee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SeminarAttendeeCreateManyArgs>(args?: SelectSubset<T, SeminarAttendeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SeminarAttendees and returns the data saved in the database.
     * @param {SeminarAttendeeCreateManyAndReturnArgs} args - Arguments to create many SeminarAttendees.
     * @example
     * // Create many SeminarAttendees
     * const seminarAttendee = await prisma.seminarAttendee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SeminarAttendees and only return the `id`
     * const seminarAttendeeWithIdOnly = await prisma.seminarAttendee.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SeminarAttendeeCreateManyAndReturnArgs>(args?: SelectSubset<T, SeminarAttendeeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeminarAttendeePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SeminarAttendee.
     * @param {SeminarAttendeeDeleteArgs} args - Arguments to delete one SeminarAttendee.
     * @example
     * // Delete one SeminarAttendee
     * const SeminarAttendee = await prisma.seminarAttendee.delete({
     *   where: {
     *     // ... filter to delete one SeminarAttendee
     *   }
     * })
     * 
     */
    delete<T extends SeminarAttendeeDeleteArgs>(args: SelectSubset<T, SeminarAttendeeDeleteArgs<ExtArgs>>): Prisma__SeminarAttendeeClient<$Result.GetResult<Prisma.$SeminarAttendeePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SeminarAttendee.
     * @param {SeminarAttendeeUpdateArgs} args - Arguments to update one SeminarAttendee.
     * @example
     * // Update one SeminarAttendee
     * const seminarAttendee = await prisma.seminarAttendee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SeminarAttendeeUpdateArgs>(args: SelectSubset<T, SeminarAttendeeUpdateArgs<ExtArgs>>): Prisma__SeminarAttendeeClient<$Result.GetResult<Prisma.$SeminarAttendeePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SeminarAttendees.
     * @param {SeminarAttendeeDeleteManyArgs} args - Arguments to filter SeminarAttendees to delete.
     * @example
     * // Delete a few SeminarAttendees
     * const { count } = await prisma.seminarAttendee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SeminarAttendeeDeleteManyArgs>(args?: SelectSubset<T, SeminarAttendeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SeminarAttendees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeminarAttendeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SeminarAttendees
     * const seminarAttendee = await prisma.seminarAttendee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SeminarAttendeeUpdateManyArgs>(args: SelectSubset<T, SeminarAttendeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SeminarAttendee.
     * @param {SeminarAttendeeUpsertArgs} args - Arguments to update or create a SeminarAttendee.
     * @example
     * // Update or create a SeminarAttendee
     * const seminarAttendee = await prisma.seminarAttendee.upsert({
     *   create: {
     *     // ... data to create a SeminarAttendee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SeminarAttendee we want to update
     *   }
     * })
     */
    upsert<T extends SeminarAttendeeUpsertArgs>(args: SelectSubset<T, SeminarAttendeeUpsertArgs<ExtArgs>>): Prisma__SeminarAttendeeClient<$Result.GetResult<Prisma.$SeminarAttendeePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SeminarAttendees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeminarAttendeeCountArgs} args - Arguments to filter SeminarAttendees to count.
     * @example
     * // Count the number of SeminarAttendees
     * const count = await prisma.seminarAttendee.count({
     *   where: {
     *     // ... the filter for the SeminarAttendees we want to count
     *   }
     * })
    **/
    count<T extends SeminarAttendeeCountArgs>(
      args?: Subset<T, SeminarAttendeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SeminarAttendeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SeminarAttendee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeminarAttendeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SeminarAttendeeAggregateArgs>(args: Subset<T, SeminarAttendeeAggregateArgs>): Prisma.PrismaPromise<GetSeminarAttendeeAggregateType<T>>

    /**
     * Group by SeminarAttendee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeminarAttendeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SeminarAttendeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SeminarAttendeeGroupByArgs['orderBy'] }
        : { orderBy?: SeminarAttendeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SeminarAttendeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSeminarAttendeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SeminarAttendee model
   */
  readonly fields: SeminarAttendeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SeminarAttendee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SeminarAttendeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    seminar<T extends SeminarDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SeminarDefaultArgs<ExtArgs>>): Prisma__SeminarClient<$Result.GetResult<Prisma.$SeminarPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SeminarAttendee model
   */ 
  interface SeminarAttendeeFieldRefs {
    readonly id: FieldRef<"SeminarAttendee", 'Int'>
    readonly seminarId: FieldRef<"SeminarAttendee", 'Int'>
    readonly name: FieldRef<"SeminarAttendee", 'String'>
    readonly email: FieldRef<"SeminarAttendee", 'String'>
    readonly phone: FieldRef<"SeminarAttendee", 'String'>
    readonly checkedIn: FieldRef<"SeminarAttendee", 'Boolean'>
    readonly checkinTime: FieldRef<"SeminarAttendee", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SeminarAttendee findUnique
   */
  export type SeminarAttendeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeminarAttendee
     */
    select?: SeminarAttendeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeminarAttendeeInclude<ExtArgs> | null
    /**
     * Filter, which SeminarAttendee to fetch.
     */
    where: SeminarAttendeeWhereUniqueInput
  }

  /**
   * SeminarAttendee findUniqueOrThrow
   */
  export type SeminarAttendeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeminarAttendee
     */
    select?: SeminarAttendeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeminarAttendeeInclude<ExtArgs> | null
    /**
     * Filter, which SeminarAttendee to fetch.
     */
    where: SeminarAttendeeWhereUniqueInput
  }

  /**
   * SeminarAttendee findFirst
   */
  export type SeminarAttendeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeminarAttendee
     */
    select?: SeminarAttendeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeminarAttendeeInclude<ExtArgs> | null
    /**
     * Filter, which SeminarAttendee to fetch.
     */
    where?: SeminarAttendeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeminarAttendees to fetch.
     */
    orderBy?: SeminarAttendeeOrderByWithRelationInput | SeminarAttendeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SeminarAttendees.
     */
    cursor?: SeminarAttendeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeminarAttendees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeminarAttendees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SeminarAttendees.
     */
    distinct?: SeminarAttendeeScalarFieldEnum | SeminarAttendeeScalarFieldEnum[]
  }

  /**
   * SeminarAttendee findFirstOrThrow
   */
  export type SeminarAttendeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeminarAttendee
     */
    select?: SeminarAttendeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeminarAttendeeInclude<ExtArgs> | null
    /**
     * Filter, which SeminarAttendee to fetch.
     */
    where?: SeminarAttendeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeminarAttendees to fetch.
     */
    orderBy?: SeminarAttendeeOrderByWithRelationInput | SeminarAttendeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SeminarAttendees.
     */
    cursor?: SeminarAttendeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeminarAttendees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeminarAttendees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SeminarAttendees.
     */
    distinct?: SeminarAttendeeScalarFieldEnum | SeminarAttendeeScalarFieldEnum[]
  }

  /**
   * SeminarAttendee findMany
   */
  export type SeminarAttendeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeminarAttendee
     */
    select?: SeminarAttendeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeminarAttendeeInclude<ExtArgs> | null
    /**
     * Filter, which SeminarAttendees to fetch.
     */
    where?: SeminarAttendeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeminarAttendees to fetch.
     */
    orderBy?: SeminarAttendeeOrderByWithRelationInput | SeminarAttendeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SeminarAttendees.
     */
    cursor?: SeminarAttendeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeminarAttendees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeminarAttendees.
     */
    skip?: number
    distinct?: SeminarAttendeeScalarFieldEnum | SeminarAttendeeScalarFieldEnum[]
  }

  /**
   * SeminarAttendee create
   */
  export type SeminarAttendeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeminarAttendee
     */
    select?: SeminarAttendeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeminarAttendeeInclude<ExtArgs> | null
    /**
     * The data needed to create a SeminarAttendee.
     */
    data: XOR<SeminarAttendeeCreateInput, SeminarAttendeeUncheckedCreateInput>
  }

  /**
   * SeminarAttendee createMany
   */
  export type SeminarAttendeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SeminarAttendees.
     */
    data: SeminarAttendeeCreateManyInput | SeminarAttendeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SeminarAttendee createManyAndReturn
   */
  export type SeminarAttendeeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeminarAttendee
     */
    select?: SeminarAttendeeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SeminarAttendees.
     */
    data: SeminarAttendeeCreateManyInput | SeminarAttendeeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeminarAttendeeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SeminarAttendee update
   */
  export type SeminarAttendeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeminarAttendee
     */
    select?: SeminarAttendeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeminarAttendeeInclude<ExtArgs> | null
    /**
     * The data needed to update a SeminarAttendee.
     */
    data: XOR<SeminarAttendeeUpdateInput, SeminarAttendeeUncheckedUpdateInput>
    /**
     * Choose, which SeminarAttendee to update.
     */
    where: SeminarAttendeeWhereUniqueInput
  }

  /**
   * SeminarAttendee updateMany
   */
  export type SeminarAttendeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SeminarAttendees.
     */
    data: XOR<SeminarAttendeeUpdateManyMutationInput, SeminarAttendeeUncheckedUpdateManyInput>
    /**
     * Filter which SeminarAttendees to update
     */
    where?: SeminarAttendeeWhereInput
  }

  /**
   * SeminarAttendee upsert
   */
  export type SeminarAttendeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeminarAttendee
     */
    select?: SeminarAttendeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeminarAttendeeInclude<ExtArgs> | null
    /**
     * The filter to search for the SeminarAttendee to update in case it exists.
     */
    where: SeminarAttendeeWhereUniqueInput
    /**
     * In case the SeminarAttendee found by the `where` argument doesn't exist, create a new SeminarAttendee with this data.
     */
    create: XOR<SeminarAttendeeCreateInput, SeminarAttendeeUncheckedCreateInput>
    /**
     * In case the SeminarAttendee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SeminarAttendeeUpdateInput, SeminarAttendeeUncheckedUpdateInput>
  }

  /**
   * SeminarAttendee delete
   */
  export type SeminarAttendeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeminarAttendee
     */
    select?: SeminarAttendeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeminarAttendeeInclude<ExtArgs> | null
    /**
     * Filter which SeminarAttendee to delete.
     */
    where: SeminarAttendeeWhereUniqueInput
  }

  /**
   * SeminarAttendee deleteMany
   */
  export type SeminarAttendeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SeminarAttendees to delete
     */
    where?: SeminarAttendeeWhereInput
  }

  /**
   * SeminarAttendee without action
   */
  export type SeminarAttendeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeminarAttendee
     */
    select?: SeminarAttendeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeminarAttendeeInclude<ExtArgs> | null
  }


  /**
   * Model SeminarInvitation
   */

  export type AggregateSeminarInvitation = {
    _count: SeminarInvitationCountAggregateOutputType | null
    _avg: SeminarInvitationAvgAggregateOutputType | null
    _sum: SeminarInvitationSumAggregateOutputType | null
    _min: SeminarInvitationMinAggregateOutputType | null
    _max: SeminarInvitationMaxAggregateOutputType | null
  }

  export type SeminarInvitationAvgAggregateOutputType = {
    id: number | null
    seminarId: number | null
    sent: number | null
    opened: number | null
    registered: number | null
  }

  export type SeminarInvitationSumAggregateOutputType = {
    id: number | null
    seminarId: number | null
    sent: number | null
    opened: number | null
    registered: number | null
  }

  export type SeminarInvitationMinAggregateOutputType = {
    id: number | null
    seminarId: number | null
    sent: number | null
    opened: number | null
    registered: number | null
    date: string | null
  }

  export type SeminarInvitationMaxAggregateOutputType = {
    id: number | null
    seminarId: number | null
    sent: number | null
    opened: number | null
    registered: number | null
    date: string | null
  }

  export type SeminarInvitationCountAggregateOutputType = {
    id: number
    seminarId: number
    sent: number
    opened: number
    registered: number
    date: number
    _all: number
  }


  export type SeminarInvitationAvgAggregateInputType = {
    id?: true
    seminarId?: true
    sent?: true
    opened?: true
    registered?: true
  }

  export type SeminarInvitationSumAggregateInputType = {
    id?: true
    seminarId?: true
    sent?: true
    opened?: true
    registered?: true
  }

  export type SeminarInvitationMinAggregateInputType = {
    id?: true
    seminarId?: true
    sent?: true
    opened?: true
    registered?: true
    date?: true
  }

  export type SeminarInvitationMaxAggregateInputType = {
    id?: true
    seminarId?: true
    sent?: true
    opened?: true
    registered?: true
    date?: true
  }

  export type SeminarInvitationCountAggregateInputType = {
    id?: true
    seminarId?: true
    sent?: true
    opened?: true
    registered?: true
    date?: true
    _all?: true
  }

  export type SeminarInvitationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SeminarInvitation to aggregate.
     */
    where?: SeminarInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeminarInvitations to fetch.
     */
    orderBy?: SeminarInvitationOrderByWithRelationInput | SeminarInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SeminarInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeminarInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeminarInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SeminarInvitations
    **/
    _count?: true | SeminarInvitationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SeminarInvitationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SeminarInvitationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SeminarInvitationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SeminarInvitationMaxAggregateInputType
  }

  export type GetSeminarInvitationAggregateType<T extends SeminarInvitationAggregateArgs> = {
        [P in keyof T & keyof AggregateSeminarInvitation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeminarInvitation[P]>
      : GetScalarType<T[P], AggregateSeminarInvitation[P]>
  }




  export type SeminarInvitationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeminarInvitationWhereInput
    orderBy?: SeminarInvitationOrderByWithAggregationInput | SeminarInvitationOrderByWithAggregationInput[]
    by: SeminarInvitationScalarFieldEnum[] | SeminarInvitationScalarFieldEnum
    having?: SeminarInvitationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SeminarInvitationCountAggregateInputType | true
    _avg?: SeminarInvitationAvgAggregateInputType
    _sum?: SeminarInvitationSumAggregateInputType
    _min?: SeminarInvitationMinAggregateInputType
    _max?: SeminarInvitationMaxAggregateInputType
  }

  export type SeminarInvitationGroupByOutputType = {
    id: number
    seminarId: number
    sent: number
    opened: number
    registered: number
    date: string
    _count: SeminarInvitationCountAggregateOutputType | null
    _avg: SeminarInvitationAvgAggregateOutputType | null
    _sum: SeminarInvitationSumAggregateOutputType | null
    _min: SeminarInvitationMinAggregateOutputType | null
    _max: SeminarInvitationMaxAggregateOutputType | null
  }

  type GetSeminarInvitationGroupByPayload<T extends SeminarInvitationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SeminarInvitationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SeminarInvitationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SeminarInvitationGroupByOutputType[P]>
            : GetScalarType<T[P], SeminarInvitationGroupByOutputType[P]>
        }
      >
    >


  export type SeminarInvitationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seminarId?: boolean
    sent?: boolean
    opened?: boolean
    registered?: boolean
    date?: boolean
    seminar?: boolean | SeminarDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["seminarInvitation"]>

  export type SeminarInvitationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seminarId?: boolean
    sent?: boolean
    opened?: boolean
    registered?: boolean
    date?: boolean
    seminar?: boolean | SeminarDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["seminarInvitation"]>

  export type SeminarInvitationSelectScalar = {
    id?: boolean
    seminarId?: boolean
    sent?: boolean
    opened?: boolean
    registered?: boolean
    date?: boolean
  }

  export type SeminarInvitationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seminar?: boolean | SeminarDefaultArgs<ExtArgs>
  }
  export type SeminarInvitationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seminar?: boolean | SeminarDefaultArgs<ExtArgs>
  }

  export type $SeminarInvitationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SeminarInvitation"
    objects: {
      seminar: Prisma.$SeminarPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      seminarId: number
      sent: number
      opened: number
      registered: number
      date: string
    }, ExtArgs["result"]["seminarInvitation"]>
    composites: {}
  }

  type SeminarInvitationGetPayload<S extends boolean | null | undefined | SeminarInvitationDefaultArgs> = $Result.GetResult<Prisma.$SeminarInvitationPayload, S>

  type SeminarInvitationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SeminarInvitationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SeminarInvitationCountAggregateInputType | true
    }

  export interface SeminarInvitationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SeminarInvitation'], meta: { name: 'SeminarInvitation' } }
    /**
     * Find zero or one SeminarInvitation that matches the filter.
     * @param {SeminarInvitationFindUniqueArgs} args - Arguments to find a SeminarInvitation
     * @example
     * // Get one SeminarInvitation
     * const seminarInvitation = await prisma.seminarInvitation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SeminarInvitationFindUniqueArgs>(args: SelectSubset<T, SeminarInvitationFindUniqueArgs<ExtArgs>>): Prisma__SeminarInvitationClient<$Result.GetResult<Prisma.$SeminarInvitationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SeminarInvitation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SeminarInvitationFindUniqueOrThrowArgs} args - Arguments to find a SeminarInvitation
     * @example
     * // Get one SeminarInvitation
     * const seminarInvitation = await prisma.seminarInvitation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SeminarInvitationFindUniqueOrThrowArgs>(args: SelectSubset<T, SeminarInvitationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SeminarInvitationClient<$Result.GetResult<Prisma.$SeminarInvitationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SeminarInvitation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeminarInvitationFindFirstArgs} args - Arguments to find a SeminarInvitation
     * @example
     * // Get one SeminarInvitation
     * const seminarInvitation = await prisma.seminarInvitation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SeminarInvitationFindFirstArgs>(args?: SelectSubset<T, SeminarInvitationFindFirstArgs<ExtArgs>>): Prisma__SeminarInvitationClient<$Result.GetResult<Prisma.$SeminarInvitationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SeminarInvitation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeminarInvitationFindFirstOrThrowArgs} args - Arguments to find a SeminarInvitation
     * @example
     * // Get one SeminarInvitation
     * const seminarInvitation = await prisma.seminarInvitation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SeminarInvitationFindFirstOrThrowArgs>(args?: SelectSubset<T, SeminarInvitationFindFirstOrThrowArgs<ExtArgs>>): Prisma__SeminarInvitationClient<$Result.GetResult<Prisma.$SeminarInvitationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SeminarInvitations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeminarInvitationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SeminarInvitations
     * const seminarInvitations = await prisma.seminarInvitation.findMany()
     * 
     * // Get first 10 SeminarInvitations
     * const seminarInvitations = await prisma.seminarInvitation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const seminarInvitationWithIdOnly = await prisma.seminarInvitation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SeminarInvitationFindManyArgs>(args?: SelectSubset<T, SeminarInvitationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeminarInvitationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SeminarInvitation.
     * @param {SeminarInvitationCreateArgs} args - Arguments to create a SeminarInvitation.
     * @example
     * // Create one SeminarInvitation
     * const SeminarInvitation = await prisma.seminarInvitation.create({
     *   data: {
     *     // ... data to create a SeminarInvitation
     *   }
     * })
     * 
     */
    create<T extends SeminarInvitationCreateArgs>(args: SelectSubset<T, SeminarInvitationCreateArgs<ExtArgs>>): Prisma__SeminarInvitationClient<$Result.GetResult<Prisma.$SeminarInvitationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SeminarInvitations.
     * @param {SeminarInvitationCreateManyArgs} args - Arguments to create many SeminarInvitations.
     * @example
     * // Create many SeminarInvitations
     * const seminarInvitation = await prisma.seminarInvitation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SeminarInvitationCreateManyArgs>(args?: SelectSubset<T, SeminarInvitationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SeminarInvitations and returns the data saved in the database.
     * @param {SeminarInvitationCreateManyAndReturnArgs} args - Arguments to create many SeminarInvitations.
     * @example
     * // Create many SeminarInvitations
     * const seminarInvitation = await prisma.seminarInvitation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SeminarInvitations and only return the `id`
     * const seminarInvitationWithIdOnly = await prisma.seminarInvitation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SeminarInvitationCreateManyAndReturnArgs>(args?: SelectSubset<T, SeminarInvitationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeminarInvitationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SeminarInvitation.
     * @param {SeminarInvitationDeleteArgs} args - Arguments to delete one SeminarInvitation.
     * @example
     * // Delete one SeminarInvitation
     * const SeminarInvitation = await prisma.seminarInvitation.delete({
     *   where: {
     *     // ... filter to delete one SeminarInvitation
     *   }
     * })
     * 
     */
    delete<T extends SeminarInvitationDeleteArgs>(args: SelectSubset<T, SeminarInvitationDeleteArgs<ExtArgs>>): Prisma__SeminarInvitationClient<$Result.GetResult<Prisma.$SeminarInvitationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SeminarInvitation.
     * @param {SeminarInvitationUpdateArgs} args - Arguments to update one SeminarInvitation.
     * @example
     * // Update one SeminarInvitation
     * const seminarInvitation = await prisma.seminarInvitation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SeminarInvitationUpdateArgs>(args: SelectSubset<T, SeminarInvitationUpdateArgs<ExtArgs>>): Prisma__SeminarInvitationClient<$Result.GetResult<Prisma.$SeminarInvitationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SeminarInvitations.
     * @param {SeminarInvitationDeleteManyArgs} args - Arguments to filter SeminarInvitations to delete.
     * @example
     * // Delete a few SeminarInvitations
     * const { count } = await prisma.seminarInvitation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SeminarInvitationDeleteManyArgs>(args?: SelectSubset<T, SeminarInvitationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SeminarInvitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeminarInvitationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SeminarInvitations
     * const seminarInvitation = await prisma.seminarInvitation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SeminarInvitationUpdateManyArgs>(args: SelectSubset<T, SeminarInvitationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SeminarInvitation.
     * @param {SeminarInvitationUpsertArgs} args - Arguments to update or create a SeminarInvitation.
     * @example
     * // Update or create a SeminarInvitation
     * const seminarInvitation = await prisma.seminarInvitation.upsert({
     *   create: {
     *     // ... data to create a SeminarInvitation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SeminarInvitation we want to update
     *   }
     * })
     */
    upsert<T extends SeminarInvitationUpsertArgs>(args: SelectSubset<T, SeminarInvitationUpsertArgs<ExtArgs>>): Prisma__SeminarInvitationClient<$Result.GetResult<Prisma.$SeminarInvitationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SeminarInvitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeminarInvitationCountArgs} args - Arguments to filter SeminarInvitations to count.
     * @example
     * // Count the number of SeminarInvitations
     * const count = await prisma.seminarInvitation.count({
     *   where: {
     *     // ... the filter for the SeminarInvitations we want to count
     *   }
     * })
    **/
    count<T extends SeminarInvitationCountArgs>(
      args?: Subset<T, SeminarInvitationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SeminarInvitationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SeminarInvitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeminarInvitationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SeminarInvitationAggregateArgs>(args: Subset<T, SeminarInvitationAggregateArgs>): Prisma.PrismaPromise<GetSeminarInvitationAggregateType<T>>

    /**
     * Group by SeminarInvitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeminarInvitationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SeminarInvitationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SeminarInvitationGroupByArgs['orderBy'] }
        : { orderBy?: SeminarInvitationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SeminarInvitationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSeminarInvitationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SeminarInvitation model
   */
  readonly fields: SeminarInvitationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SeminarInvitation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SeminarInvitationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    seminar<T extends SeminarDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SeminarDefaultArgs<ExtArgs>>): Prisma__SeminarClient<$Result.GetResult<Prisma.$SeminarPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SeminarInvitation model
   */ 
  interface SeminarInvitationFieldRefs {
    readonly id: FieldRef<"SeminarInvitation", 'Int'>
    readonly seminarId: FieldRef<"SeminarInvitation", 'Int'>
    readonly sent: FieldRef<"SeminarInvitation", 'Int'>
    readonly opened: FieldRef<"SeminarInvitation", 'Int'>
    readonly registered: FieldRef<"SeminarInvitation", 'Int'>
    readonly date: FieldRef<"SeminarInvitation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SeminarInvitation findUnique
   */
  export type SeminarInvitationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeminarInvitation
     */
    select?: SeminarInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeminarInvitationInclude<ExtArgs> | null
    /**
     * Filter, which SeminarInvitation to fetch.
     */
    where: SeminarInvitationWhereUniqueInput
  }

  /**
   * SeminarInvitation findUniqueOrThrow
   */
  export type SeminarInvitationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeminarInvitation
     */
    select?: SeminarInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeminarInvitationInclude<ExtArgs> | null
    /**
     * Filter, which SeminarInvitation to fetch.
     */
    where: SeminarInvitationWhereUniqueInput
  }

  /**
   * SeminarInvitation findFirst
   */
  export type SeminarInvitationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeminarInvitation
     */
    select?: SeminarInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeminarInvitationInclude<ExtArgs> | null
    /**
     * Filter, which SeminarInvitation to fetch.
     */
    where?: SeminarInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeminarInvitations to fetch.
     */
    orderBy?: SeminarInvitationOrderByWithRelationInput | SeminarInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SeminarInvitations.
     */
    cursor?: SeminarInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeminarInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeminarInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SeminarInvitations.
     */
    distinct?: SeminarInvitationScalarFieldEnum | SeminarInvitationScalarFieldEnum[]
  }

  /**
   * SeminarInvitation findFirstOrThrow
   */
  export type SeminarInvitationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeminarInvitation
     */
    select?: SeminarInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeminarInvitationInclude<ExtArgs> | null
    /**
     * Filter, which SeminarInvitation to fetch.
     */
    where?: SeminarInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeminarInvitations to fetch.
     */
    orderBy?: SeminarInvitationOrderByWithRelationInput | SeminarInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SeminarInvitations.
     */
    cursor?: SeminarInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeminarInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeminarInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SeminarInvitations.
     */
    distinct?: SeminarInvitationScalarFieldEnum | SeminarInvitationScalarFieldEnum[]
  }

  /**
   * SeminarInvitation findMany
   */
  export type SeminarInvitationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeminarInvitation
     */
    select?: SeminarInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeminarInvitationInclude<ExtArgs> | null
    /**
     * Filter, which SeminarInvitations to fetch.
     */
    where?: SeminarInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeminarInvitations to fetch.
     */
    orderBy?: SeminarInvitationOrderByWithRelationInput | SeminarInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SeminarInvitations.
     */
    cursor?: SeminarInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeminarInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeminarInvitations.
     */
    skip?: number
    distinct?: SeminarInvitationScalarFieldEnum | SeminarInvitationScalarFieldEnum[]
  }

  /**
   * SeminarInvitation create
   */
  export type SeminarInvitationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeminarInvitation
     */
    select?: SeminarInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeminarInvitationInclude<ExtArgs> | null
    /**
     * The data needed to create a SeminarInvitation.
     */
    data: XOR<SeminarInvitationCreateInput, SeminarInvitationUncheckedCreateInput>
  }

  /**
   * SeminarInvitation createMany
   */
  export type SeminarInvitationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SeminarInvitations.
     */
    data: SeminarInvitationCreateManyInput | SeminarInvitationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SeminarInvitation createManyAndReturn
   */
  export type SeminarInvitationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeminarInvitation
     */
    select?: SeminarInvitationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SeminarInvitations.
     */
    data: SeminarInvitationCreateManyInput | SeminarInvitationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeminarInvitationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SeminarInvitation update
   */
  export type SeminarInvitationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeminarInvitation
     */
    select?: SeminarInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeminarInvitationInclude<ExtArgs> | null
    /**
     * The data needed to update a SeminarInvitation.
     */
    data: XOR<SeminarInvitationUpdateInput, SeminarInvitationUncheckedUpdateInput>
    /**
     * Choose, which SeminarInvitation to update.
     */
    where: SeminarInvitationWhereUniqueInput
  }

  /**
   * SeminarInvitation updateMany
   */
  export type SeminarInvitationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SeminarInvitations.
     */
    data: XOR<SeminarInvitationUpdateManyMutationInput, SeminarInvitationUncheckedUpdateManyInput>
    /**
     * Filter which SeminarInvitations to update
     */
    where?: SeminarInvitationWhereInput
  }

  /**
   * SeminarInvitation upsert
   */
  export type SeminarInvitationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeminarInvitation
     */
    select?: SeminarInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeminarInvitationInclude<ExtArgs> | null
    /**
     * The filter to search for the SeminarInvitation to update in case it exists.
     */
    where: SeminarInvitationWhereUniqueInput
    /**
     * In case the SeminarInvitation found by the `where` argument doesn't exist, create a new SeminarInvitation with this data.
     */
    create: XOR<SeminarInvitationCreateInput, SeminarInvitationUncheckedCreateInput>
    /**
     * In case the SeminarInvitation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SeminarInvitationUpdateInput, SeminarInvitationUncheckedUpdateInput>
  }

  /**
   * SeminarInvitation delete
   */
  export type SeminarInvitationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeminarInvitation
     */
    select?: SeminarInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeminarInvitationInclude<ExtArgs> | null
    /**
     * Filter which SeminarInvitation to delete.
     */
    where: SeminarInvitationWhereUniqueInput
  }

  /**
   * SeminarInvitation deleteMany
   */
  export type SeminarInvitationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SeminarInvitations to delete
     */
    where?: SeminarInvitationWhereInput
  }

  /**
   * SeminarInvitation without action
   */
  export type SeminarInvitationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeminarInvitation
     */
    select?: SeminarInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeminarInvitationInclude<ExtArgs> | null
  }


  /**
   * Model SeminarSession
   */

  export type AggregateSeminarSession = {
    _count: SeminarSessionCountAggregateOutputType | null
    _avg: SeminarSessionAvgAggregateOutputType | null
    _sum: SeminarSessionSumAggregateOutputType | null
    _min: SeminarSessionMinAggregateOutputType | null
    _max: SeminarSessionMaxAggregateOutputType | null
  }

  export type SeminarSessionAvgAggregateOutputType = {
    id: number | null
    seminarId: number | null
  }

  export type SeminarSessionSumAggregateOutputType = {
    id: number | null
    seminarId: number | null
  }

  export type SeminarSessionMinAggregateOutputType = {
    id: number | null
    seminarId: number | null
    time: string | null
    topic: string | null
    speaker: string | null
  }

  export type SeminarSessionMaxAggregateOutputType = {
    id: number | null
    seminarId: number | null
    time: string | null
    topic: string | null
    speaker: string | null
  }

  export type SeminarSessionCountAggregateOutputType = {
    id: number
    seminarId: number
    time: number
    topic: number
    speaker: number
    _all: number
  }


  export type SeminarSessionAvgAggregateInputType = {
    id?: true
    seminarId?: true
  }

  export type SeminarSessionSumAggregateInputType = {
    id?: true
    seminarId?: true
  }

  export type SeminarSessionMinAggregateInputType = {
    id?: true
    seminarId?: true
    time?: true
    topic?: true
    speaker?: true
  }

  export type SeminarSessionMaxAggregateInputType = {
    id?: true
    seminarId?: true
    time?: true
    topic?: true
    speaker?: true
  }

  export type SeminarSessionCountAggregateInputType = {
    id?: true
    seminarId?: true
    time?: true
    topic?: true
    speaker?: true
    _all?: true
  }

  export type SeminarSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SeminarSession to aggregate.
     */
    where?: SeminarSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeminarSessions to fetch.
     */
    orderBy?: SeminarSessionOrderByWithRelationInput | SeminarSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SeminarSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeminarSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeminarSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SeminarSessions
    **/
    _count?: true | SeminarSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SeminarSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SeminarSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SeminarSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SeminarSessionMaxAggregateInputType
  }

  export type GetSeminarSessionAggregateType<T extends SeminarSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSeminarSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeminarSession[P]>
      : GetScalarType<T[P], AggregateSeminarSession[P]>
  }




  export type SeminarSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeminarSessionWhereInput
    orderBy?: SeminarSessionOrderByWithAggregationInput | SeminarSessionOrderByWithAggregationInput[]
    by: SeminarSessionScalarFieldEnum[] | SeminarSessionScalarFieldEnum
    having?: SeminarSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SeminarSessionCountAggregateInputType | true
    _avg?: SeminarSessionAvgAggregateInputType
    _sum?: SeminarSessionSumAggregateInputType
    _min?: SeminarSessionMinAggregateInputType
    _max?: SeminarSessionMaxAggregateInputType
  }

  export type SeminarSessionGroupByOutputType = {
    id: number
    seminarId: number
    time: string
    topic: string
    speaker: string
    _count: SeminarSessionCountAggregateOutputType | null
    _avg: SeminarSessionAvgAggregateOutputType | null
    _sum: SeminarSessionSumAggregateOutputType | null
    _min: SeminarSessionMinAggregateOutputType | null
    _max: SeminarSessionMaxAggregateOutputType | null
  }

  type GetSeminarSessionGroupByPayload<T extends SeminarSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SeminarSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SeminarSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SeminarSessionGroupByOutputType[P]>
            : GetScalarType<T[P], SeminarSessionGroupByOutputType[P]>
        }
      >
    >


  export type SeminarSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seminarId?: boolean
    time?: boolean
    topic?: boolean
    speaker?: boolean
    seminar?: boolean | SeminarDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["seminarSession"]>

  export type SeminarSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seminarId?: boolean
    time?: boolean
    topic?: boolean
    speaker?: boolean
    seminar?: boolean | SeminarDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["seminarSession"]>

  export type SeminarSessionSelectScalar = {
    id?: boolean
    seminarId?: boolean
    time?: boolean
    topic?: boolean
    speaker?: boolean
  }

  export type SeminarSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seminar?: boolean | SeminarDefaultArgs<ExtArgs>
  }
  export type SeminarSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seminar?: boolean | SeminarDefaultArgs<ExtArgs>
  }

  export type $SeminarSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SeminarSession"
    objects: {
      seminar: Prisma.$SeminarPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      seminarId: number
      time: string
      topic: string
      speaker: string
    }, ExtArgs["result"]["seminarSession"]>
    composites: {}
  }

  type SeminarSessionGetPayload<S extends boolean | null | undefined | SeminarSessionDefaultArgs> = $Result.GetResult<Prisma.$SeminarSessionPayload, S>

  type SeminarSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SeminarSessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SeminarSessionCountAggregateInputType | true
    }

  export interface SeminarSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SeminarSession'], meta: { name: 'SeminarSession' } }
    /**
     * Find zero or one SeminarSession that matches the filter.
     * @param {SeminarSessionFindUniqueArgs} args - Arguments to find a SeminarSession
     * @example
     * // Get one SeminarSession
     * const seminarSession = await prisma.seminarSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SeminarSessionFindUniqueArgs>(args: SelectSubset<T, SeminarSessionFindUniqueArgs<ExtArgs>>): Prisma__SeminarSessionClient<$Result.GetResult<Prisma.$SeminarSessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SeminarSession that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SeminarSessionFindUniqueOrThrowArgs} args - Arguments to find a SeminarSession
     * @example
     * // Get one SeminarSession
     * const seminarSession = await prisma.seminarSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SeminarSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SeminarSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SeminarSessionClient<$Result.GetResult<Prisma.$SeminarSessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SeminarSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeminarSessionFindFirstArgs} args - Arguments to find a SeminarSession
     * @example
     * // Get one SeminarSession
     * const seminarSession = await prisma.seminarSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SeminarSessionFindFirstArgs>(args?: SelectSubset<T, SeminarSessionFindFirstArgs<ExtArgs>>): Prisma__SeminarSessionClient<$Result.GetResult<Prisma.$SeminarSessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SeminarSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeminarSessionFindFirstOrThrowArgs} args - Arguments to find a SeminarSession
     * @example
     * // Get one SeminarSession
     * const seminarSession = await prisma.seminarSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SeminarSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SeminarSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SeminarSessionClient<$Result.GetResult<Prisma.$SeminarSessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SeminarSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeminarSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SeminarSessions
     * const seminarSessions = await prisma.seminarSession.findMany()
     * 
     * // Get first 10 SeminarSessions
     * const seminarSessions = await prisma.seminarSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const seminarSessionWithIdOnly = await prisma.seminarSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SeminarSessionFindManyArgs>(args?: SelectSubset<T, SeminarSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeminarSessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SeminarSession.
     * @param {SeminarSessionCreateArgs} args - Arguments to create a SeminarSession.
     * @example
     * // Create one SeminarSession
     * const SeminarSession = await prisma.seminarSession.create({
     *   data: {
     *     // ... data to create a SeminarSession
     *   }
     * })
     * 
     */
    create<T extends SeminarSessionCreateArgs>(args: SelectSubset<T, SeminarSessionCreateArgs<ExtArgs>>): Prisma__SeminarSessionClient<$Result.GetResult<Prisma.$SeminarSessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SeminarSessions.
     * @param {SeminarSessionCreateManyArgs} args - Arguments to create many SeminarSessions.
     * @example
     * // Create many SeminarSessions
     * const seminarSession = await prisma.seminarSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SeminarSessionCreateManyArgs>(args?: SelectSubset<T, SeminarSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SeminarSessions and returns the data saved in the database.
     * @param {SeminarSessionCreateManyAndReturnArgs} args - Arguments to create many SeminarSessions.
     * @example
     * // Create many SeminarSessions
     * const seminarSession = await prisma.seminarSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SeminarSessions and only return the `id`
     * const seminarSessionWithIdOnly = await prisma.seminarSession.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SeminarSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SeminarSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeminarSessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SeminarSession.
     * @param {SeminarSessionDeleteArgs} args - Arguments to delete one SeminarSession.
     * @example
     * // Delete one SeminarSession
     * const SeminarSession = await prisma.seminarSession.delete({
     *   where: {
     *     // ... filter to delete one SeminarSession
     *   }
     * })
     * 
     */
    delete<T extends SeminarSessionDeleteArgs>(args: SelectSubset<T, SeminarSessionDeleteArgs<ExtArgs>>): Prisma__SeminarSessionClient<$Result.GetResult<Prisma.$SeminarSessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SeminarSession.
     * @param {SeminarSessionUpdateArgs} args - Arguments to update one SeminarSession.
     * @example
     * // Update one SeminarSession
     * const seminarSession = await prisma.seminarSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SeminarSessionUpdateArgs>(args: SelectSubset<T, SeminarSessionUpdateArgs<ExtArgs>>): Prisma__SeminarSessionClient<$Result.GetResult<Prisma.$SeminarSessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SeminarSessions.
     * @param {SeminarSessionDeleteManyArgs} args - Arguments to filter SeminarSessions to delete.
     * @example
     * // Delete a few SeminarSessions
     * const { count } = await prisma.seminarSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SeminarSessionDeleteManyArgs>(args?: SelectSubset<T, SeminarSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SeminarSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeminarSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SeminarSessions
     * const seminarSession = await prisma.seminarSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SeminarSessionUpdateManyArgs>(args: SelectSubset<T, SeminarSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SeminarSession.
     * @param {SeminarSessionUpsertArgs} args - Arguments to update or create a SeminarSession.
     * @example
     * // Update or create a SeminarSession
     * const seminarSession = await prisma.seminarSession.upsert({
     *   create: {
     *     // ... data to create a SeminarSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SeminarSession we want to update
     *   }
     * })
     */
    upsert<T extends SeminarSessionUpsertArgs>(args: SelectSubset<T, SeminarSessionUpsertArgs<ExtArgs>>): Prisma__SeminarSessionClient<$Result.GetResult<Prisma.$SeminarSessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SeminarSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeminarSessionCountArgs} args - Arguments to filter SeminarSessions to count.
     * @example
     * // Count the number of SeminarSessions
     * const count = await prisma.seminarSession.count({
     *   where: {
     *     // ... the filter for the SeminarSessions we want to count
     *   }
     * })
    **/
    count<T extends SeminarSessionCountArgs>(
      args?: Subset<T, SeminarSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SeminarSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SeminarSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeminarSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SeminarSessionAggregateArgs>(args: Subset<T, SeminarSessionAggregateArgs>): Prisma.PrismaPromise<GetSeminarSessionAggregateType<T>>

    /**
     * Group by SeminarSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeminarSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SeminarSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SeminarSessionGroupByArgs['orderBy'] }
        : { orderBy?: SeminarSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SeminarSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSeminarSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SeminarSession model
   */
  readonly fields: SeminarSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SeminarSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SeminarSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    seminar<T extends SeminarDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SeminarDefaultArgs<ExtArgs>>): Prisma__SeminarClient<$Result.GetResult<Prisma.$SeminarPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SeminarSession model
   */ 
  interface SeminarSessionFieldRefs {
    readonly id: FieldRef<"SeminarSession", 'Int'>
    readonly seminarId: FieldRef<"SeminarSession", 'Int'>
    readonly time: FieldRef<"SeminarSession", 'String'>
    readonly topic: FieldRef<"SeminarSession", 'String'>
    readonly speaker: FieldRef<"SeminarSession", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SeminarSession findUnique
   */
  export type SeminarSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeminarSession
     */
    select?: SeminarSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeminarSessionInclude<ExtArgs> | null
    /**
     * Filter, which SeminarSession to fetch.
     */
    where: SeminarSessionWhereUniqueInput
  }

  /**
   * SeminarSession findUniqueOrThrow
   */
  export type SeminarSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeminarSession
     */
    select?: SeminarSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeminarSessionInclude<ExtArgs> | null
    /**
     * Filter, which SeminarSession to fetch.
     */
    where: SeminarSessionWhereUniqueInput
  }

  /**
   * SeminarSession findFirst
   */
  export type SeminarSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeminarSession
     */
    select?: SeminarSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeminarSessionInclude<ExtArgs> | null
    /**
     * Filter, which SeminarSession to fetch.
     */
    where?: SeminarSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeminarSessions to fetch.
     */
    orderBy?: SeminarSessionOrderByWithRelationInput | SeminarSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SeminarSessions.
     */
    cursor?: SeminarSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeminarSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeminarSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SeminarSessions.
     */
    distinct?: SeminarSessionScalarFieldEnum | SeminarSessionScalarFieldEnum[]
  }

  /**
   * SeminarSession findFirstOrThrow
   */
  export type SeminarSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeminarSession
     */
    select?: SeminarSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeminarSessionInclude<ExtArgs> | null
    /**
     * Filter, which SeminarSession to fetch.
     */
    where?: SeminarSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeminarSessions to fetch.
     */
    orderBy?: SeminarSessionOrderByWithRelationInput | SeminarSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SeminarSessions.
     */
    cursor?: SeminarSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeminarSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeminarSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SeminarSessions.
     */
    distinct?: SeminarSessionScalarFieldEnum | SeminarSessionScalarFieldEnum[]
  }

  /**
   * SeminarSession findMany
   */
  export type SeminarSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeminarSession
     */
    select?: SeminarSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeminarSessionInclude<ExtArgs> | null
    /**
     * Filter, which SeminarSessions to fetch.
     */
    where?: SeminarSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeminarSessions to fetch.
     */
    orderBy?: SeminarSessionOrderByWithRelationInput | SeminarSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SeminarSessions.
     */
    cursor?: SeminarSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeminarSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeminarSessions.
     */
    skip?: number
    distinct?: SeminarSessionScalarFieldEnum | SeminarSessionScalarFieldEnum[]
  }

  /**
   * SeminarSession create
   */
  export type SeminarSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeminarSession
     */
    select?: SeminarSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeminarSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a SeminarSession.
     */
    data: XOR<SeminarSessionCreateInput, SeminarSessionUncheckedCreateInput>
  }

  /**
   * SeminarSession createMany
   */
  export type SeminarSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SeminarSessions.
     */
    data: SeminarSessionCreateManyInput | SeminarSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SeminarSession createManyAndReturn
   */
  export type SeminarSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeminarSession
     */
    select?: SeminarSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SeminarSessions.
     */
    data: SeminarSessionCreateManyInput | SeminarSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeminarSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SeminarSession update
   */
  export type SeminarSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeminarSession
     */
    select?: SeminarSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeminarSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a SeminarSession.
     */
    data: XOR<SeminarSessionUpdateInput, SeminarSessionUncheckedUpdateInput>
    /**
     * Choose, which SeminarSession to update.
     */
    where: SeminarSessionWhereUniqueInput
  }

  /**
   * SeminarSession updateMany
   */
  export type SeminarSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SeminarSessions.
     */
    data: XOR<SeminarSessionUpdateManyMutationInput, SeminarSessionUncheckedUpdateManyInput>
    /**
     * Filter which SeminarSessions to update
     */
    where?: SeminarSessionWhereInput
  }

  /**
   * SeminarSession upsert
   */
  export type SeminarSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeminarSession
     */
    select?: SeminarSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeminarSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the SeminarSession to update in case it exists.
     */
    where: SeminarSessionWhereUniqueInput
    /**
     * In case the SeminarSession found by the `where` argument doesn't exist, create a new SeminarSession with this data.
     */
    create: XOR<SeminarSessionCreateInput, SeminarSessionUncheckedCreateInput>
    /**
     * In case the SeminarSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SeminarSessionUpdateInput, SeminarSessionUncheckedUpdateInput>
  }

  /**
   * SeminarSession delete
   */
  export type SeminarSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeminarSession
     */
    select?: SeminarSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeminarSessionInclude<ExtArgs> | null
    /**
     * Filter which SeminarSession to delete.
     */
    where: SeminarSessionWhereUniqueInput
  }

  /**
   * SeminarSession deleteMany
   */
  export type SeminarSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SeminarSessions to delete
     */
    where?: SeminarSessionWhereInput
  }

  /**
   * SeminarSession without action
   */
  export type SeminarSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeminarSession
     */
    select?: SeminarSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeminarSessionInclude<ExtArgs> | null
  }


  /**
   * Model SeminarSpeaker
   */

  export type AggregateSeminarSpeaker = {
    _count: SeminarSpeakerCountAggregateOutputType | null
    _avg: SeminarSpeakerAvgAggregateOutputType | null
    _sum: SeminarSpeakerSumAggregateOutputType | null
    _min: SeminarSpeakerMinAggregateOutputType | null
    _max: SeminarSpeakerMaxAggregateOutputType | null
  }

  export type SeminarSpeakerAvgAggregateOutputType = {
    id: number | null
    seminars: number | null
  }

  export type SeminarSpeakerSumAggregateOutputType = {
    id: number | null
    seminars: number | null
  }

  export type SeminarSpeakerMinAggregateOutputType = {
    id: number | null
    name: string | null
    title: string | null
    photo: string | null
    bio: string | null
    seminars: number | null
  }

  export type SeminarSpeakerMaxAggregateOutputType = {
    id: number | null
    name: string | null
    title: string | null
    photo: string | null
    bio: string | null
    seminars: number | null
  }

  export type SeminarSpeakerCountAggregateOutputType = {
    id: number
    name: number
    title: number
    photo: number
    bio: number
    seminars: number
    _all: number
  }


  export type SeminarSpeakerAvgAggregateInputType = {
    id?: true
    seminars?: true
  }

  export type SeminarSpeakerSumAggregateInputType = {
    id?: true
    seminars?: true
  }

  export type SeminarSpeakerMinAggregateInputType = {
    id?: true
    name?: true
    title?: true
    photo?: true
    bio?: true
    seminars?: true
  }

  export type SeminarSpeakerMaxAggregateInputType = {
    id?: true
    name?: true
    title?: true
    photo?: true
    bio?: true
    seminars?: true
  }

  export type SeminarSpeakerCountAggregateInputType = {
    id?: true
    name?: true
    title?: true
    photo?: true
    bio?: true
    seminars?: true
    _all?: true
  }

  export type SeminarSpeakerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SeminarSpeaker to aggregate.
     */
    where?: SeminarSpeakerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeminarSpeakers to fetch.
     */
    orderBy?: SeminarSpeakerOrderByWithRelationInput | SeminarSpeakerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SeminarSpeakerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeminarSpeakers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeminarSpeakers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SeminarSpeakers
    **/
    _count?: true | SeminarSpeakerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SeminarSpeakerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SeminarSpeakerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SeminarSpeakerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SeminarSpeakerMaxAggregateInputType
  }

  export type GetSeminarSpeakerAggregateType<T extends SeminarSpeakerAggregateArgs> = {
        [P in keyof T & keyof AggregateSeminarSpeaker]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeminarSpeaker[P]>
      : GetScalarType<T[P], AggregateSeminarSpeaker[P]>
  }




  export type SeminarSpeakerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeminarSpeakerWhereInput
    orderBy?: SeminarSpeakerOrderByWithAggregationInput | SeminarSpeakerOrderByWithAggregationInput[]
    by: SeminarSpeakerScalarFieldEnum[] | SeminarSpeakerScalarFieldEnum
    having?: SeminarSpeakerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SeminarSpeakerCountAggregateInputType | true
    _avg?: SeminarSpeakerAvgAggregateInputType
    _sum?: SeminarSpeakerSumAggregateInputType
    _min?: SeminarSpeakerMinAggregateInputType
    _max?: SeminarSpeakerMaxAggregateInputType
  }

  export type SeminarSpeakerGroupByOutputType = {
    id: number
    name: string
    title: string
    photo: string
    bio: string | null
    seminars: number
    _count: SeminarSpeakerCountAggregateOutputType | null
    _avg: SeminarSpeakerAvgAggregateOutputType | null
    _sum: SeminarSpeakerSumAggregateOutputType | null
    _min: SeminarSpeakerMinAggregateOutputType | null
    _max: SeminarSpeakerMaxAggregateOutputType | null
  }

  type GetSeminarSpeakerGroupByPayload<T extends SeminarSpeakerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SeminarSpeakerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SeminarSpeakerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SeminarSpeakerGroupByOutputType[P]>
            : GetScalarType<T[P], SeminarSpeakerGroupByOutputType[P]>
        }
      >
    >


  export type SeminarSpeakerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    title?: boolean
    photo?: boolean
    bio?: boolean
    seminars?: boolean
  }, ExtArgs["result"]["seminarSpeaker"]>

  export type SeminarSpeakerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    title?: boolean
    photo?: boolean
    bio?: boolean
    seminars?: boolean
  }, ExtArgs["result"]["seminarSpeaker"]>

  export type SeminarSpeakerSelectScalar = {
    id?: boolean
    name?: boolean
    title?: boolean
    photo?: boolean
    bio?: boolean
    seminars?: boolean
  }


  export type $SeminarSpeakerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SeminarSpeaker"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      title: string
      photo: string
      bio: string | null
      seminars: number
    }, ExtArgs["result"]["seminarSpeaker"]>
    composites: {}
  }

  type SeminarSpeakerGetPayload<S extends boolean | null | undefined | SeminarSpeakerDefaultArgs> = $Result.GetResult<Prisma.$SeminarSpeakerPayload, S>

  type SeminarSpeakerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SeminarSpeakerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SeminarSpeakerCountAggregateInputType | true
    }

  export interface SeminarSpeakerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SeminarSpeaker'], meta: { name: 'SeminarSpeaker' } }
    /**
     * Find zero or one SeminarSpeaker that matches the filter.
     * @param {SeminarSpeakerFindUniqueArgs} args - Arguments to find a SeminarSpeaker
     * @example
     * // Get one SeminarSpeaker
     * const seminarSpeaker = await prisma.seminarSpeaker.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SeminarSpeakerFindUniqueArgs>(args: SelectSubset<T, SeminarSpeakerFindUniqueArgs<ExtArgs>>): Prisma__SeminarSpeakerClient<$Result.GetResult<Prisma.$SeminarSpeakerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SeminarSpeaker that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SeminarSpeakerFindUniqueOrThrowArgs} args - Arguments to find a SeminarSpeaker
     * @example
     * // Get one SeminarSpeaker
     * const seminarSpeaker = await prisma.seminarSpeaker.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SeminarSpeakerFindUniqueOrThrowArgs>(args: SelectSubset<T, SeminarSpeakerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SeminarSpeakerClient<$Result.GetResult<Prisma.$SeminarSpeakerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SeminarSpeaker that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeminarSpeakerFindFirstArgs} args - Arguments to find a SeminarSpeaker
     * @example
     * // Get one SeminarSpeaker
     * const seminarSpeaker = await prisma.seminarSpeaker.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SeminarSpeakerFindFirstArgs>(args?: SelectSubset<T, SeminarSpeakerFindFirstArgs<ExtArgs>>): Prisma__SeminarSpeakerClient<$Result.GetResult<Prisma.$SeminarSpeakerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SeminarSpeaker that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeminarSpeakerFindFirstOrThrowArgs} args - Arguments to find a SeminarSpeaker
     * @example
     * // Get one SeminarSpeaker
     * const seminarSpeaker = await prisma.seminarSpeaker.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SeminarSpeakerFindFirstOrThrowArgs>(args?: SelectSubset<T, SeminarSpeakerFindFirstOrThrowArgs<ExtArgs>>): Prisma__SeminarSpeakerClient<$Result.GetResult<Prisma.$SeminarSpeakerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SeminarSpeakers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeminarSpeakerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SeminarSpeakers
     * const seminarSpeakers = await prisma.seminarSpeaker.findMany()
     * 
     * // Get first 10 SeminarSpeakers
     * const seminarSpeakers = await prisma.seminarSpeaker.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const seminarSpeakerWithIdOnly = await prisma.seminarSpeaker.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SeminarSpeakerFindManyArgs>(args?: SelectSubset<T, SeminarSpeakerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeminarSpeakerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SeminarSpeaker.
     * @param {SeminarSpeakerCreateArgs} args - Arguments to create a SeminarSpeaker.
     * @example
     * // Create one SeminarSpeaker
     * const SeminarSpeaker = await prisma.seminarSpeaker.create({
     *   data: {
     *     // ... data to create a SeminarSpeaker
     *   }
     * })
     * 
     */
    create<T extends SeminarSpeakerCreateArgs>(args: SelectSubset<T, SeminarSpeakerCreateArgs<ExtArgs>>): Prisma__SeminarSpeakerClient<$Result.GetResult<Prisma.$SeminarSpeakerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SeminarSpeakers.
     * @param {SeminarSpeakerCreateManyArgs} args - Arguments to create many SeminarSpeakers.
     * @example
     * // Create many SeminarSpeakers
     * const seminarSpeaker = await prisma.seminarSpeaker.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SeminarSpeakerCreateManyArgs>(args?: SelectSubset<T, SeminarSpeakerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SeminarSpeakers and returns the data saved in the database.
     * @param {SeminarSpeakerCreateManyAndReturnArgs} args - Arguments to create many SeminarSpeakers.
     * @example
     * // Create many SeminarSpeakers
     * const seminarSpeaker = await prisma.seminarSpeaker.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SeminarSpeakers and only return the `id`
     * const seminarSpeakerWithIdOnly = await prisma.seminarSpeaker.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SeminarSpeakerCreateManyAndReturnArgs>(args?: SelectSubset<T, SeminarSpeakerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeminarSpeakerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SeminarSpeaker.
     * @param {SeminarSpeakerDeleteArgs} args - Arguments to delete one SeminarSpeaker.
     * @example
     * // Delete one SeminarSpeaker
     * const SeminarSpeaker = await prisma.seminarSpeaker.delete({
     *   where: {
     *     // ... filter to delete one SeminarSpeaker
     *   }
     * })
     * 
     */
    delete<T extends SeminarSpeakerDeleteArgs>(args: SelectSubset<T, SeminarSpeakerDeleteArgs<ExtArgs>>): Prisma__SeminarSpeakerClient<$Result.GetResult<Prisma.$SeminarSpeakerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SeminarSpeaker.
     * @param {SeminarSpeakerUpdateArgs} args - Arguments to update one SeminarSpeaker.
     * @example
     * // Update one SeminarSpeaker
     * const seminarSpeaker = await prisma.seminarSpeaker.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SeminarSpeakerUpdateArgs>(args: SelectSubset<T, SeminarSpeakerUpdateArgs<ExtArgs>>): Prisma__SeminarSpeakerClient<$Result.GetResult<Prisma.$SeminarSpeakerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SeminarSpeakers.
     * @param {SeminarSpeakerDeleteManyArgs} args - Arguments to filter SeminarSpeakers to delete.
     * @example
     * // Delete a few SeminarSpeakers
     * const { count } = await prisma.seminarSpeaker.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SeminarSpeakerDeleteManyArgs>(args?: SelectSubset<T, SeminarSpeakerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SeminarSpeakers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeminarSpeakerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SeminarSpeakers
     * const seminarSpeaker = await prisma.seminarSpeaker.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SeminarSpeakerUpdateManyArgs>(args: SelectSubset<T, SeminarSpeakerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SeminarSpeaker.
     * @param {SeminarSpeakerUpsertArgs} args - Arguments to update or create a SeminarSpeaker.
     * @example
     * // Update or create a SeminarSpeaker
     * const seminarSpeaker = await prisma.seminarSpeaker.upsert({
     *   create: {
     *     // ... data to create a SeminarSpeaker
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SeminarSpeaker we want to update
     *   }
     * })
     */
    upsert<T extends SeminarSpeakerUpsertArgs>(args: SelectSubset<T, SeminarSpeakerUpsertArgs<ExtArgs>>): Prisma__SeminarSpeakerClient<$Result.GetResult<Prisma.$SeminarSpeakerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SeminarSpeakers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeminarSpeakerCountArgs} args - Arguments to filter SeminarSpeakers to count.
     * @example
     * // Count the number of SeminarSpeakers
     * const count = await prisma.seminarSpeaker.count({
     *   where: {
     *     // ... the filter for the SeminarSpeakers we want to count
     *   }
     * })
    **/
    count<T extends SeminarSpeakerCountArgs>(
      args?: Subset<T, SeminarSpeakerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SeminarSpeakerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SeminarSpeaker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeminarSpeakerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SeminarSpeakerAggregateArgs>(args: Subset<T, SeminarSpeakerAggregateArgs>): Prisma.PrismaPromise<GetSeminarSpeakerAggregateType<T>>

    /**
     * Group by SeminarSpeaker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeminarSpeakerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SeminarSpeakerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SeminarSpeakerGroupByArgs['orderBy'] }
        : { orderBy?: SeminarSpeakerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SeminarSpeakerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSeminarSpeakerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SeminarSpeaker model
   */
  readonly fields: SeminarSpeakerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SeminarSpeaker.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SeminarSpeakerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SeminarSpeaker model
   */ 
  interface SeminarSpeakerFieldRefs {
    readonly id: FieldRef<"SeminarSpeaker", 'Int'>
    readonly name: FieldRef<"SeminarSpeaker", 'String'>
    readonly title: FieldRef<"SeminarSpeaker", 'String'>
    readonly photo: FieldRef<"SeminarSpeaker", 'String'>
    readonly bio: FieldRef<"SeminarSpeaker", 'String'>
    readonly seminars: FieldRef<"SeminarSpeaker", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SeminarSpeaker findUnique
   */
  export type SeminarSpeakerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeminarSpeaker
     */
    select?: SeminarSpeakerSelect<ExtArgs> | null
    /**
     * Filter, which SeminarSpeaker to fetch.
     */
    where: SeminarSpeakerWhereUniqueInput
  }

  /**
   * SeminarSpeaker findUniqueOrThrow
   */
  export type SeminarSpeakerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeminarSpeaker
     */
    select?: SeminarSpeakerSelect<ExtArgs> | null
    /**
     * Filter, which SeminarSpeaker to fetch.
     */
    where: SeminarSpeakerWhereUniqueInput
  }

  /**
   * SeminarSpeaker findFirst
   */
  export type SeminarSpeakerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeminarSpeaker
     */
    select?: SeminarSpeakerSelect<ExtArgs> | null
    /**
     * Filter, which SeminarSpeaker to fetch.
     */
    where?: SeminarSpeakerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeminarSpeakers to fetch.
     */
    orderBy?: SeminarSpeakerOrderByWithRelationInput | SeminarSpeakerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SeminarSpeakers.
     */
    cursor?: SeminarSpeakerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeminarSpeakers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeminarSpeakers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SeminarSpeakers.
     */
    distinct?: SeminarSpeakerScalarFieldEnum | SeminarSpeakerScalarFieldEnum[]
  }

  /**
   * SeminarSpeaker findFirstOrThrow
   */
  export type SeminarSpeakerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeminarSpeaker
     */
    select?: SeminarSpeakerSelect<ExtArgs> | null
    /**
     * Filter, which SeminarSpeaker to fetch.
     */
    where?: SeminarSpeakerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeminarSpeakers to fetch.
     */
    orderBy?: SeminarSpeakerOrderByWithRelationInput | SeminarSpeakerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SeminarSpeakers.
     */
    cursor?: SeminarSpeakerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeminarSpeakers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeminarSpeakers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SeminarSpeakers.
     */
    distinct?: SeminarSpeakerScalarFieldEnum | SeminarSpeakerScalarFieldEnum[]
  }

  /**
   * SeminarSpeaker findMany
   */
  export type SeminarSpeakerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeminarSpeaker
     */
    select?: SeminarSpeakerSelect<ExtArgs> | null
    /**
     * Filter, which SeminarSpeakers to fetch.
     */
    where?: SeminarSpeakerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeminarSpeakers to fetch.
     */
    orderBy?: SeminarSpeakerOrderByWithRelationInput | SeminarSpeakerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SeminarSpeakers.
     */
    cursor?: SeminarSpeakerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeminarSpeakers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeminarSpeakers.
     */
    skip?: number
    distinct?: SeminarSpeakerScalarFieldEnum | SeminarSpeakerScalarFieldEnum[]
  }

  /**
   * SeminarSpeaker create
   */
  export type SeminarSpeakerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeminarSpeaker
     */
    select?: SeminarSpeakerSelect<ExtArgs> | null
    /**
     * The data needed to create a SeminarSpeaker.
     */
    data: XOR<SeminarSpeakerCreateInput, SeminarSpeakerUncheckedCreateInput>
  }

  /**
   * SeminarSpeaker createMany
   */
  export type SeminarSpeakerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SeminarSpeakers.
     */
    data: SeminarSpeakerCreateManyInput | SeminarSpeakerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SeminarSpeaker createManyAndReturn
   */
  export type SeminarSpeakerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeminarSpeaker
     */
    select?: SeminarSpeakerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SeminarSpeakers.
     */
    data: SeminarSpeakerCreateManyInput | SeminarSpeakerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SeminarSpeaker update
   */
  export type SeminarSpeakerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeminarSpeaker
     */
    select?: SeminarSpeakerSelect<ExtArgs> | null
    /**
     * The data needed to update a SeminarSpeaker.
     */
    data: XOR<SeminarSpeakerUpdateInput, SeminarSpeakerUncheckedUpdateInput>
    /**
     * Choose, which SeminarSpeaker to update.
     */
    where: SeminarSpeakerWhereUniqueInput
  }

  /**
   * SeminarSpeaker updateMany
   */
  export type SeminarSpeakerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SeminarSpeakers.
     */
    data: XOR<SeminarSpeakerUpdateManyMutationInput, SeminarSpeakerUncheckedUpdateManyInput>
    /**
     * Filter which SeminarSpeakers to update
     */
    where?: SeminarSpeakerWhereInput
  }

  /**
   * SeminarSpeaker upsert
   */
  export type SeminarSpeakerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeminarSpeaker
     */
    select?: SeminarSpeakerSelect<ExtArgs> | null
    /**
     * The filter to search for the SeminarSpeaker to update in case it exists.
     */
    where: SeminarSpeakerWhereUniqueInput
    /**
     * In case the SeminarSpeaker found by the `where` argument doesn't exist, create a new SeminarSpeaker with this data.
     */
    create: XOR<SeminarSpeakerCreateInput, SeminarSpeakerUncheckedCreateInput>
    /**
     * In case the SeminarSpeaker was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SeminarSpeakerUpdateInput, SeminarSpeakerUncheckedUpdateInput>
  }

  /**
   * SeminarSpeaker delete
   */
  export type SeminarSpeakerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeminarSpeaker
     */
    select?: SeminarSpeakerSelect<ExtArgs> | null
    /**
     * Filter which SeminarSpeaker to delete.
     */
    where: SeminarSpeakerWhereUniqueInput
  }

  /**
   * SeminarSpeaker deleteMany
   */
  export type SeminarSpeakerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SeminarSpeakers to delete
     */
    where?: SeminarSpeakerWhereInput
  }

  /**
   * SeminarSpeaker without action
   */
  export type SeminarSpeakerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeminarSpeaker
     */
    select?: SeminarSpeakerSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const SeminarScalarFieldEnum: {
    id: 'id',
    title: 'title',
    date: 'date',
    location: 'location',
    capacity: 'capacity',
    registrations: 'registrations',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SeminarScalarFieldEnum = (typeof SeminarScalarFieldEnum)[keyof typeof SeminarScalarFieldEnum]


  export const SeminarBannerScalarFieldEnum: {
    id: 'id',
    seminarId: 'seminarId',
    image: 'image',
    priority: 'priority'
  };

  export type SeminarBannerScalarFieldEnum = (typeof SeminarBannerScalarFieldEnum)[keyof typeof SeminarBannerScalarFieldEnum]


  export const SeminarAttendeeScalarFieldEnum: {
    id: 'id',
    seminarId: 'seminarId',
    name: 'name',
    email: 'email',
    phone: 'phone',
    checkedIn: 'checkedIn',
    checkinTime: 'checkinTime'
  };

  export type SeminarAttendeeScalarFieldEnum = (typeof SeminarAttendeeScalarFieldEnum)[keyof typeof SeminarAttendeeScalarFieldEnum]


  export const SeminarInvitationScalarFieldEnum: {
    id: 'id',
    seminarId: 'seminarId',
    sent: 'sent',
    opened: 'opened',
    registered: 'registered',
    date: 'date'
  };

  export type SeminarInvitationScalarFieldEnum = (typeof SeminarInvitationScalarFieldEnum)[keyof typeof SeminarInvitationScalarFieldEnum]


  export const SeminarSessionScalarFieldEnum: {
    id: 'id',
    seminarId: 'seminarId',
    time: 'time',
    topic: 'topic',
    speaker: 'speaker'
  };

  export type SeminarSessionScalarFieldEnum = (typeof SeminarSessionScalarFieldEnum)[keyof typeof SeminarSessionScalarFieldEnum]


  export const SeminarSpeakerScalarFieldEnum: {
    id: 'id',
    name: 'name',
    title: 'title',
    photo: 'photo',
    bio: 'bio',
    seminars: 'seminars'
  };

  export type SeminarSpeakerScalarFieldEnum = (typeof SeminarSpeakerScalarFieldEnum)[keyof typeof SeminarSpeakerScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type SeminarWhereInput = {
    AND?: SeminarWhereInput | SeminarWhereInput[]
    OR?: SeminarWhereInput[]
    NOT?: SeminarWhereInput | SeminarWhereInput[]
    id?: IntFilter<"Seminar"> | number
    title?: StringFilter<"Seminar"> | string
    date?: StringFilter<"Seminar"> | string
    location?: StringFilter<"Seminar"> | string
    capacity?: IntFilter<"Seminar"> | number
    registrations?: IntFilter<"Seminar"> | number
    status?: StringFilter<"Seminar"> | string
    createdAt?: DateTimeFilter<"Seminar"> | Date | string
    updatedAt?: DateTimeFilter<"Seminar"> | Date | string
    banners?: SeminarBannerListRelationFilter
    attendees?: SeminarAttendeeListRelationFilter
    invitations?: SeminarInvitationListRelationFilter
    sessions?: SeminarSessionListRelationFilter
  }

  export type SeminarOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    date?: SortOrder
    location?: SortOrder
    capacity?: SortOrder
    registrations?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    banners?: SeminarBannerOrderByRelationAggregateInput
    attendees?: SeminarAttendeeOrderByRelationAggregateInput
    invitations?: SeminarInvitationOrderByRelationAggregateInput
    sessions?: SeminarSessionOrderByRelationAggregateInput
  }

  export type SeminarWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SeminarWhereInput | SeminarWhereInput[]
    OR?: SeminarWhereInput[]
    NOT?: SeminarWhereInput | SeminarWhereInput[]
    title?: StringFilter<"Seminar"> | string
    date?: StringFilter<"Seminar"> | string
    location?: StringFilter<"Seminar"> | string
    capacity?: IntFilter<"Seminar"> | number
    registrations?: IntFilter<"Seminar"> | number
    status?: StringFilter<"Seminar"> | string
    createdAt?: DateTimeFilter<"Seminar"> | Date | string
    updatedAt?: DateTimeFilter<"Seminar"> | Date | string
    banners?: SeminarBannerListRelationFilter
    attendees?: SeminarAttendeeListRelationFilter
    invitations?: SeminarInvitationListRelationFilter
    sessions?: SeminarSessionListRelationFilter
  }, "id">

  export type SeminarOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    date?: SortOrder
    location?: SortOrder
    capacity?: SortOrder
    registrations?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SeminarCountOrderByAggregateInput
    _avg?: SeminarAvgOrderByAggregateInput
    _max?: SeminarMaxOrderByAggregateInput
    _min?: SeminarMinOrderByAggregateInput
    _sum?: SeminarSumOrderByAggregateInput
  }

  export type SeminarScalarWhereWithAggregatesInput = {
    AND?: SeminarScalarWhereWithAggregatesInput | SeminarScalarWhereWithAggregatesInput[]
    OR?: SeminarScalarWhereWithAggregatesInput[]
    NOT?: SeminarScalarWhereWithAggregatesInput | SeminarScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Seminar"> | number
    title?: StringWithAggregatesFilter<"Seminar"> | string
    date?: StringWithAggregatesFilter<"Seminar"> | string
    location?: StringWithAggregatesFilter<"Seminar"> | string
    capacity?: IntWithAggregatesFilter<"Seminar"> | number
    registrations?: IntWithAggregatesFilter<"Seminar"> | number
    status?: StringWithAggregatesFilter<"Seminar"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Seminar"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Seminar"> | Date | string
  }

  export type SeminarBannerWhereInput = {
    AND?: SeminarBannerWhereInput | SeminarBannerWhereInput[]
    OR?: SeminarBannerWhereInput[]
    NOT?: SeminarBannerWhereInput | SeminarBannerWhereInput[]
    id?: IntFilter<"SeminarBanner"> | number
    seminarId?: IntFilter<"SeminarBanner"> | number
    image?: StringFilter<"SeminarBanner"> | string
    priority?: IntFilter<"SeminarBanner"> | number
    seminar?: XOR<SeminarRelationFilter, SeminarWhereInput>
  }

  export type SeminarBannerOrderByWithRelationInput = {
    id?: SortOrder
    seminarId?: SortOrder
    image?: SortOrder
    priority?: SortOrder
    seminar?: SeminarOrderByWithRelationInput
  }

  export type SeminarBannerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SeminarBannerWhereInput | SeminarBannerWhereInput[]
    OR?: SeminarBannerWhereInput[]
    NOT?: SeminarBannerWhereInput | SeminarBannerWhereInput[]
    seminarId?: IntFilter<"SeminarBanner"> | number
    image?: StringFilter<"SeminarBanner"> | string
    priority?: IntFilter<"SeminarBanner"> | number
    seminar?: XOR<SeminarRelationFilter, SeminarWhereInput>
  }, "id">

  export type SeminarBannerOrderByWithAggregationInput = {
    id?: SortOrder
    seminarId?: SortOrder
    image?: SortOrder
    priority?: SortOrder
    _count?: SeminarBannerCountOrderByAggregateInput
    _avg?: SeminarBannerAvgOrderByAggregateInput
    _max?: SeminarBannerMaxOrderByAggregateInput
    _min?: SeminarBannerMinOrderByAggregateInput
    _sum?: SeminarBannerSumOrderByAggregateInput
  }

  export type SeminarBannerScalarWhereWithAggregatesInput = {
    AND?: SeminarBannerScalarWhereWithAggregatesInput | SeminarBannerScalarWhereWithAggregatesInput[]
    OR?: SeminarBannerScalarWhereWithAggregatesInput[]
    NOT?: SeminarBannerScalarWhereWithAggregatesInput | SeminarBannerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SeminarBanner"> | number
    seminarId?: IntWithAggregatesFilter<"SeminarBanner"> | number
    image?: StringWithAggregatesFilter<"SeminarBanner"> | string
    priority?: IntWithAggregatesFilter<"SeminarBanner"> | number
  }

  export type SeminarAttendeeWhereInput = {
    AND?: SeminarAttendeeWhereInput | SeminarAttendeeWhereInput[]
    OR?: SeminarAttendeeWhereInput[]
    NOT?: SeminarAttendeeWhereInput | SeminarAttendeeWhereInput[]
    id?: IntFilter<"SeminarAttendee"> | number
    seminarId?: IntFilter<"SeminarAttendee"> | number
    name?: StringFilter<"SeminarAttendee"> | string
    email?: StringFilter<"SeminarAttendee"> | string
    phone?: StringFilter<"SeminarAttendee"> | string
    checkedIn?: BoolFilter<"SeminarAttendee"> | boolean
    checkinTime?: StringNullableFilter<"SeminarAttendee"> | string | null
    seminar?: XOR<SeminarRelationFilter, SeminarWhereInput>
  }

  export type SeminarAttendeeOrderByWithRelationInput = {
    id?: SortOrder
    seminarId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    checkedIn?: SortOrder
    checkinTime?: SortOrderInput | SortOrder
    seminar?: SeminarOrderByWithRelationInput
  }

  export type SeminarAttendeeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SeminarAttendeeWhereInput | SeminarAttendeeWhereInput[]
    OR?: SeminarAttendeeWhereInput[]
    NOT?: SeminarAttendeeWhereInput | SeminarAttendeeWhereInput[]
    seminarId?: IntFilter<"SeminarAttendee"> | number
    name?: StringFilter<"SeminarAttendee"> | string
    email?: StringFilter<"SeminarAttendee"> | string
    phone?: StringFilter<"SeminarAttendee"> | string
    checkedIn?: BoolFilter<"SeminarAttendee"> | boolean
    checkinTime?: StringNullableFilter<"SeminarAttendee"> | string | null
    seminar?: XOR<SeminarRelationFilter, SeminarWhereInput>
  }, "id">

  export type SeminarAttendeeOrderByWithAggregationInput = {
    id?: SortOrder
    seminarId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    checkedIn?: SortOrder
    checkinTime?: SortOrderInput | SortOrder
    _count?: SeminarAttendeeCountOrderByAggregateInput
    _avg?: SeminarAttendeeAvgOrderByAggregateInput
    _max?: SeminarAttendeeMaxOrderByAggregateInput
    _min?: SeminarAttendeeMinOrderByAggregateInput
    _sum?: SeminarAttendeeSumOrderByAggregateInput
  }

  export type SeminarAttendeeScalarWhereWithAggregatesInput = {
    AND?: SeminarAttendeeScalarWhereWithAggregatesInput | SeminarAttendeeScalarWhereWithAggregatesInput[]
    OR?: SeminarAttendeeScalarWhereWithAggregatesInput[]
    NOT?: SeminarAttendeeScalarWhereWithAggregatesInput | SeminarAttendeeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SeminarAttendee"> | number
    seminarId?: IntWithAggregatesFilter<"SeminarAttendee"> | number
    name?: StringWithAggregatesFilter<"SeminarAttendee"> | string
    email?: StringWithAggregatesFilter<"SeminarAttendee"> | string
    phone?: StringWithAggregatesFilter<"SeminarAttendee"> | string
    checkedIn?: BoolWithAggregatesFilter<"SeminarAttendee"> | boolean
    checkinTime?: StringNullableWithAggregatesFilter<"SeminarAttendee"> | string | null
  }

  export type SeminarInvitationWhereInput = {
    AND?: SeminarInvitationWhereInput | SeminarInvitationWhereInput[]
    OR?: SeminarInvitationWhereInput[]
    NOT?: SeminarInvitationWhereInput | SeminarInvitationWhereInput[]
    id?: IntFilter<"SeminarInvitation"> | number
    seminarId?: IntFilter<"SeminarInvitation"> | number
    sent?: IntFilter<"SeminarInvitation"> | number
    opened?: IntFilter<"SeminarInvitation"> | number
    registered?: IntFilter<"SeminarInvitation"> | number
    date?: StringFilter<"SeminarInvitation"> | string
    seminar?: XOR<SeminarRelationFilter, SeminarWhereInput>
  }

  export type SeminarInvitationOrderByWithRelationInput = {
    id?: SortOrder
    seminarId?: SortOrder
    sent?: SortOrder
    opened?: SortOrder
    registered?: SortOrder
    date?: SortOrder
    seminar?: SeminarOrderByWithRelationInput
  }

  export type SeminarInvitationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SeminarInvitationWhereInput | SeminarInvitationWhereInput[]
    OR?: SeminarInvitationWhereInput[]
    NOT?: SeminarInvitationWhereInput | SeminarInvitationWhereInput[]
    seminarId?: IntFilter<"SeminarInvitation"> | number
    sent?: IntFilter<"SeminarInvitation"> | number
    opened?: IntFilter<"SeminarInvitation"> | number
    registered?: IntFilter<"SeminarInvitation"> | number
    date?: StringFilter<"SeminarInvitation"> | string
    seminar?: XOR<SeminarRelationFilter, SeminarWhereInput>
  }, "id">

  export type SeminarInvitationOrderByWithAggregationInput = {
    id?: SortOrder
    seminarId?: SortOrder
    sent?: SortOrder
    opened?: SortOrder
    registered?: SortOrder
    date?: SortOrder
    _count?: SeminarInvitationCountOrderByAggregateInput
    _avg?: SeminarInvitationAvgOrderByAggregateInput
    _max?: SeminarInvitationMaxOrderByAggregateInput
    _min?: SeminarInvitationMinOrderByAggregateInput
    _sum?: SeminarInvitationSumOrderByAggregateInput
  }

  export type SeminarInvitationScalarWhereWithAggregatesInput = {
    AND?: SeminarInvitationScalarWhereWithAggregatesInput | SeminarInvitationScalarWhereWithAggregatesInput[]
    OR?: SeminarInvitationScalarWhereWithAggregatesInput[]
    NOT?: SeminarInvitationScalarWhereWithAggregatesInput | SeminarInvitationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SeminarInvitation"> | number
    seminarId?: IntWithAggregatesFilter<"SeminarInvitation"> | number
    sent?: IntWithAggregatesFilter<"SeminarInvitation"> | number
    opened?: IntWithAggregatesFilter<"SeminarInvitation"> | number
    registered?: IntWithAggregatesFilter<"SeminarInvitation"> | number
    date?: StringWithAggregatesFilter<"SeminarInvitation"> | string
  }

  export type SeminarSessionWhereInput = {
    AND?: SeminarSessionWhereInput | SeminarSessionWhereInput[]
    OR?: SeminarSessionWhereInput[]
    NOT?: SeminarSessionWhereInput | SeminarSessionWhereInput[]
    id?: IntFilter<"SeminarSession"> | number
    seminarId?: IntFilter<"SeminarSession"> | number
    time?: StringFilter<"SeminarSession"> | string
    topic?: StringFilter<"SeminarSession"> | string
    speaker?: StringFilter<"SeminarSession"> | string
    seminar?: XOR<SeminarRelationFilter, SeminarWhereInput>
  }

  export type SeminarSessionOrderByWithRelationInput = {
    id?: SortOrder
    seminarId?: SortOrder
    time?: SortOrder
    topic?: SortOrder
    speaker?: SortOrder
    seminar?: SeminarOrderByWithRelationInput
  }

  export type SeminarSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SeminarSessionWhereInput | SeminarSessionWhereInput[]
    OR?: SeminarSessionWhereInput[]
    NOT?: SeminarSessionWhereInput | SeminarSessionWhereInput[]
    seminarId?: IntFilter<"SeminarSession"> | number
    time?: StringFilter<"SeminarSession"> | string
    topic?: StringFilter<"SeminarSession"> | string
    speaker?: StringFilter<"SeminarSession"> | string
    seminar?: XOR<SeminarRelationFilter, SeminarWhereInput>
  }, "id">

  export type SeminarSessionOrderByWithAggregationInput = {
    id?: SortOrder
    seminarId?: SortOrder
    time?: SortOrder
    topic?: SortOrder
    speaker?: SortOrder
    _count?: SeminarSessionCountOrderByAggregateInput
    _avg?: SeminarSessionAvgOrderByAggregateInput
    _max?: SeminarSessionMaxOrderByAggregateInput
    _min?: SeminarSessionMinOrderByAggregateInput
    _sum?: SeminarSessionSumOrderByAggregateInput
  }

  export type SeminarSessionScalarWhereWithAggregatesInput = {
    AND?: SeminarSessionScalarWhereWithAggregatesInput | SeminarSessionScalarWhereWithAggregatesInput[]
    OR?: SeminarSessionScalarWhereWithAggregatesInput[]
    NOT?: SeminarSessionScalarWhereWithAggregatesInput | SeminarSessionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SeminarSession"> | number
    seminarId?: IntWithAggregatesFilter<"SeminarSession"> | number
    time?: StringWithAggregatesFilter<"SeminarSession"> | string
    topic?: StringWithAggregatesFilter<"SeminarSession"> | string
    speaker?: StringWithAggregatesFilter<"SeminarSession"> | string
  }

  export type SeminarSpeakerWhereInput = {
    AND?: SeminarSpeakerWhereInput | SeminarSpeakerWhereInput[]
    OR?: SeminarSpeakerWhereInput[]
    NOT?: SeminarSpeakerWhereInput | SeminarSpeakerWhereInput[]
    id?: IntFilter<"SeminarSpeaker"> | number
    name?: StringFilter<"SeminarSpeaker"> | string
    title?: StringFilter<"SeminarSpeaker"> | string
    photo?: StringFilter<"SeminarSpeaker"> | string
    bio?: StringNullableFilter<"SeminarSpeaker"> | string | null
    seminars?: IntFilter<"SeminarSpeaker"> | number
  }

  export type SeminarSpeakerOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    title?: SortOrder
    photo?: SortOrder
    bio?: SortOrderInput | SortOrder
    seminars?: SortOrder
  }

  export type SeminarSpeakerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SeminarSpeakerWhereInput | SeminarSpeakerWhereInput[]
    OR?: SeminarSpeakerWhereInput[]
    NOT?: SeminarSpeakerWhereInput | SeminarSpeakerWhereInput[]
    name?: StringFilter<"SeminarSpeaker"> | string
    title?: StringFilter<"SeminarSpeaker"> | string
    photo?: StringFilter<"SeminarSpeaker"> | string
    bio?: StringNullableFilter<"SeminarSpeaker"> | string | null
    seminars?: IntFilter<"SeminarSpeaker"> | number
  }, "id">

  export type SeminarSpeakerOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    title?: SortOrder
    photo?: SortOrder
    bio?: SortOrderInput | SortOrder
    seminars?: SortOrder
    _count?: SeminarSpeakerCountOrderByAggregateInput
    _avg?: SeminarSpeakerAvgOrderByAggregateInput
    _max?: SeminarSpeakerMaxOrderByAggregateInput
    _min?: SeminarSpeakerMinOrderByAggregateInput
    _sum?: SeminarSpeakerSumOrderByAggregateInput
  }

  export type SeminarSpeakerScalarWhereWithAggregatesInput = {
    AND?: SeminarSpeakerScalarWhereWithAggregatesInput | SeminarSpeakerScalarWhereWithAggregatesInput[]
    OR?: SeminarSpeakerScalarWhereWithAggregatesInput[]
    NOT?: SeminarSpeakerScalarWhereWithAggregatesInput | SeminarSpeakerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SeminarSpeaker"> | number
    name?: StringWithAggregatesFilter<"SeminarSpeaker"> | string
    title?: StringWithAggregatesFilter<"SeminarSpeaker"> | string
    photo?: StringWithAggregatesFilter<"SeminarSpeaker"> | string
    bio?: StringNullableWithAggregatesFilter<"SeminarSpeaker"> | string | null
    seminars?: IntWithAggregatesFilter<"SeminarSpeaker"> | number
  }

  export type SeminarCreateInput = {
    title: string
    date: string
    location: string
    capacity: number
    registrations?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    banners?: SeminarBannerCreateNestedManyWithoutSeminarInput
    attendees?: SeminarAttendeeCreateNestedManyWithoutSeminarInput
    invitations?: SeminarInvitationCreateNestedManyWithoutSeminarInput
    sessions?: SeminarSessionCreateNestedManyWithoutSeminarInput
  }

  export type SeminarUncheckedCreateInput = {
    id?: number
    title: string
    date: string
    location: string
    capacity: number
    registrations?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    banners?: SeminarBannerUncheckedCreateNestedManyWithoutSeminarInput
    attendees?: SeminarAttendeeUncheckedCreateNestedManyWithoutSeminarInput
    invitations?: SeminarInvitationUncheckedCreateNestedManyWithoutSeminarInput
    sessions?: SeminarSessionUncheckedCreateNestedManyWithoutSeminarInput
  }

  export type SeminarUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    registrations?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    banners?: SeminarBannerUpdateManyWithoutSeminarNestedInput
    attendees?: SeminarAttendeeUpdateManyWithoutSeminarNestedInput
    invitations?: SeminarInvitationUpdateManyWithoutSeminarNestedInput
    sessions?: SeminarSessionUpdateManyWithoutSeminarNestedInput
  }

  export type SeminarUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    registrations?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    banners?: SeminarBannerUncheckedUpdateManyWithoutSeminarNestedInput
    attendees?: SeminarAttendeeUncheckedUpdateManyWithoutSeminarNestedInput
    invitations?: SeminarInvitationUncheckedUpdateManyWithoutSeminarNestedInput
    sessions?: SeminarSessionUncheckedUpdateManyWithoutSeminarNestedInput
  }

  export type SeminarCreateManyInput = {
    id?: number
    title: string
    date: string
    location: string
    capacity: number
    registrations?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SeminarUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    registrations?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeminarUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    registrations?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeminarBannerCreateInput = {
    image: string
    priority?: number
    seminar: SeminarCreateNestedOneWithoutBannersInput
  }

  export type SeminarBannerUncheckedCreateInput = {
    id?: number
    seminarId: number
    image: string
    priority?: number
  }

  export type SeminarBannerUpdateInput = {
    image?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    seminar?: SeminarUpdateOneRequiredWithoutBannersNestedInput
  }

  export type SeminarBannerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    seminarId?: IntFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
  }

  export type SeminarBannerCreateManyInput = {
    id?: number
    seminarId: number
    image: string
    priority?: number
  }

  export type SeminarBannerUpdateManyMutationInput = {
    image?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
  }

  export type SeminarBannerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    seminarId?: IntFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
  }

  export type SeminarAttendeeCreateInput = {
    name: string
    email: string
    phone: string
    checkedIn?: boolean
    checkinTime?: string | null
    seminar: SeminarCreateNestedOneWithoutAttendeesInput
  }

  export type SeminarAttendeeUncheckedCreateInput = {
    id?: number
    seminarId: number
    name: string
    email: string
    phone: string
    checkedIn?: boolean
    checkinTime?: string | null
  }

  export type SeminarAttendeeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    checkedIn?: BoolFieldUpdateOperationsInput | boolean
    checkinTime?: NullableStringFieldUpdateOperationsInput | string | null
    seminar?: SeminarUpdateOneRequiredWithoutAttendeesNestedInput
  }

  export type SeminarAttendeeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    seminarId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    checkedIn?: BoolFieldUpdateOperationsInput | boolean
    checkinTime?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SeminarAttendeeCreateManyInput = {
    id?: number
    seminarId: number
    name: string
    email: string
    phone: string
    checkedIn?: boolean
    checkinTime?: string | null
  }

  export type SeminarAttendeeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    checkedIn?: BoolFieldUpdateOperationsInput | boolean
    checkinTime?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SeminarAttendeeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    seminarId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    checkedIn?: BoolFieldUpdateOperationsInput | boolean
    checkinTime?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SeminarInvitationCreateInput = {
    sent?: number
    opened?: number
    registered?: number
    date: string
    seminar: SeminarCreateNestedOneWithoutInvitationsInput
  }

  export type SeminarInvitationUncheckedCreateInput = {
    id?: number
    seminarId: number
    sent?: number
    opened?: number
    registered?: number
    date: string
  }

  export type SeminarInvitationUpdateInput = {
    sent?: IntFieldUpdateOperationsInput | number
    opened?: IntFieldUpdateOperationsInput | number
    registered?: IntFieldUpdateOperationsInput | number
    date?: StringFieldUpdateOperationsInput | string
    seminar?: SeminarUpdateOneRequiredWithoutInvitationsNestedInput
  }

  export type SeminarInvitationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    seminarId?: IntFieldUpdateOperationsInput | number
    sent?: IntFieldUpdateOperationsInput | number
    opened?: IntFieldUpdateOperationsInput | number
    registered?: IntFieldUpdateOperationsInput | number
    date?: StringFieldUpdateOperationsInput | string
  }

  export type SeminarInvitationCreateManyInput = {
    id?: number
    seminarId: number
    sent?: number
    opened?: number
    registered?: number
    date: string
  }

  export type SeminarInvitationUpdateManyMutationInput = {
    sent?: IntFieldUpdateOperationsInput | number
    opened?: IntFieldUpdateOperationsInput | number
    registered?: IntFieldUpdateOperationsInput | number
    date?: StringFieldUpdateOperationsInput | string
  }

  export type SeminarInvitationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    seminarId?: IntFieldUpdateOperationsInput | number
    sent?: IntFieldUpdateOperationsInput | number
    opened?: IntFieldUpdateOperationsInput | number
    registered?: IntFieldUpdateOperationsInput | number
    date?: StringFieldUpdateOperationsInput | string
  }

  export type SeminarSessionCreateInput = {
    time: string
    topic: string
    speaker: string
    seminar: SeminarCreateNestedOneWithoutSessionsInput
  }

  export type SeminarSessionUncheckedCreateInput = {
    id?: number
    seminarId: number
    time: string
    topic: string
    speaker: string
  }

  export type SeminarSessionUpdateInput = {
    time?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    speaker?: StringFieldUpdateOperationsInput | string
    seminar?: SeminarUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SeminarSessionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    seminarId?: IntFieldUpdateOperationsInput | number
    time?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    speaker?: StringFieldUpdateOperationsInput | string
  }

  export type SeminarSessionCreateManyInput = {
    id?: number
    seminarId: number
    time: string
    topic: string
    speaker: string
  }

  export type SeminarSessionUpdateManyMutationInput = {
    time?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    speaker?: StringFieldUpdateOperationsInput | string
  }

  export type SeminarSessionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    seminarId?: IntFieldUpdateOperationsInput | number
    time?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    speaker?: StringFieldUpdateOperationsInput | string
  }

  export type SeminarSpeakerCreateInput = {
    name: string
    title: string
    photo: string
    bio?: string | null
    seminars?: number
  }

  export type SeminarSpeakerUncheckedCreateInput = {
    id?: number
    name: string
    title: string
    photo: string
    bio?: string | null
    seminars?: number
  }

  export type SeminarSpeakerUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    seminars?: IntFieldUpdateOperationsInput | number
  }

  export type SeminarSpeakerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    seminars?: IntFieldUpdateOperationsInput | number
  }

  export type SeminarSpeakerCreateManyInput = {
    id?: number
    name: string
    title: string
    photo: string
    bio?: string | null
    seminars?: number
  }

  export type SeminarSpeakerUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    seminars?: IntFieldUpdateOperationsInput | number
  }

  export type SeminarSpeakerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    seminars?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SeminarBannerListRelationFilter = {
    every?: SeminarBannerWhereInput
    some?: SeminarBannerWhereInput
    none?: SeminarBannerWhereInput
  }

  export type SeminarAttendeeListRelationFilter = {
    every?: SeminarAttendeeWhereInput
    some?: SeminarAttendeeWhereInput
    none?: SeminarAttendeeWhereInput
  }

  export type SeminarInvitationListRelationFilter = {
    every?: SeminarInvitationWhereInput
    some?: SeminarInvitationWhereInput
    none?: SeminarInvitationWhereInput
  }

  export type SeminarSessionListRelationFilter = {
    every?: SeminarSessionWhereInput
    some?: SeminarSessionWhereInput
    none?: SeminarSessionWhereInput
  }

  export type SeminarBannerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SeminarAttendeeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SeminarInvitationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SeminarSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SeminarCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    date?: SortOrder
    location?: SortOrder
    capacity?: SortOrder
    registrations?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SeminarAvgOrderByAggregateInput = {
    id?: SortOrder
    capacity?: SortOrder
    registrations?: SortOrder
  }

  export type SeminarMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    date?: SortOrder
    location?: SortOrder
    capacity?: SortOrder
    registrations?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SeminarMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    date?: SortOrder
    location?: SortOrder
    capacity?: SortOrder
    registrations?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SeminarSumOrderByAggregateInput = {
    id?: SortOrder
    capacity?: SortOrder
    registrations?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type SeminarRelationFilter = {
    is?: SeminarWhereInput
    isNot?: SeminarWhereInput
  }

  export type SeminarBannerCountOrderByAggregateInput = {
    id?: SortOrder
    seminarId?: SortOrder
    image?: SortOrder
    priority?: SortOrder
  }

  export type SeminarBannerAvgOrderByAggregateInput = {
    id?: SortOrder
    seminarId?: SortOrder
    priority?: SortOrder
  }

  export type SeminarBannerMaxOrderByAggregateInput = {
    id?: SortOrder
    seminarId?: SortOrder
    image?: SortOrder
    priority?: SortOrder
  }

  export type SeminarBannerMinOrderByAggregateInput = {
    id?: SortOrder
    seminarId?: SortOrder
    image?: SortOrder
    priority?: SortOrder
  }

  export type SeminarBannerSumOrderByAggregateInput = {
    id?: SortOrder
    seminarId?: SortOrder
    priority?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type SeminarAttendeeCountOrderByAggregateInput = {
    id?: SortOrder
    seminarId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    checkedIn?: SortOrder
    checkinTime?: SortOrder
  }

  export type SeminarAttendeeAvgOrderByAggregateInput = {
    id?: SortOrder
    seminarId?: SortOrder
  }

  export type SeminarAttendeeMaxOrderByAggregateInput = {
    id?: SortOrder
    seminarId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    checkedIn?: SortOrder
    checkinTime?: SortOrder
  }

  export type SeminarAttendeeMinOrderByAggregateInput = {
    id?: SortOrder
    seminarId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    checkedIn?: SortOrder
    checkinTime?: SortOrder
  }

  export type SeminarAttendeeSumOrderByAggregateInput = {
    id?: SortOrder
    seminarId?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type SeminarInvitationCountOrderByAggregateInput = {
    id?: SortOrder
    seminarId?: SortOrder
    sent?: SortOrder
    opened?: SortOrder
    registered?: SortOrder
    date?: SortOrder
  }

  export type SeminarInvitationAvgOrderByAggregateInput = {
    id?: SortOrder
    seminarId?: SortOrder
    sent?: SortOrder
    opened?: SortOrder
    registered?: SortOrder
  }

  export type SeminarInvitationMaxOrderByAggregateInput = {
    id?: SortOrder
    seminarId?: SortOrder
    sent?: SortOrder
    opened?: SortOrder
    registered?: SortOrder
    date?: SortOrder
  }

  export type SeminarInvitationMinOrderByAggregateInput = {
    id?: SortOrder
    seminarId?: SortOrder
    sent?: SortOrder
    opened?: SortOrder
    registered?: SortOrder
    date?: SortOrder
  }

  export type SeminarInvitationSumOrderByAggregateInput = {
    id?: SortOrder
    seminarId?: SortOrder
    sent?: SortOrder
    opened?: SortOrder
    registered?: SortOrder
  }

  export type SeminarSessionCountOrderByAggregateInput = {
    id?: SortOrder
    seminarId?: SortOrder
    time?: SortOrder
    topic?: SortOrder
    speaker?: SortOrder
  }

  export type SeminarSessionAvgOrderByAggregateInput = {
    id?: SortOrder
    seminarId?: SortOrder
  }

  export type SeminarSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    seminarId?: SortOrder
    time?: SortOrder
    topic?: SortOrder
    speaker?: SortOrder
  }

  export type SeminarSessionMinOrderByAggregateInput = {
    id?: SortOrder
    seminarId?: SortOrder
    time?: SortOrder
    topic?: SortOrder
    speaker?: SortOrder
  }

  export type SeminarSessionSumOrderByAggregateInput = {
    id?: SortOrder
    seminarId?: SortOrder
  }

  export type SeminarSpeakerCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    title?: SortOrder
    photo?: SortOrder
    bio?: SortOrder
    seminars?: SortOrder
  }

  export type SeminarSpeakerAvgOrderByAggregateInput = {
    id?: SortOrder
    seminars?: SortOrder
  }

  export type SeminarSpeakerMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    title?: SortOrder
    photo?: SortOrder
    bio?: SortOrder
    seminars?: SortOrder
  }

  export type SeminarSpeakerMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    title?: SortOrder
    photo?: SortOrder
    bio?: SortOrder
    seminars?: SortOrder
  }

  export type SeminarSpeakerSumOrderByAggregateInput = {
    id?: SortOrder
    seminars?: SortOrder
  }

  export type SeminarBannerCreateNestedManyWithoutSeminarInput = {
    create?: XOR<SeminarBannerCreateWithoutSeminarInput, SeminarBannerUncheckedCreateWithoutSeminarInput> | SeminarBannerCreateWithoutSeminarInput[] | SeminarBannerUncheckedCreateWithoutSeminarInput[]
    connectOrCreate?: SeminarBannerCreateOrConnectWithoutSeminarInput | SeminarBannerCreateOrConnectWithoutSeminarInput[]
    createMany?: SeminarBannerCreateManySeminarInputEnvelope
    connect?: SeminarBannerWhereUniqueInput | SeminarBannerWhereUniqueInput[]
  }

  export type SeminarAttendeeCreateNestedManyWithoutSeminarInput = {
    create?: XOR<SeminarAttendeeCreateWithoutSeminarInput, SeminarAttendeeUncheckedCreateWithoutSeminarInput> | SeminarAttendeeCreateWithoutSeminarInput[] | SeminarAttendeeUncheckedCreateWithoutSeminarInput[]
    connectOrCreate?: SeminarAttendeeCreateOrConnectWithoutSeminarInput | SeminarAttendeeCreateOrConnectWithoutSeminarInput[]
    createMany?: SeminarAttendeeCreateManySeminarInputEnvelope
    connect?: SeminarAttendeeWhereUniqueInput | SeminarAttendeeWhereUniqueInput[]
  }

  export type SeminarInvitationCreateNestedManyWithoutSeminarInput = {
    create?: XOR<SeminarInvitationCreateWithoutSeminarInput, SeminarInvitationUncheckedCreateWithoutSeminarInput> | SeminarInvitationCreateWithoutSeminarInput[] | SeminarInvitationUncheckedCreateWithoutSeminarInput[]
    connectOrCreate?: SeminarInvitationCreateOrConnectWithoutSeminarInput | SeminarInvitationCreateOrConnectWithoutSeminarInput[]
    createMany?: SeminarInvitationCreateManySeminarInputEnvelope
    connect?: SeminarInvitationWhereUniqueInput | SeminarInvitationWhereUniqueInput[]
  }

  export type SeminarSessionCreateNestedManyWithoutSeminarInput = {
    create?: XOR<SeminarSessionCreateWithoutSeminarInput, SeminarSessionUncheckedCreateWithoutSeminarInput> | SeminarSessionCreateWithoutSeminarInput[] | SeminarSessionUncheckedCreateWithoutSeminarInput[]
    connectOrCreate?: SeminarSessionCreateOrConnectWithoutSeminarInput | SeminarSessionCreateOrConnectWithoutSeminarInput[]
    createMany?: SeminarSessionCreateManySeminarInputEnvelope
    connect?: SeminarSessionWhereUniqueInput | SeminarSessionWhereUniqueInput[]
  }

  export type SeminarBannerUncheckedCreateNestedManyWithoutSeminarInput = {
    create?: XOR<SeminarBannerCreateWithoutSeminarInput, SeminarBannerUncheckedCreateWithoutSeminarInput> | SeminarBannerCreateWithoutSeminarInput[] | SeminarBannerUncheckedCreateWithoutSeminarInput[]
    connectOrCreate?: SeminarBannerCreateOrConnectWithoutSeminarInput | SeminarBannerCreateOrConnectWithoutSeminarInput[]
    createMany?: SeminarBannerCreateManySeminarInputEnvelope
    connect?: SeminarBannerWhereUniqueInput | SeminarBannerWhereUniqueInput[]
  }

  export type SeminarAttendeeUncheckedCreateNestedManyWithoutSeminarInput = {
    create?: XOR<SeminarAttendeeCreateWithoutSeminarInput, SeminarAttendeeUncheckedCreateWithoutSeminarInput> | SeminarAttendeeCreateWithoutSeminarInput[] | SeminarAttendeeUncheckedCreateWithoutSeminarInput[]
    connectOrCreate?: SeminarAttendeeCreateOrConnectWithoutSeminarInput | SeminarAttendeeCreateOrConnectWithoutSeminarInput[]
    createMany?: SeminarAttendeeCreateManySeminarInputEnvelope
    connect?: SeminarAttendeeWhereUniqueInput | SeminarAttendeeWhereUniqueInput[]
  }

  export type SeminarInvitationUncheckedCreateNestedManyWithoutSeminarInput = {
    create?: XOR<SeminarInvitationCreateWithoutSeminarInput, SeminarInvitationUncheckedCreateWithoutSeminarInput> | SeminarInvitationCreateWithoutSeminarInput[] | SeminarInvitationUncheckedCreateWithoutSeminarInput[]
    connectOrCreate?: SeminarInvitationCreateOrConnectWithoutSeminarInput | SeminarInvitationCreateOrConnectWithoutSeminarInput[]
    createMany?: SeminarInvitationCreateManySeminarInputEnvelope
    connect?: SeminarInvitationWhereUniqueInput | SeminarInvitationWhereUniqueInput[]
  }

  export type SeminarSessionUncheckedCreateNestedManyWithoutSeminarInput = {
    create?: XOR<SeminarSessionCreateWithoutSeminarInput, SeminarSessionUncheckedCreateWithoutSeminarInput> | SeminarSessionCreateWithoutSeminarInput[] | SeminarSessionUncheckedCreateWithoutSeminarInput[]
    connectOrCreate?: SeminarSessionCreateOrConnectWithoutSeminarInput | SeminarSessionCreateOrConnectWithoutSeminarInput[]
    createMany?: SeminarSessionCreateManySeminarInputEnvelope
    connect?: SeminarSessionWhereUniqueInput | SeminarSessionWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type SeminarBannerUpdateManyWithoutSeminarNestedInput = {
    create?: XOR<SeminarBannerCreateWithoutSeminarInput, SeminarBannerUncheckedCreateWithoutSeminarInput> | SeminarBannerCreateWithoutSeminarInput[] | SeminarBannerUncheckedCreateWithoutSeminarInput[]
    connectOrCreate?: SeminarBannerCreateOrConnectWithoutSeminarInput | SeminarBannerCreateOrConnectWithoutSeminarInput[]
    upsert?: SeminarBannerUpsertWithWhereUniqueWithoutSeminarInput | SeminarBannerUpsertWithWhereUniqueWithoutSeminarInput[]
    createMany?: SeminarBannerCreateManySeminarInputEnvelope
    set?: SeminarBannerWhereUniqueInput | SeminarBannerWhereUniqueInput[]
    disconnect?: SeminarBannerWhereUniqueInput | SeminarBannerWhereUniqueInput[]
    delete?: SeminarBannerWhereUniqueInput | SeminarBannerWhereUniqueInput[]
    connect?: SeminarBannerWhereUniqueInput | SeminarBannerWhereUniqueInput[]
    update?: SeminarBannerUpdateWithWhereUniqueWithoutSeminarInput | SeminarBannerUpdateWithWhereUniqueWithoutSeminarInput[]
    updateMany?: SeminarBannerUpdateManyWithWhereWithoutSeminarInput | SeminarBannerUpdateManyWithWhereWithoutSeminarInput[]
    deleteMany?: SeminarBannerScalarWhereInput | SeminarBannerScalarWhereInput[]
  }

  export type SeminarAttendeeUpdateManyWithoutSeminarNestedInput = {
    create?: XOR<SeminarAttendeeCreateWithoutSeminarInput, SeminarAttendeeUncheckedCreateWithoutSeminarInput> | SeminarAttendeeCreateWithoutSeminarInput[] | SeminarAttendeeUncheckedCreateWithoutSeminarInput[]
    connectOrCreate?: SeminarAttendeeCreateOrConnectWithoutSeminarInput | SeminarAttendeeCreateOrConnectWithoutSeminarInput[]
    upsert?: SeminarAttendeeUpsertWithWhereUniqueWithoutSeminarInput | SeminarAttendeeUpsertWithWhereUniqueWithoutSeminarInput[]
    createMany?: SeminarAttendeeCreateManySeminarInputEnvelope
    set?: SeminarAttendeeWhereUniqueInput | SeminarAttendeeWhereUniqueInput[]
    disconnect?: SeminarAttendeeWhereUniqueInput | SeminarAttendeeWhereUniqueInput[]
    delete?: SeminarAttendeeWhereUniqueInput | SeminarAttendeeWhereUniqueInput[]
    connect?: SeminarAttendeeWhereUniqueInput | SeminarAttendeeWhereUniqueInput[]
    update?: SeminarAttendeeUpdateWithWhereUniqueWithoutSeminarInput | SeminarAttendeeUpdateWithWhereUniqueWithoutSeminarInput[]
    updateMany?: SeminarAttendeeUpdateManyWithWhereWithoutSeminarInput | SeminarAttendeeUpdateManyWithWhereWithoutSeminarInput[]
    deleteMany?: SeminarAttendeeScalarWhereInput | SeminarAttendeeScalarWhereInput[]
  }

  export type SeminarInvitationUpdateManyWithoutSeminarNestedInput = {
    create?: XOR<SeminarInvitationCreateWithoutSeminarInput, SeminarInvitationUncheckedCreateWithoutSeminarInput> | SeminarInvitationCreateWithoutSeminarInput[] | SeminarInvitationUncheckedCreateWithoutSeminarInput[]
    connectOrCreate?: SeminarInvitationCreateOrConnectWithoutSeminarInput | SeminarInvitationCreateOrConnectWithoutSeminarInput[]
    upsert?: SeminarInvitationUpsertWithWhereUniqueWithoutSeminarInput | SeminarInvitationUpsertWithWhereUniqueWithoutSeminarInput[]
    createMany?: SeminarInvitationCreateManySeminarInputEnvelope
    set?: SeminarInvitationWhereUniqueInput | SeminarInvitationWhereUniqueInput[]
    disconnect?: SeminarInvitationWhereUniqueInput | SeminarInvitationWhereUniqueInput[]
    delete?: SeminarInvitationWhereUniqueInput | SeminarInvitationWhereUniqueInput[]
    connect?: SeminarInvitationWhereUniqueInput | SeminarInvitationWhereUniqueInput[]
    update?: SeminarInvitationUpdateWithWhereUniqueWithoutSeminarInput | SeminarInvitationUpdateWithWhereUniqueWithoutSeminarInput[]
    updateMany?: SeminarInvitationUpdateManyWithWhereWithoutSeminarInput | SeminarInvitationUpdateManyWithWhereWithoutSeminarInput[]
    deleteMany?: SeminarInvitationScalarWhereInput | SeminarInvitationScalarWhereInput[]
  }

  export type SeminarSessionUpdateManyWithoutSeminarNestedInput = {
    create?: XOR<SeminarSessionCreateWithoutSeminarInput, SeminarSessionUncheckedCreateWithoutSeminarInput> | SeminarSessionCreateWithoutSeminarInput[] | SeminarSessionUncheckedCreateWithoutSeminarInput[]
    connectOrCreate?: SeminarSessionCreateOrConnectWithoutSeminarInput | SeminarSessionCreateOrConnectWithoutSeminarInput[]
    upsert?: SeminarSessionUpsertWithWhereUniqueWithoutSeminarInput | SeminarSessionUpsertWithWhereUniqueWithoutSeminarInput[]
    createMany?: SeminarSessionCreateManySeminarInputEnvelope
    set?: SeminarSessionWhereUniqueInput | SeminarSessionWhereUniqueInput[]
    disconnect?: SeminarSessionWhereUniqueInput | SeminarSessionWhereUniqueInput[]
    delete?: SeminarSessionWhereUniqueInput | SeminarSessionWhereUniqueInput[]
    connect?: SeminarSessionWhereUniqueInput | SeminarSessionWhereUniqueInput[]
    update?: SeminarSessionUpdateWithWhereUniqueWithoutSeminarInput | SeminarSessionUpdateWithWhereUniqueWithoutSeminarInput[]
    updateMany?: SeminarSessionUpdateManyWithWhereWithoutSeminarInput | SeminarSessionUpdateManyWithWhereWithoutSeminarInput[]
    deleteMany?: SeminarSessionScalarWhereInput | SeminarSessionScalarWhereInput[]
  }

  export type SeminarBannerUncheckedUpdateManyWithoutSeminarNestedInput = {
    create?: XOR<SeminarBannerCreateWithoutSeminarInput, SeminarBannerUncheckedCreateWithoutSeminarInput> | SeminarBannerCreateWithoutSeminarInput[] | SeminarBannerUncheckedCreateWithoutSeminarInput[]
    connectOrCreate?: SeminarBannerCreateOrConnectWithoutSeminarInput | SeminarBannerCreateOrConnectWithoutSeminarInput[]
    upsert?: SeminarBannerUpsertWithWhereUniqueWithoutSeminarInput | SeminarBannerUpsertWithWhereUniqueWithoutSeminarInput[]
    createMany?: SeminarBannerCreateManySeminarInputEnvelope
    set?: SeminarBannerWhereUniqueInput | SeminarBannerWhereUniqueInput[]
    disconnect?: SeminarBannerWhereUniqueInput | SeminarBannerWhereUniqueInput[]
    delete?: SeminarBannerWhereUniqueInput | SeminarBannerWhereUniqueInput[]
    connect?: SeminarBannerWhereUniqueInput | SeminarBannerWhereUniqueInput[]
    update?: SeminarBannerUpdateWithWhereUniqueWithoutSeminarInput | SeminarBannerUpdateWithWhereUniqueWithoutSeminarInput[]
    updateMany?: SeminarBannerUpdateManyWithWhereWithoutSeminarInput | SeminarBannerUpdateManyWithWhereWithoutSeminarInput[]
    deleteMany?: SeminarBannerScalarWhereInput | SeminarBannerScalarWhereInput[]
  }

  export type SeminarAttendeeUncheckedUpdateManyWithoutSeminarNestedInput = {
    create?: XOR<SeminarAttendeeCreateWithoutSeminarInput, SeminarAttendeeUncheckedCreateWithoutSeminarInput> | SeminarAttendeeCreateWithoutSeminarInput[] | SeminarAttendeeUncheckedCreateWithoutSeminarInput[]
    connectOrCreate?: SeminarAttendeeCreateOrConnectWithoutSeminarInput | SeminarAttendeeCreateOrConnectWithoutSeminarInput[]
    upsert?: SeminarAttendeeUpsertWithWhereUniqueWithoutSeminarInput | SeminarAttendeeUpsertWithWhereUniqueWithoutSeminarInput[]
    createMany?: SeminarAttendeeCreateManySeminarInputEnvelope
    set?: SeminarAttendeeWhereUniqueInput | SeminarAttendeeWhereUniqueInput[]
    disconnect?: SeminarAttendeeWhereUniqueInput | SeminarAttendeeWhereUniqueInput[]
    delete?: SeminarAttendeeWhereUniqueInput | SeminarAttendeeWhereUniqueInput[]
    connect?: SeminarAttendeeWhereUniqueInput | SeminarAttendeeWhereUniqueInput[]
    update?: SeminarAttendeeUpdateWithWhereUniqueWithoutSeminarInput | SeminarAttendeeUpdateWithWhereUniqueWithoutSeminarInput[]
    updateMany?: SeminarAttendeeUpdateManyWithWhereWithoutSeminarInput | SeminarAttendeeUpdateManyWithWhereWithoutSeminarInput[]
    deleteMany?: SeminarAttendeeScalarWhereInput | SeminarAttendeeScalarWhereInput[]
  }

  export type SeminarInvitationUncheckedUpdateManyWithoutSeminarNestedInput = {
    create?: XOR<SeminarInvitationCreateWithoutSeminarInput, SeminarInvitationUncheckedCreateWithoutSeminarInput> | SeminarInvitationCreateWithoutSeminarInput[] | SeminarInvitationUncheckedCreateWithoutSeminarInput[]
    connectOrCreate?: SeminarInvitationCreateOrConnectWithoutSeminarInput | SeminarInvitationCreateOrConnectWithoutSeminarInput[]
    upsert?: SeminarInvitationUpsertWithWhereUniqueWithoutSeminarInput | SeminarInvitationUpsertWithWhereUniqueWithoutSeminarInput[]
    createMany?: SeminarInvitationCreateManySeminarInputEnvelope
    set?: SeminarInvitationWhereUniqueInput | SeminarInvitationWhereUniqueInput[]
    disconnect?: SeminarInvitationWhereUniqueInput | SeminarInvitationWhereUniqueInput[]
    delete?: SeminarInvitationWhereUniqueInput | SeminarInvitationWhereUniqueInput[]
    connect?: SeminarInvitationWhereUniqueInput | SeminarInvitationWhereUniqueInput[]
    update?: SeminarInvitationUpdateWithWhereUniqueWithoutSeminarInput | SeminarInvitationUpdateWithWhereUniqueWithoutSeminarInput[]
    updateMany?: SeminarInvitationUpdateManyWithWhereWithoutSeminarInput | SeminarInvitationUpdateManyWithWhereWithoutSeminarInput[]
    deleteMany?: SeminarInvitationScalarWhereInput | SeminarInvitationScalarWhereInput[]
  }

  export type SeminarSessionUncheckedUpdateManyWithoutSeminarNestedInput = {
    create?: XOR<SeminarSessionCreateWithoutSeminarInput, SeminarSessionUncheckedCreateWithoutSeminarInput> | SeminarSessionCreateWithoutSeminarInput[] | SeminarSessionUncheckedCreateWithoutSeminarInput[]
    connectOrCreate?: SeminarSessionCreateOrConnectWithoutSeminarInput | SeminarSessionCreateOrConnectWithoutSeminarInput[]
    upsert?: SeminarSessionUpsertWithWhereUniqueWithoutSeminarInput | SeminarSessionUpsertWithWhereUniqueWithoutSeminarInput[]
    createMany?: SeminarSessionCreateManySeminarInputEnvelope
    set?: SeminarSessionWhereUniqueInput | SeminarSessionWhereUniqueInput[]
    disconnect?: SeminarSessionWhereUniqueInput | SeminarSessionWhereUniqueInput[]
    delete?: SeminarSessionWhereUniqueInput | SeminarSessionWhereUniqueInput[]
    connect?: SeminarSessionWhereUniqueInput | SeminarSessionWhereUniqueInput[]
    update?: SeminarSessionUpdateWithWhereUniqueWithoutSeminarInput | SeminarSessionUpdateWithWhereUniqueWithoutSeminarInput[]
    updateMany?: SeminarSessionUpdateManyWithWhereWithoutSeminarInput | SeminarSessionUpdateManyWithWhereWithoutSeminarInput[]
    deleteMany?: SeminarSessionScalarWhereInput | SeminarSessionScalarWhereInput[]
  }

  export type SeminarCreateNestedOneWithoutBannersInput = {
    create?: XOR<SeminarCreateWithoutBannersInput, SeminarUncheckedCreateWithoutBannersInput>
    connectOrCreate?: SeminarCreateOrConnectWithoutBannersInput
    connect?: SeminarWhereUniqueInput
  }

  export type SeminarUpdateOneRequiredWithoutBannersNestedInput = {
    create?: XOR<SeminarCreateWithoutBannersInput, SeminarUncheckedCreateWithoutBannersInput>
    connectOrCreate?: SeminarCreateOrConnectWithoutBannersInput
    upsert?: SeminarUpsertWithoutBannersInput
    connect?: SeminarWhereUniqueInput
    update?: XOR<XOR<SeminarUpdateToOneWithWhereWithoutBannersInput, SeminarUpdateWithoutBannersInput>, SeminarUncheckedUpdateWithoutBannersInput>
  }

  export type SeminarCreateNestedOneWithoutAttendeesInput = {
    create?: XOR<SeminarCreateWithoutAttendeesInput, SeminarUncheckedCreateWithoutAttendeesInput>
    connectOrCreate?: SeminarCreateOrConnectWithoutAttendeesInput
    connect?: SeminarWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type SeminarUpdateOneRequiredWithoutAttendeesNestedInput = {
    create?: XOR<SeminarCreateWithoutAttendeesInput, SeminarUncheckedCreateWithoutAttendeesInput>
    connectOrCreate?: SeminarCreateOrConnectWithoutAttendeesInput
    upsert?: SeminarUpsertWithoutAttendeesInput
    connect?: SeminarWhereUniqueInput
    update?: XOR<XOR<SeminarUpdateToOneWithWhereWithoutAttendeesInput, SeminarUpdateWithoutAttendeesInput>, SeminarUncheckedUpdateWithoutAttendeesInput>
  }

  export type SeminarCreateNestedOneWithoutInvitationsInput = {
    create?: XOR<SeminarCreateWithoutInvitationsInput, SeminarUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: SeminarCreateOrConnectWithoutInvitationsInput
    connect?: SeminarWhereUniqueInput
  }

  export type SeminarUpdateOneRequiredWithoutInvitationsNestedInput = {
    create?: XOR<SeminarCreateWithoutInvitationsInput, SeminarUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: SeminarCreateOrConnectWithoutInvitationsInput
    upsert?: SeminarUpsertWithoutInvitationsInput
    connect?: SeminarWhereUniqueInput
    update?: XOR<XOR<SeminarUpdateToOneWithWhereWithoutInvitationsInput, SeminarUpdateWithoutInvitationsInput>, SeminarUncheckedUpdateWithoutInvitationsInput>
  }

  export type SeminarCreateNestedOneWithoutSessionsInput = {
    create?: XOR<SeminarCreateWithoutSessionsInput, SeminarUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: SeminarCreateOrConnectWithoutSessionsInput
    connect?: SeminarWhereUniqueInput
  }

  export type SeminarUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<SeminarCreateWithoutSessionsInput, SeminarUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: SeminarCreateOrConnectWithoutSessionsInput
    upsert?: SeminarUpsertWithoutSessionsInput
    connect?: SeminarWhereUniqueInput
    update?: XOR<XOR<SeminarUpdateToOneWithWhereWithoutSessionsInput, SeminarUpdateWithoutSessionsInput>, SeminarUncheckedUpdateWithoutSessionsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type SeminarBannerCreateWithoutSeminarInput = {
    image: string
    priority?: number
  }

  export type SeminarBannerUncheckedCreateWithoutSeminarInput = {
    id?: number
    image: string
    priority?: number
  }

  export type SeminarBannerCreateOrConnectWithoutSeminarInput = {
    where: SeminarBannerWhereUniqueInput
    create: XOR<SeminarBannerCreateWithoutSeminarInput, SeminarBannerUncheckedCreateWithoutSeminarInput>
  }

  export type SeminarBannerCreateManySeminarInputEnvelope = {
    data: SeminarBannerCreateManySeminarInput | SeminarBannerCreateManySeminarInput[]
    skipDuplicates?: boolean
  }

  export type SeminarAttendeeCreateWithoutSeminarInput = {
    name: string
    email: string
    phone: string
    checkedIn?: boolean
    checkinTime?: string | null
  }

  export type SeminarAttendeeUncheckedCreateWithoutSeminarInput = {
    id?: number
    name: string
    email: string
    phone: string
    checkedIn?: boolean
    checkinTime?: string | null
  }

  export type SeminarAttendeeCreateOrConnectWithoutSeminarInput = {
    where: SeminarAttendeeWhereUniqueInput
    create: XOR<SeminarAttendeeCreateWithoutSeminarInput, SeminarAttendeeUncheckedCreateWithoutSeminarInput>
  }

  export type SeminarAttendeeCreateManySeminarInputEnvelope = {
    data: SeminarAttendeeCreateManySeminarInput | SeminarAttendeeCreateManySeminarInput[]
    skipDuplicates?: boolean
  }

  export type SeminarInvitationCreateWithoutSeminarInput = {
    sent?: number
    opened?: number
    registered?: number
    date: string
  }

  export type SeminarInvitationUncheckedCreateWithoutSeminarInput = {
    id?: number
    sent?: number
    opened?: number
    registered?: number
    date: string
  }

  export type SeminarInvitationCreateOrConnectWithoutSeminarInput = {
    where: SeminarInvitationWhereUniqueInput
    create: XOR<SeminarInvitationCreateWithoutSeminarInput, SeminarInvitationUncheckedCreateWithoutSeminarInput>
  }

  export type SeminarInvitationCreateManySeminarInputEnvelope = {
    data: SeminarInvitationCreateManySeminarInput | SeminarInvitationCreateManySeminarInput[]
    skipDuplicates?: boolean
  }

  export type SeminarSessionCreateWithoutSeminarInput = {
    time: string
    topic: string
    speaker: string
  }

  export type SeminarSessionUncheckedCreateWithoutSeminarInput = {
    id?: number
    time: string
    topic: string
    speaker: string
  }

  export type SeminarSessionCreateOrConnectWithoutSeminarInput = {
    where: SeminarSessionWhereUniqueInput
    create: XOR<SeminarSessionCreateWithoutSeminarInput, SeminarSessionUncheckedCreateWithoutSeminarInput>
  }

  export type SeminarSessionCreateManySeminarInputEnvelope = {
    data: SeminarSessionCreateManySeminarInput | SeminarSessionCreateManySeminarInput[]
    skipDuplicates?: boolean
  }

  export type SeminarBannerUpsertWithWhereUniqueWithoutSeminarInput = {
    where: SeminarBannerWhereUniqueInput
    update: XOR<SeminarBannerUpdateWithoutSeminarInput, SeminarBannerUncheckedUpdateWithoutSeminarInput>
    create: XOR<SeminarBannerCreateWithoutSeminarInput, SeminarBannerUncheckedCreateWithoutSeminarInput>
  }

  export type SeminarBannerUpdateWithWhereUniqueWithoutSeminarInput = {
    where: SeminarBannerWhereUniqueInput
    data: XOR<SeminarBannerUpdateWithoutSeminarInput, SeminarBannerUncheckedUpdateWithoutSeminarInput>
  }

  export type SeminarBannerUpdateManyWithWhereWithoutSeminarInput = {
    where: SeminarBannerScalarWhereInput
    data: XOR<SeminarBannerUpdateManyMutationInput, SeminarBannerUncheckedUpdateManyWithoutSeminarInput>
  }

  export type SeminarBannerScalarWhereInput = {
    AND?: SeminarBannerScalarWhereInput | SeminarBannerScalarWhereInput[]
    OR?: SeminarBannerScalarWhereInput[]
    NOT?: SeminarBannerScalarWhereInput | SeminarBannerScalarWhereInput[]
    id?: IntFilter<"SeminarBanner"> | number
    seminarId?: IntFilter<"SeminarBanner"> | number
    image?: StringFilter<"SeminarBanner"> | string
    priority?: IntFilter<"SeminarBanner"> | number
  }

  export type SeminarAttendeeUpsertWithWhereUniqueWithoutSeminarInput = {
    where: SeminarAttendeeWhereUniqueInput
    update: XOR<SeminarAttendeeUpdateWithoutSeminarInput, SeminarAttendeeUncheckedUpdateWithoutSeminarInput>
    create: XOR<SeminarAttendeeCreateWithoutSeminarInput, SeminarAttendeeUncheckedCreateWithoutSeminarInput>
  }

  export type SeminarAttendeeUpdateWithWhereUniqueWithoutSeminarInput = {
    where: SeminarAttendeeWhereUniqueInput
    data: XOR<SeminarAttendeeUpdateWithoutSeminarInput, SeminarAttendeeUncheckedUpdateWithoutSeminarInput>
  }

  export type SeminarAttendeeUpdateManyWithWhereWithoutSeminarInput = {
    where: SeminarAttendeeScalarWhereInput
    data: XOR<SeminarAttendeeUpdateManyMutationInput, SeminarAttendeeUncheckedUpdateManyWithoutSeminarInput>
  }

  export type SeminarAttendeeScalarWhereInput = {
    AND?: SeminarAttendeeScalarWhereInput | SeminarAttendeeScalarWhereInput[]
    OR?: SeminarAttendeeScalarWhereInput[]
    NOT?: SeminarAttendeeScalarWhereInput | SeminarAttendeeScalarWhereInput[]
    id?: IntFilter<"SeminarAttendee"> | number
    seminarId?: IntFilter<"SeminarAttendee"> | number
    name?: StringFilter<"SeminarAttendee"> | string
    email?: StringFilter<"SeminarAttendee"> | string
    phone?: StringFilter<"SeminarAttendee"> | string
    checkedIn?: BoolFilter<"SeminarAttendee"> | boolean
    checkinTime?: StringNullableFilter<"SeminarAttendee"> | string | null
  }

  export type SeminarInvitationUpsertWithWhereUniqueWithoutSeminarInput = {
    where: SeminarInvitationWhereUniqueInput
    update: XOR<SeminarInvitationUpdateWithoutSeminarInput, SeminarInvitationUncheckedUpdateWithoutSeminarInput>
    create: XOR<SeminarInvitationCreateWithoutSeminarInput, SeminarInvitationUncheckedCreateWithoutSeminarInput>
  }

  export type SeminarInvitationUpdateWithWhereUniqueWithoutSeminarInput = {
    where: SeminarInvitationWhereUniqueInput
    data: XOR<SeminarInvitationUpdateWithoutSeminarInput, SeminarInvitationUncheckedUpdateWithoutSeminarInput>
  }

  export type SeminarInvitationUpdateManyWithWhereWithoutSeminarInput = {
    where: SeminarInvitationScalarWhereInput
    data: XOR<SeminarInvitationUpdateManyMutationInput, SeminarInvitationUncheckedUpdateManyWithoutSeminarInput>
  }

  export type SeminarInvitationScalarWhereInput = {
    AND?: SeminarInvitationScalarWhereInput | SeminarInvitationScalarWhereInput[]
    OR?: SeminarInvitationScalarWhereInput[]
    NOT?: SeminarInvitationScalarWhereInput | SeminarInvitationScalarWhereInput[]
    id?: IntFilter<"SeminarInvitation"> | number
    seminarId?: IntFilter<"SeminarInvitation"> | number
    sent?: IntFilter<"SeminarInvitation"> | number
    opened?: IntFilter<"SeminarInvitation"> | number
    registered?: IntFilter<"SeminarInvitation"> | number
    date?: StringFilter<"SeminarInvitation"> | string
  }

  export type SeminarSessionUpsertWithWhereUniqueWithoutSeminarInput = {
    where: SeminarSessionWhereUniqueInput
    update: XOR<SeminarSessionUpdateWithoutSeminarInput, SeminarSessionUncheckedUpdateWithoutSeminarInput>
    create: XOR<SeminarSessionCreateWithoutSeminarInput, SeminarSessionUncheckedCreateWithoutSeminarInput>
  }

  export type SeminarSessionUpdateWithWhereUniqueWithoutSeminarInput = {
    where: SeminarSessionWhereUniqueInput
    data: XOR<SeminarSessionUpdateWithoutSeminarInput, SeminarSessionUncheckedUpdateWithoutSeminarInput>
  }

  export type SeminarSessionUpdateManyWithWhereWithoutSeminarInput = {
    where: SeminarSessionScalarWhereInput
    data: XOR<SeminarSessionUpdateManyMutationInput, SeminarSessionUncheckedUpdateManyWithoutSeminarInput>
  }

  export type SeminarSessionScalarWhereInput = {
    AND?: SeminarSessionScalarWhereInput | SeminarSessionScalarWhereInput[]
    OR?: SeminarSessionScalarWhereInput[]
    NOT?: SeminarSessionScalarWhereInput | SeminarSessionScalarWhereInput[]
    id?: IntFilter<"SeminarSession"> | number
    seminarId?: IntFilter<"SeminarSession"> | number
    time?: StringFilter<"SeminarSession"> | string
    topic?: StringFilter<"SeminarSession"> | string
    speaker?: StringFilter<"SeminarSession"> | string
  }

  export type SeminarCreateWithoutBannersInput = {
    title: string
    date: string
    location: string
    capacity: number
    registrations?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    attendees?: SeminarAttendeeCreateNestedManyWithoutSeminarInput
    invitations?: SeminarInvitationCreateNestedManyWithoutSeminarInput
    sessions?: SeminarSessionCreateNestedManyWithoutSeminarInput
  }

  export type SeminarUncheckedCreateWithoutBannersInput = {
    id?: number
    title: string
    date: string
    location: string
    capacity: number
    registrations?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    attendees?: SeminarAttendeeUncheckedCreateNestedManyWithoutSeminarInput
    invitations?: SeminarInvitationUncheckedCreateNestedManyWithoutSeminarInput
    sessions?: SeminarSessionUncheckedCreateNestedManyWithoutSeminarInput
  }

  export type SeminarCreateOrConnectWithoutBannersInput = {
    where: SeminarWhereUniqueInput
    create: XOR<SeminarCreateWithoutBannersInput, SeminarUncheckedCreateWithoutBannersInput>
  }

  export type SeminarUpsertWithoutBannersInput = {
    update: XOR<SeminarUpdateWithoutBannersInput, SeminarUncheckedUpdateWithoutBannersInput>
    create: XOR<SeminarCreateWithoutBannersInput, SeminarUncheckedCreateWithoutBannersInput>
    where?: SeminarWhereInput
  }

  export type SeminarUpdateToOneWithWhereWithoutBannersInput = {
    where?: SeminarWhereInput
    data: XOR<SeminarUpdateWithoutBannersInput, SeminarUncheckedUpdateWithoutBannersInput>
  }

  export type SeminarUpdateWithoutBannersInput = {
    title?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    registrations?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendees?: SeminarAttendeeUpdateManyWithoutSeminarNestedInput
    invitations?: SeminarInvitationUpdateManyWithoutSeminarNestedInput
    sessions?: SeminarSessionUpdateManyWithoutSeminarNestedInput
  }

  export type SeminarUncheckedUpdateWithoutBannersInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    registrations?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendees?: SeminarAttendeeUncheckedUpdateManyWithoutSeminarNestedInput
    invitations?: SeminarInvitationUncheckedUpdateManyWithoutSeminarNestedInput
    sessions?: SeminarSessionUncheckedUpdateManyWithoutSeminarNestedInput
  }

  export type SeminarCreateWithoutAttendeesInput = {
    title: string
    date: string
    location: string
    capacity: number
    registrations?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    banners?: SeminarBannerCreateNestedManyWithoutSeminarInput
    invitations?: SeminarInvitationCreateNestedManyWithoutSeminarInput
    sessions?: SeminarSessionCreateNestedManyWithoutSeminarInput
  }

  export type SeminarUncheckedCreateWithoutAttendeesInput = {
    id?: number
    title: string
    date: string
    location: string
    capacity: number
    registrations?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    banners?: SeminarBannerUncheckedCreateNestedManyWithoutSeminarInput
    invitations?: SeminarInvitationUncheckedCreateNestedManyWithoutSeminarInput
    sessions?: SeminarSessionUncheckedCreateNestedManyWithoutSeminarInput
  }

  export type SeminarCreateOrConnectWithoutAttendeesInput = {
    where: SeminarWhereUniqueInput
    create: XOR<SeminarCreateWithoutAttendeesInput, SeminarUncheckedCreateWithoutAttendeesInput>
  }

  export type SeminarUpsertWithoutAttendeesInput = {
    update: XOR<SeminarUpdateWithoutAttendeesInput, SeminarUncheckedUpdateWithoutAttendeesInput>
    create: XOR<SeminarCreateWithoutAttendeesInput, SeminarUncheckedCreateWithoutAttendeesInput>
    where?: SeminarWhereInput
  }

  export type SeminarUpdateToOneWithWhereWithoutAttendeesInput = {
    where?: SeminarWhereInput
    data: XOR<SeminarUpdateWithoutAttendeesInput, SeminarUncheckedUpdateWithoutAttendeesInput>
  }

  export type SeminarUpdateWithoutAttendeesInput = {
    title?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    registrations?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    banners?: SeminarBannerUpdateManyWithoutSeminarNestedInput
    invitations?: SeminarInvitationUpdateManyWithoutSeminarNestedInput
    sessions?: SeminarSessionUpdateManyWithoutSeminarNestedInput
  }

  export type SeminarUncheckedUpdateWithoutAttendeesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    registrations?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    banners?: SeminarBannerUncheckedUpdateManyWithoutSeminarNestedInput
    invitations?: SeminarInvitationUncheckedUpdateManyWithoutSeminarNestedInput
    sessions?: SeminarSessionUncheckedUpdateManyWithoutSeminarNestedInput
  }

  export type SeminarCreateWithoutInvitationsInput = {
    title: string
    date: string
    location: string
    capacity: number
    registrations?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    banners?: SeminarBannerCreateNestedManyWithoutSeminarInput
    attendees?: SeminarAttendeeCreateNestedManyWithoutSeminarInput
    sessions?: SeminarSessionCreateNestedManyWithoutSeminarInput
  }

  export type SeminarUncheckedCreateWithoutInvitationsInput = {
    id?: number
    title: string
    date: string
    location: string
    capacity: number
    registrations?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    banners?: SeminarBannerUncheckedCreateNestedManyWithoutSeminarInput
    attendees?: SeminarAttendeeUncheckedCreateNestedManyWithoutSeminarInput
    sessions?: SeminarSessionUncheckedCreateNestedManyWithoutSeminarInput
  }

  export type SeminarCreateOrConnectWithoutInvitationsInput = {
    where: SeminarWhereUniqueInput
    create: XOR<SeminarCreateWithoutInvitationsInput, SeminarUncheckedCreateWithoutInvitationsInput>
  }

  export type SeminarUpsertWithoutInvitationsInput = {
    update: XOR<SeminarUpdateWithoutInvitationsInput, SeminarUncheckedUpdateWithoutInvitationsInput>
    create: XOR<SeminarCreateWithoutInvitationsInput, SeminarUncheckedCreateWithoutInvitationsInput>
    where?: SeminarWhereInput
  }

  export type SeminarUpdateToOneWithWhereWithoutInvitationsInput = {
    where?: SeminarWhereInput
    data: XOR<SeminarUpdateWithoutInvitationsInput, SeminarUncheckedUpdateWithoutInvitationsInput>
  }

  export type SeminarUpdateWithoutInvitationsInput = {
    title?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    registrations?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    banners?: SeminarBannerUpdateManyWithoutSeminarNestedInput
    attendees?: SeminarAttendeeUpdateManyWithoutSeminarNestedInput
    sessions?: SeminarSessionUpdateManyWithoutSeminarNestedInput
  }

  export type SeminarUncheckedUpdateWithoutInvitationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    registrations?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    banners?: SeminarBannerUncheckedUpdateManyWithoutSeminarNestedInput
    attendees?: SeminarAttendeeUncheckedUpdateManyWithoutSeminarNestedInput
    sessions?: SeminarSessionUncheckedUpdateManyWithoutSeminarNestedInput
  }

  export type SeminarCreateWithoutSessionsInput = {
    title: string
    date: string
    location: string
    capacity: number
    registrations?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    banners?: SeminarBannerCreateNestedManyWithoutSeminarInput
    attendees?: SeminarAttendeeCreateNestedManyWithoutSeminarInput
    invitations?: SeminarInvitationCreateNestedManyWithoutSeminarInput
  }

  export type SeminarUncheckedCreateWithoutSessionsInput = {
    id?: number
    title: string
    date: string
    location: string
    capacity: number
    registrations?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    banners?: SeminarBannerUncheckedCreateNestedManyWithoutSeminarInput
    attendees?: SeminarAttendeeUncheckedCreateNestedManyWithoutSeminarInput
    invitations?: SeminarInvitationUncheckedCreateNestedManyWithoutSeminarInput
  }

  export type SeminarCreateOrConnectWithoutSessionsInput = {
    where: SeminarWhereUniqueInput
    create: XOR<SeminarCreateWithoutSessionsInput, SeminarUncheckedCreateWithoutSessionsInput>
  }

  export type SeminarUpsertWithoutSessionsInput = {
    update: XOR<SeminarUpdateWithoutSessionsInput, SeminarUncheckedUpdateWithoutSessionsInput>
    create: XOR<SeminarCreateWithoutSessionsInput, SeminarUncheckedCreateWithoutSessionsInput>
    where?: SeminarWhereInput
  }

  export type SeminarUpdateToOneWithWhereWithoutSessionsInput = {
    where?: SeminarWhereInput
    data: XOR<SeminarUpdateWithoutSessionsInput, SeminarUncheckedUpdateWithoutSessionsInput>
  }

  export type SeminarUpdateWithoutSessionsInput = {
    title?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    registrations?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    banners?: SeminarBannerUpdateManyWithoutSeminarNestedInput
    attendees?: SeminarAttendeeUpdateManyWithoutSeminarNestedInput
    invitations?: SeminarInvitationUpdateManyWithoutSeminarNestedInput
  }

  export type SeminarUncheckedUpdateWithoutSessionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    registrations?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    banners?: SeminarBannerUncheckedUpdateManyWithoutSeminarNestedInput
    attendees?: SeminarAttendeeUncheckedUpdateManyWithoutSeminarNestedInput
    invitations?: SeminarInvitationUncheckedUpdateManyWithoutSeminarNestedInput
  }

  export type SeminarBannerCreateManySeminarInput = {
    id?: number
    image: string
    priority?: number
  }

  export type SeminarAttendeeCreateManySeminarInput = {
    id?: number
    name: string
    email: string
    phone: string
    checkedIn?: boolean
    checkinTime?: string | null
  }

  export type SeminarInvitationCreateManySeminarInput = {
    id?: number
    sent?: number
    opened?: number
    registered?: number
    date: string
  }

  export type SeminarSessionCreateManySeminarInput = {
    id?: number
    time: string
    topic: string
    speaker: string
  }

  export type SeminarBannerUpdateWithoutSeminarInput = {
    image?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
  }

  export type SeminarBannerUncheckedUpdateWithoutSeminarInput = {
    id?: IntFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
  }

  export type SeminarBannerUncheckedUpdateManyWithoutSeminarInput = {
    id?: IntFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
  }

  export type SeminarAttendeeUpdateWithoutSeminarInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    checkedIn?: BoolFieldUpdateOperationsInput | boolean
    checkinTime?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SeminarAttendeeUncheckedUpdateWithoutSeminarInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    checkedIn?: BoolFieldUpdateOperationsInput | boolean
    checkinTime?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SeminarAttendeeUncheckedUpdateManyWithoutSeminarInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    checkedIn?: BoolFieldUpdateOperationsInput | boolean
    checkinTime?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SeminarInvitationUpdateWithoutSeminarInput = {
    sent?: IntFieldUpdateOperationsInput | number
    opened?: IntFieldUpdateOperationsInput | number
    registered?: IntFieldUpdateOperationsInput | number
    date?: StringFieldUpdateOperationsInput | string
  }

  export type SeminarInvitationUncheckedUpdateWithoutSeminarInput = {
    id?: IntFieldUpdateOperationsInput | number
    sent?: IntFieldUpdateOperationsInput | number
    opened?: IntFieldUpdateOperationsInput | number
    registered?: IntFieldUpdateOperationsInput | number
    date?: StringFieldUpdateOperationsInput | string
  }

  export type SeminarInvitationUncheckedUpdateManyWithoutSeminarInput = {
    id?: IntFieldUpdateOperationsInput | number
    sent?: IntFieldUpdateOperationsInput | number
    opened?: IntFieldUpdateOperationsInput | number
    registered?: IntFieldUpdateOperationsInput | number
    date?: StringFieldUpdateOperationsInput | string
  }

  export type SeminarSessionUpdateWithoutSeminarInput = {
    time?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    speaker?: StringFieldUpdateOperationsInput | string
  }

  export type SeminarSessionUncheckedUpdateWithoutSeminarInput = {
    id?: IntFieldUpdateOperationsInput | number
    time?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    speaker?: StringFieldUpdateOperationsInput | string
  }

  export type SeminarSessionUncheckedUpdateManyWithoutSeminarInput = {
    id?: IntFieldUpdateOperationsInput | number
    time?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    speaker?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use SeminarCountOutputTypeDefaultArgs instead
     */
    export type SeminarCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SeminarCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SeminarDefaultArgs instead
     */
    export type SeminarArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SeminarDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SeminarBannerDefaultArgs instead
     */
    export type SeminarBannerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SeminarBannerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SeminarAttendeeDefaultArgs instead
     */
    export type SeminarAttendeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SeminarAttendeeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SeminarInvitationDefaultArgs instead
     */
    export type SeminarInvitationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SeminarInvitationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SeminarSessionDefaultArgs instead
     */
    export type SeminarSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SeminarSessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SeminarSpeakerDefaultArgs instead
     */
    export type SeminarSpeakerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SeminarSpeakerDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}